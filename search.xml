<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dubbo进阶（四）：Dubbo注册中心</title>
      <link href="/2020/04/22/Dubbo%E8%BF%9B%E9%98%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ADubbo%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2020/04/22/Dubbo%E8%BF%9B%E9%98%B6%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9ADubbo%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>在Dubbo微服务体系中，注册中心是其核心的组件之一。Dubbo通过注册中心实现了分布式环境中各服务之间的注册与发现，是各个分布式节点之间的纽带。</p><a id="more"></a><p>在Dubbo微服务体系中，注册中心是其核心的组件之一。Dubbo通过注册中心实现了分布式环境中各服务之间的注册与发现，是各个分布式节点之间的纽带。主要作用有：</p><ul><li>动态加入：一个服务提供者通过注册中心可以动态的把自己暴露给其他消费者，无需消费者逐个去更新配置文件。</li><li>动态发现：一个消费者可以动态感知新的配置、路由规则和新的服务提供者，无需重启服务使之生效。</li><li>动态调整：注册中心支持参数的动态调整，新参数自动更新到所有相关服务节点。</li><li>统一配置：避免了本地配置导致每个服务的配置不一致问题。</li></ul><p><code>dubbo</code>主要包含四种注册中心的实现，分别是：<code>Zookeeper</code>、<code>Redis</code>、<code>Simple</code>、<code>Multicast</code>。</p><p>其中<code>Zookeeper</code>是官方推荐的注册中心实现，在生产环境中已经有大量实际使用，具体的实现在Dubbo的源码 dubbo-registry-zookeeper模块中。而Redis注册中心在稳定性方面相比ZK就差了一些，其稳定性主要是依赖Redis本身，阿里内部并没有使用Redis作为注册中心。Simple是一个基于内存的简单的注册中心实现，它本身就是一个标准的RPC服务，不支持集群，可能出现单点故障。Multicast模式则不需要启动任何注册中心，只要通过广播地址，就可以互相发现。服务提供者启动时，会广播自己的地址，消费者启动时，会广播订阅请求，服务提供者收到订阅请求，会根据配置广播或单播给订阅者。</p><h5 id="注册中心的工作流程"><a href="#注册中心的工作流程" class="headerlink" title="注册中心的工作流程"></a>注册中心的工作流程</h5><p><img src="https://img-blog.csdnimg.cn/20200422100258346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>Provider注册</code>：Provider启动时，会向注册中心写入自己的元数据信息，同时会订阅配置元数据信息。</li><li><code>Consumer订阅</code>：这里的订阅指Consumer启动时也会向注册中心写入自己的元数据信息，并订阅服务提供者、路由和配置元数据信息。</li><li><code>服务治理中心启动</code>：dubbo-admin启动时，会同时订阅所有消费者、服务提供者、路由和配置元数据信息。</li><li><code>动态注册、发现</code>：当有新的Provider加入或者有离开时，注册中心服务提供者目录会发生变化，变化信息会动态通知给消费者、服务治理中心。</li><li><code>监控中心采集</code>：当Consumer发起调用时，会异步将调用、统计信息等上报给监控中心。</li></ul><h5 id="zookeeper的原理"><a href="#zookeeper的原理" class="headerlink" title="zookeeper的原理"></a>zookeeper的原理</h5><p><code>zookeeper</code>是树形节点的注册中心，每个节点的类型分为持久节点、持久顺序节点、临时节点、临时顺序节点。</p><ul><li>持久节点：服务注册后保证节点不会丢失，注册中心重启也会存在。</li><li>持久顺序节点：在持久节点特性的基础上增加了节点先后顺序的能力。</li><li>临时节点：服务注册后连接丢失或者session超时，注册的节点会自动消失。</li><li>临时节点顺序：在临时节点特性的基础上增加了节点先后顺序的能力。</li></ul><p>Dubbo使用ZK作为注册中心时，只会创建临时节点和持久节点两种，对创建顺序并没有要求。</p><p>/dubbo/com.foo.BarService/providers是服务提供者在Zookeeper注册中心的路径示例，是一种属性结构，该结构分为四层：root（根节点，对应示例中的dubbo）、service（接口名称，对应示例中的com.foo.BarService）、四种服务目录（对应示例中的providers，其他目录还有consumers、routers、configurators）。在服务分类节点下是具体的Dubbo服务URL。属性结构示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ &#x2F;dubbo</span><br><span class="line">+-- service</span><br><span class="line">+-- providers</span><br><span class="line">+-- consumers</span><br><span class="line">+-- routers</span><br><span class="line">+-- configurators</span><br></pre></td></tr></table></figure><p>树形结构的关系：<br>（1）树的根节点是注册中心分组，下面有多个服务接口，分组值来自用户配置<code>&lt;dubbo:registry&gt;</code>中的group属性，默认是/dubbo.<br>（2）服务接口下包含四类子目录，分别是providers、consumers、routers、configurators，这个路径时持久节点。<br>（3）服务提供者目录（/dubbo/service/providers）下面包含的接口有多个服务提供者URL元数据信息。<br>（4）服务消费者目录（/dubbo/service/consumers）下面包含的解耦有多个消费者URL元数据信息。<br>（5）路由配置目录（/dubbo/service/routers）下面包含多个用于消费者路由策略URL元数据信息。<br>（6）动态配置目录（/dubbo/service/configurators）下面包含多个用于服务者动态配置URL元数据信息。</p><p>树形示意图，如下：<br><img src="https://img-blog.csdnimg.cn/20200422104226376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>配置实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">  &lt;!-- 适用于Zookeeper一个集群有多个节点，多个IP和端口逗号分割--&gt;</span><br><span class="line">  &lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;ip:port,ip:port,ip:port&quot; &#x2F;&gt;</span><br><span class="line">  &lt;!-- 适用于Zookeeper多个集群有多个节点，多个IP和端口用竖线分割--&gt;</span><br><span class="line">  &lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;ip:port|ip:port|ip:port&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><h5 id="zookeeper发布的实现"><a href="#zookeeper发布的实现" class="headerlink" title="zookeeper发布的实现"></a>zookeeper发布的实现</h5><p><code>provider</code>和<code>Consumer</code>需要将自己注册到Zookeeper。服务提供者的注册是为了让消费者订阅（准确来说应该叫感知服务的存在），从而发起远程调用；也上服务治理中心感知有新的服务提供者上线。消费者的发布是为了让服务治理中心可以发现自己。Zookeeper发布订阅代码非常简单，只是调用Zookeeper 的 Client 库在注册中心创建一个目录而已，如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doRegister(URL url) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, true));</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">throw new RpcException(&quot;Failed to register &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消发布对应也很简单，只是把ZK注册中心上对应的路径删除，如下代码所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doUnregister(URL url) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">zkClient.delete(toUrlPath(url));</span><br><span class="line">&#125; catch (Throwable e) &#123;</span><br><span class="line">throw new RpcException(&quot;Failed to unregister &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="zookeeper订阅的实现"><a href="#zookeeper订阅的实现" class="headerlink" title="zookeeper订阅的实现"></a>zookeeper订阅的实现</h5><p>订阅通常有pull和push两种方式，一种是客户端定时轮训注册中心拉取配置，另一种是注册中心主动推送数据给客户端。这两种方式各有利弊，目前Dubbo采用的是第一次启动拉取方式，后续接收事件重新拉取数据。</p><p>在服务暴露时，服务端会订阅configurators用于监听动态配置，在消费端启动时，消费端会订阅providers、routers和configurators这三个目录，分别对应服务提供者、路由和动态配置变更通知。</p><p>Dubbo提供了两种不同ZK开源客户端库的封装，分别对应接口：</p><ul><li>Apache Curator</li><li>zkClient</li></ul><p>我们可以在<code>&lt;dubbo:registry&gt;</code>的client属性中设置curator、zkClient来使用不同的客户端实现库，如果不设置默认使用Curator作为实现。</p><p>Zookeeper客户端采用的是<code>“事件通知” + “客户端拉取”</code>的方式，客户端在第一次连接上注册中心时，会获取对应目录西安全量的数据。并在订阅的节点上注册一个watcher，客户端与注册中心之间保持TCP长连接，后续每个节点有任何数据变化的时候，注册中心会根据watcher的回调主动通知客户端（事件通知），客户端接到通知后，会把对应节点下的全量数据都拉取过来（客户端拉取），这一点在<code>NotifyListener#notify(List&lt;URL&gt; urls)</code>接口上就有说明。全量拉取有一个局限，党委服务节点较多时会对网络造成很大的压力。</p><p>Zookeeper每个节点都有一个版本号，当某个节点的数据发生变化时，对应的版本号就会变化，并触发watcher事件，推送数据给订阅方。版本号强调的是变化次数，即使该节点的值没有变化，只要有更新操作，依然会使版本号变化。</p><p>Zookeeper实现服务订阅的核心代码在ZookeeperRegistry中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void doSubscribe(final URL url, final NotifyListener listener) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">         </span><br><span class="line">           if (ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">         </span><br><span class="line">               &#x2F;***              服务治理中心订阅全部服务               ***&#x2F;</span><br><span class="line"></span><br><span class="line">               &#x2F;&#x2F; 订阅所有数据</span><br><span class="line">               String root &#x3D; toRootPath();</span><br><span class="line">               &#x2F;&#x2F; 获取Listeners</span><br><span class="line">               ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners &#x3D; zkListeners.get(url);</span><br><span class="line">               if (listeners &#x3D;&#x3D; null) &#123;</span><br><span class="line">                   &#x2F;&#x2F; 为获取到监听器，这里创建一个监听器并放入缓存。</span><br><span class="line">                   zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                   listeners &#x3D; zkListeners.get(url);</span><br><span class="line">               &#125;</span><br><span class="line">               ChildListener zkListener &#x3D; listeners.get(listener);</span><br><span class="line">               if (zkListener &#x3D;&#x3D; null) &#123;</span><br><span class="line">                   &#x2F;&#x2F; zkListener为空，说明是第一次，新建一个listener</span><br><span class="line">                   listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; &#123;</span><br><span class="line">                       &#x2F;&#x2F; 这是一个内部类实现，不会立即执行，只会在触发变更通知时执行</span><br><span class="line">                       &#x2F;&#x2F; 如果子节点有变化则会接收到通知，遍历所有子节点</span><br><span class="line">                       for (String child : currentChilds) &#123;</span><br><span class="line">                           child &#x3D; URL.decode(child);</span><br><span class="line">                           &#x2F;&#x2F; 如果存在子节点还未被订阅，说明是新增节点吗，则进行订阅</span><br><span class="line">                           if (!anyServices.contains(child)) &#123;</span><br><span class="line">                               anyServices.add(child);</span><br><span class="line">                                &#x2F;&#x2F; 订阅新节点</span><br><span class="line">                               subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,</span><br><span class="line">                                       Constants.CHECK_KEY, String.valueOf(false)), listener);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">                   zkListener &#x3D; listeners.get(listener);</span><br><span class="line">               &#125;</span><br><span class="line">             &#x2F;&#x2F; 创建持久节点，接下来订阅持久节点的直接子节点</span><br><span class="line">               zkClient.create(root, false);</span><br><span class="line">               List&lt;String&gt; services &#x3D; zkClient.addChildListener(root, zkListener);</span><br><span class="line">               if (CollectionUtils.isNotEmpty(services)) &#123;</span><br><span class="line">                  &#x2F;&#x2F; 遍历所有子节点进行订阅</span><br><span class="line">                   for (String service : services) &#123;</span><br><span class="line">                       service &#x3D; URL.decode(service);</span><br><span class="line">                       anyServices.add(service);</span><br><span class="line">                       subscribe(url.setPath(service).addParameters(INTERFACE_KEY, service,</span><br><span class="line">                               Constants.CHECK_KEY, String.valueOf(false)), listener);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line"></span><br><span class="line">               &#x2F;***             普通消费者服务订阅               ***&#x2F;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">                List&lt;URL&gt; urls &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">               &#x2F;&#x2F;toCategoriesPath(url): 根据url类别，获取一组要订阅的路径</span><br><span class="line">               for (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">                   ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners &#x3D; zkListeners.get(url);</span><br><span class="line">                   if (listeners &#x3D;&#x3D; null) &#123;</span><br><span class="line">                       &#x2F;&#x2F; 如果listeners缓存为空则创建缓存</span><br><span class="line">                       zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                       listeners &#x3D; zkListeners.get(url);</span><br><span class="line">                   &#125;</span><br><span class="line">                   ChildListener zkListener &#x3D; listeners.get(listener);</span><br><span class="line">                   &#x2F;&#x2F; 如果zkListener缓存为空则创建缓存</span><br><span class="line">                   if (zkListener &#x3D;&#x3D; null) &#123;</span><br><span class="line">                       listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)));</span><br><span class="line">                       zkListener &#x3D; listeners.get(listener);</span><br><span class="line">                   &#125;</span><br><span class="line">                   zkClient.create(path, false);</span><br><span class="line">                   &#x2F;&#x2F; 订阅，返回该节点下的子路径并缓存</span><br><span class="line">                   List&lt;String&gt; children &#x3D; zkClient.addChildListener(path, zkListener);</span><br><span class="line">                   if (children !&#x3D; null) &#123;</span><br><span class="line">                       urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               &#x2F;&#x2F; 回调NotifyListener, 更新本地缓存信息</span><br><span class="line">               notify(url, listener, urls);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Throwable e) &#123;</span><br><span class="line">           throw new RpcException(&quot;Failed to subscribe &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="zookeeper的缓存机制"><a href="#zookeeper的缓存机制" class="headerlink" title="zookeeper的缓存机制"></a>zookeeper的缓存机制</h5><p>缓存的存在就是用空间换取时间的一种机制。如果Consumer每次远程调用都要先去注册中心拉取一次可调用的服务列表，则会让注册中心承受巨大的流量压力。另外，每个额外的网络请求也会让整个系统的性能下降，同时服务列表变化的频率本身并不是很高，除非服务提供商对接口做了升级、或是服务节点新增或下线（从某各角度来看这并不是一个很高频的操作），所以每次都拉取也就显得并不那么必要。</p><p>因此针对这个问题，dubbo的注册中心实现了通用的缓存机制，在抽象类AbstractRegistry中实现。AbstractRegistry类结构关系图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200422110514363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>消费者或者服务治理中心获取注册信息后会做本地缓存。内存中会有一份，保存在Properties对象里，磁盘里也会有一份文件，通过file对象引用。在AbstractRegistry抽象类中有如下定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**  本地缓存对象 **&#x2F;</span><br><span class="line">private final Properties properties &#x3D; new Properties();</span><br><span class="line">&#x2F;** 磁盘文件服务缓存对象 **&#x2F;</span><br><span class="line">private File file;</span><br><span class="line">&#x2F;** 内存中的服务缓存对象 **&#x2F;</span><br><span class="line">private final ConcurrentMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt; notified &#x3D; new ConcurrentHashMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure><p>其中内存中的缓存notified是ConcurrentHashMap里面又封装了一个Map，外层Map的key是消费者的URL，内层Map的key是分类，包含了providers、consumers、routers、configutators四种，value则对应的服务列表，对于没有服务提供者提供服务的URL，它会以特殊的empty://前缀了开头。</p><h5 id="zookeeper缓存的加载"><a href="#zookeeper缓存的加载" class="headerlink" title="zookeeper缓存的加载"></a>zookeeper缓存的加载</h5><p>在服务初始化时候，AbstractRegistry构造器函数里会从本地磁盘文件中把持久化的注册数据到Properties对象里，并加载到内存缓存中，核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void loadProperties() &#123;</span><br><span class="line">       if (file !&#x3D; null &amp;&amp; file.exists()) &#123;</span><br><span class="line">           InputStream in &#x3D; null;</span><br><span class="line">           try &#123;</span><br><span class="line">               &#x2F;&#x2F; 读取磁盘文件</span><br><span class="line">               in &#x3D; new FileInputStream(file);</span><br><span class="line">               &#x2F;&#x2F; 把数据写入到内存缓存中</span><br><span class="line">               properties.load(in);</span><br><span class="line">               ……</span><br><span class="line">           &#125; catch (Throwable e) &#123;</span><br><span class="line">               ……</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               ……</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Properties保存了所有服务提供者的URL，使用URL#serviceKey()作为key，提供者列表、路由规则列表、配置规则列表等作为value。如果应用在启动过程中注册中心无法连接或岩机，则Dubbo框架会自动通过本地缓存加载Invokers。</p><h5 id="zookeeper缓存的保存与更新"><a href="#zookeeper缓存的保存与更新" class="headerlink" title="zookeeper缓存的保存与更新"></a>zookeeper缓存的保存与更新</h5><p>缓存的保存有同步和异步两种方式。异步会使用线程池异步保存，如果线程在执行过程中出现异常，则会再次调用线程池不断重试，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(syncSaveFile)&#123;</span><br><span class="line">    &#x2F;&#x2F; 同步保存</span><br><span class="line">    doSaveProperties(version);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 异步保存,放入线程池。会传入一个AtomicLong的版本号保证数据是最新的</span><br><span class="line">    registryCacheExecutor.execute(new SaveProperties(version));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractRegistry#notify 方法中封装了更新内存和本地文件缓存的逻辑。当客户端第一次订阅获取全量数据的时候，或者后续由于订阅的数据发生变更时，都会调用该方法进行保存。</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式，RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo进阶（三）：SpringBoot整合Dubbo构建分布式服务</title>
      <link href="/2020/04/21/Dubbo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ASpringBoot%E6%95%B4%E5%90%88Dubbo%E6%9E%84%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/04/21/Dubbo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9ASpringBoot%E6%95%B4%E5%90%88Dubbo%E6%9E%84%E5%BB%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p><code>Dubbo</code>官方文档中提到有三种方式来开发<code>Dubbo</code>的应用程序，分别是：基于XML配置实现；继续注解实现（常用 / 推荐）；基于API实现。</p><a id="more"></a><p><code>Dubbo</code>官方文档中提到有三种方式来开发<code>Dubbo</code>的应用程序，分别是</p><ul><li>基于XML配置实现</li><li>继续注解实现（常用 / 推荐）</li><li>基于API实现</li></ul><p>鉴于我们平时开发过程中用<code>Spring Boot</code>比较多，所以本篇博客以<code>Spring Boot</code>为例，整合Dubbo来构建一个简单的分布式服务。</p><h5 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h5><p>本文用的注册中心是zookeeper，所以需要下载并安装zookeeper。安装zookeeper的示例网上有很多了，也很简单，自行安装就好啦。启动zookeeper之后如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200421225410285.png" alt="在这里插入图片描述"></p><h5 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h5><p>整个项目结构也很简单，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200421223808445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>dubbo-springboot-api</code>只定义了简单的接口。</li><li><code>dubbo-springboot-provider</code>服务提供者。</li><li><code>dubbo-springboot-consumer</code>服务消费者。</li></ul><p>这三个子项目我创建的都是<code>Spring Boot</code>程序。但其实<code>dubbo-springboot-provider</code>和<code>dubbo-springboot-consumer</code>创建成<code>Spring Boot</code>程序就足够用了。</p><h5 id="创建一个空的maven项目，命名为dubbo-springboot"><a href="#创建一个空的maven项目，命名为dubbo-springboot" class="headerlink" title="创建一个空的maven项目，命名为dubbo-springboot"></a>创建一个空的maven项目，命名为<code>dubbo-springboot</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo-springboot&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;dubbo-springboot-api&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;dubbo-springboot-consumer&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;dubbo-springboot-provider&lt;&#x2F;module&gt;</span><br><span class="line">    &lt;&#x2F;modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><h5 id="创建dubbo-springboot-api子项目"><a href="#创建dubbo-springboot-api子项目" class="headerlink" title="创建dubbo-springboot-api子项目"></a>创建<code>dubbo-springboot-api</code>子项目</h5><p>整个子项目其实什么也没有做，只是单纯的定义一个接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.bazooka.api.service;</span><br><span class="line"></span><br><span class="line">public interface HelloDubboService &#123;</span><br><span class="line"></span><br><span class="line">    String sayHello(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建dubbo-springboot-provider子项目"><a href="#创建dubbo-springboot-provider子项目" class="headerlink" title="创建dubbo-springboot-provider子项目"></a>创建<code>dubbo-springboot-provider</code>子项目</h5><p>这个子项目主要是以<code>服务提供者</code>的身份编写<code>HelloDubboService</code>的实现，来供服务消费者远程调用。</p><ul><li>pom如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- 引入spring-boot-starter以及dubbo和curator的依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.2.0&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;&#x2F;exclusion&gt;</span><br><span class="line">            &lt;&#x2F;exclusions&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-springboot-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><ul><li>编写服务提供者的实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">@Component</span><br><span class="line">public class HelloDubboServiceImpl implements HelloDubboService &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        return &quot;欢迎&quot; + name + &quot;使用Dubbo。&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是<code>@Service</code>是Dubbo提供的注解，而不是Spring提供的注解。这个注解的意思主要是用来暴露服务的。</p><ul><li>修改application.properties</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#当前服务&#x2F;应用的名字</span><br><span class="line">dubbo.application.name&#x3D;dubbo-springboot-provider</span><br><span class="line">#注册中心的协议和地址</span><br><span class="line">dubbo.registry.protocol&#x3D;zookeeper</span><br><span class="line">dubbo.registry.address&#x3D;127.0.0.1:2181</span><br><span class="line">#通信规则（通信协议和接口）</span><br><span class="line">dubbo.protocol.name&#x3D;dubbo</span><br><span class="line">dubbo.protocol.port&#x3D;20880</span><br><span class="line">#连接监控中心</span><br><span class="line">dubbo.monitor.protocol&#x3D;registry</span><br></pre></td></tr></table></figure><ul><li>添加<code>@EnableDubbo</code>注解</li></ul><p>这个注解的含义主要是来扫描包，实现Dubbo的自动装配，相当于配置<code>dubbo.scan.base-packages</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDubbo</span><br><span class="line">public class ProviderApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切就绪之后启动<code>ProviderApplication</code>。</p><h5 id="创建dubbo-springboot-consumer子项目"><a href="#创建dubbo-springboot-consumer子项目" class="headerlink" title="创建dubbo-springboot-consumer子项目"></a>创建<code>dubbo-springboot-consumer</code>子项目</h5><p>这个子项目主要是来远程调用服务提供者的实现。</p><ul><li>pom保持一致就可以啦。</li><li>定义一个<code>ConsumerService</code>并实现它。<ul><li>这里的<code>@Service</code>是<code>import org.springframework.stereotype.Service</code></li><li><code>@Reference</code>来代替 <code>@Autowired</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class ConsumerServiceImpl implements ConsumerService &#123;</span><br><span class="line"></span><br><span class="line">    @Reference</span><br><span class="line">    HelloDubboService helloDubboService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String message) &#123;</span><br><span class="line">        return helloDubboService.sayHello(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改<code>application.properties</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.port&#x3D;8081  </span><br><span class="line"></span><br><span class="line">dubbo.application.name&#x3D;order-service-consumer</span><br><span class="line">dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;127.0.0.1:2181</span><br><span class="line">dubbo.monitor.protocol&#x3D;registry</span><br></pre></td></tr></table></figure><ul><li>同样的需要在main方法上添加<code>@EnableDubbo</code>注解</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDubbo</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个<code>HelloDubboController</code>如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloDubboController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    ConsumerService consumerService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;sayHello&quot;)</span><br><span class="line">    public String sayHello(@RequestParam(&quot;name&quot;) String name) &#123;</span><br><span class="line">        return consumerService.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切就绪之后启动<code>ConsumerApplication</code></p><h5 id="查看测试结果"><a href="#查看测试结果" class="headerlink" title="查看测试结果"></a>查看测试结果</h5><p><img src="https://img-blog.csdnimg.cn/20200421232137636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到结果是我预期的结果，证明项目没什么问题哈。</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式，RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo进阶（二）：Dubbo是什么</title>
      <link href="/2020/04/20/Dubbo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADubbo%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2020/04/20/Dubbo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ADubbo%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>在当今微服务盛行的大环境下，设计一套高并发、高可扩展、自动容错和高可用的分布式系统无疑是离不开一套优秀的<code>RPC</code>框架的。<code>Dubbo</code>是阿里开源的<code>RPC</code>框架，在市场上众多<code>RPC</code>框架中是最受欢迎的，各大公司也都争相拥抱和使用。</p><a id="more"></a><p>在当今微服务盛行的大环境下，设计一套高并发、高可扩展、自动容错和高可用的分布式系统无疑是离不开一套优秀的<code>RPC</code>框架的。<code>Dubbo</code>是阿里开源的<code>RPC</code>框架，在市场上众多<code>RPC</code>框架中是最受欢迎的，各大公司也都争相拥抱和使用。</p><h5 id="Dubbo的架构图"><a href="#Dubbo的架构图" class="headerlink" title="Dubbo的架构图"></a>Dubbo的架构图</h5><p><img src="https://img-blog.csdnimg.cn/20200415143110190.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图片来自<a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo官网</a>，各个角色说明如下：</p><table><thead><tr><th>角色</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Container</td><td>服务运行容器</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Provider</td><td>在启动的时候会向注册中心注册元数据（IP/端口之类的），Consumer在启动的时候会向注册中心订阅（第一次订阅会拉去全部数据）服务方的元数据，注册中心发生数据变化的时候，会推送给订阅的Consumer。在获取到服务方的元数据之后可以进行<code>RPC</code>调用，在<code>RPC</code>调用后会向监控中心上报统计信息（比如并发数和调用的接口），开发人员可以在监控中心看到服务的调用情况。</td></tr></tbody></table><h5 id="Dubbo的分层和核心组件"><a href="#Dubbo的分层和核心组件" class="headerlink" title="Dubbo的分层和核心组件"></a>Dubbo的分层和核心组件</h5><p><img src="https://img-blog.csdnimg.cn/20200420082736740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>核心组件如下：</p><table><thead><tr><th>层次明</th><th>作用</th></tr></thead><tbody><tr><td>Service</td><td>业务层。即我们实现的业务代码。</td></tr><tr><td>config</td><td>配置层。主要围绕ServiceConfig（暴露服务的位置）和ReferenceConfig（引用的服务位置）两个实现类展开，初始化配置信息。可以理解为该层管理了整个Dubbo的配置。</td></tr><tr><td>proxy</td><td>服务代理层。在Dubbo中，无论生产者还是消费者，框架都会生成一个代理类，整个过程对上层是透明的。当调用一个远程接口时就像是调用本地的接口一样，代理程会自动发起远程调用并返回结果，让业务层对远程调用完全无感。</td></tr><tr><td>registry</td><td>注册层。负责Dubbo框架的服务注册和发现。当有新的服务加入或者旧的服务下线时，注册中心都会感知并通知给所有的订阅方，整个过程不需要人工参与。</td></tr><tr><td>cluster</td><td>集群容错层。主要负责远程调用失败时的容错策略（重试失败，快速失败等）。选择具体节点调用时的负载均衡策略（如随机，一致性Hash等），特殊调用路径的路由策略（如某个消费者只会条用某个IP的生产者）。</td></tr><tr><td>monitor</td><td>控制层。主要负责监控统计调用次数和时间等。</td></tr><tr><td>protocol</td><td>远程调用层。封装RPC调用具体过程，Protocol是Invoker暴露（发布一个服务让别人可以调用）和引用（应用一个远程服务到本地）的主功能入口，它负责管理Invoker的整个生命周期。Invoker是Dubbo的核心模型，框架中所有的其他模型都向它靠拢，或者转换成它，它代表一个可执行体。允许向他发起invoke调动，它可能是执行一个本地的接口实现，也可能是一个远程调用，还可能是一个集群实现。</td></tr><tr><td>exchange</td><td>信息交换层。建立Request-Response模型，封装请求响应模式，如把同步请求转换成异步请求。</td></tr><tr><td>transport</td><td>网络传输层。把网络传输抽象为同一接口，如Mina和Netty虽然接口不一样，但是Dubbo在它们上面又封装了同一接口。用户也可以根据其他扩展接口添加更多的网络传输方式。</td></tr><tr><td>Serialize</td><td>序列化层。如果数据通过网络进行发送，则需要先做序列化，编程二进制流。序列化层负责管理整个框架网络传输时的序列化/反序列化工作。</td></tr></tbody></table><h5 id="Dubbo总体调用过程"><a href="#Dubbo总体调用过程" class="headerlink" title="Dubbo总体调用过程"></a>Dubbo总体调用过程</h5><p><img src="https://img-blog.csdnimg.cn/20200420091712719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>首先是从一个Proxy开始，Proxy持有一个Invoker对象，然后触发invoke调用。</li><li>在invoke调用过程中，需要使用Cluster，Cluster负责容错，如果调用失败的则重试。Cluster在调用之前会通过Directory获取所有可以调用的远程服务Invoker列表。</li><li>然后通过负载均衡选取一个可以调用的Invoker。这个Invoker在调用之前会经过一个过滤链，通常为处理上下文、限流、计数等。</li><li>接下来通过client做数据传输，如常见的Netty Client。在传输之前需要做一些私有协议的构造，此时就会用到Codec接口。构造完成之后，就对数据包做序列化然后传送到服务提供者端。服务提供者收到数据包，也会使用Codec处理协议头及一些半包、粘包等。处理好之后再对完整的数据报文做反序列化处理。</li><li>随后这个Request被分配到线程池中进行处理。Server会处理这些Request，根据请求找到对应的Exporter（它内部持有了Invoker）。</li><li>最后得到了接口的真实实现并调用，再原路返回调用结果。</li></ol><p>以上就是一个完整的远程调用过程。</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式，RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo进阶（一）：RPC和RESTful</title>
      <link href="/2020/04/17/Dubbo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARPC%E5%92%8CRESTful/"/>
      <url>/2020/04/17/Dubbo%E8%BF%9B%E9%98%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ARPC%E5%92%8CRESTful/</url>
      
        <content type="html"><![CDATA[<p>想要比较清楚的了解<code>RPC</code>和<code>RESTful</code>的区别，我们先来了解一下网络的七层模型。</p><a id="more"></a><p>想要比较清楚的了解<code>RPC</code>和<code>RESTful</code>的区别，我们先来了解一下网络的七层模型。</p><h5 id="OSI网络模型"><a href="#OSI网络模型" class="headerlink" title="OSI网络模型"></a>OSI网络模型</h5><p><img src="https://img-blog.csdnimg.cn/20200414143204841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>图片来自网络</p><p>我们可以清楚的看到<code>OSI</code>模型一共有七层，从上到下分别是：</p><ul><li>第一层应用层。定义了用于在网络中进行通信和传输数据的接口；</li><li>第二层表示层。定义不同的系统中数据的传输格式，编码和解码规范等；</li><li>第三层会话层。管理用户的会话，控制用户间逻辑连接的建立和中断；</li><li>第四层传输层。管理着网络中的端到端的数据传输；</li><li>第五层网络层。定义网络设备间如何传输数据；</li><li>第六层链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输；</li><li>第七层物理层。这一层主要就是传输这些二进制数据。</li></ul><p>众所周知<code>REST API</code>是基于<code>HTTP</code>协议来传输数据的，<code>RPC</code>主要是基于<code>TCP/IP</code>协议的，所以效率来看的话，<code>RPC</code>的效率会高一点，尤其是在复杂的系统中使用<code>RPC</code>效果会更明显。</p><h5 id="什么是REST-API"><a href="#什么是REST-API" class="headerlink" title="什么是REST API"></a>什么是REST API</h5><p>RESTFUL是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义。RESTFUL适用于移动互联网厂商作为业务使能接口的场景，实现第三方OTT调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。</p><p>↑以上内容来自百度百科。</p><p><code>REST</code>即Representational State Transfer的缩写，是基于HTTP协议之上的一组约束和属性，翻译过来是表现层状态转移。</p><p><code>REST</code>是一种设计风格（并非一种标准），描述的是在网络中<code>Client</code>和<code>Server</code>的一种交互形式，目的是便于不同的软件/程序在网络中互相传递消息。</p><p>REST API大概有以下三部分组成：</p><ul><li>method：动词（GET，POST之类的）</li><li>Host/post：URI(统一资源标识)、服务器，端口</li><li>Path：名词（路径，服务器里面的某个东西）路径的结尾是资源的形态(如text, html, image, pdf等)。</li></ul><p>REST API常见的HTTP code</p><ul><li>Status Code: 200 OK</li><li>Status Code: 400 Bed Request</li><li>Status Code: 404 Not Found</li><li>Status Code: 500 Internal Server Error </li></ul><p><code>REST</code>充分利用HTTP自身的<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>的方法实现接口的统一化，比如对同一个资源进行CRUD操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET     &#x2F;dogs    获取所有狗狗 </span><br><span class="line">POST    &#x2F;dogs    新增&#x2F;修改狗狗信息</span><br><span class="line">PUT     &#x2F;dogs    修改狗狗信息</span><br><span class="line">DELETE  &#x2F;dogs    删除狗狗信息</span><br></pre></td></tr></table></figure><p>REST API主要的设计原则：</p><ul><li>资源与URI</li><li>统一资源接口(HTTP方法如GET，PUT和POST)</li><li>资源的表述</li><li>资源的链接</li><li>状态的转移</li></ul><p>总之，RESTful的核心就是后端将资源发布为URI，前端通过URI访问资源，并通过HTTP动词表示要对资源进行的操作。</p><h5 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h5><p><strong>RPC(Remote Procedure Call)</strong>，远程过程调用，就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</p><p><code>RPC</code>在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。通常的调用过程，把函数序列化，远端收到后，再把函数反序列化，完成函数调用。</p><p>一个完整的RPC的架构应该包含以下几个组件：</p><ul><li>客户端（Client）：服务的调用方；</li><li>服务端（Server）：真正的服务提供者；</li><li>Client stub：存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方；</li><li>Server stub：接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li></ul><h5 id="一个RPC的完整过程"><a href="#一个RPC的完整过程" class="headerlink" title="一个RPC的完整过程"></a>一个RPC的完整过程</h5><p><code>RPC</code>采用<code>Client-Server</code>结构，通过<code>request-response</code>消息模式实现。</p><p>实际情况下，RPC很少用到http协议来进行数据传输，毕竟只是想传输一下数据而已，何必动用到一个文本传输的应用层协议呢。为什么不直接使用二进制传输？比如直接用Java的Socket协议进行传输？</p><p>不管用何种协议进行数据传输，一个完整的RPC过程，都可以用下面这张图来描述：</p><p><img src="https://img-blog.csdnimg.cn/20200415092116313.gif" alt="在这里插入图片描述"></p><p>对上图的解释如下：</p><ul><li>Client是服务调用方，Server是服务提供者。</li><li>左边的Client里的Application就是一个真正的调用者，先去调用Client Stub这个代理对象，其实内部是通过RPC方式来进行远程调用的代理对象，这一步主要是来传递参数。</li><li>至于Client Runtime Library，则是实现远程调用的工具包，比如jdk的Socket。最后通过底层网络实现实现数据的传输。</li><li>然后客户端本地操作系统将消息从客户端机器发送到服务端机器。</li><li>服务端操作系统接收到数据包传递给Server Stub。</li><li>Server Stub解组消息为参数。</li><li>Server Stub再调用服务端的函数（或方法），得到执行结果之后以反方向的相同的步骤响应给客户端，至此就完成了一次RPC调用。</li></ul><p>这个过程中最重要的就是<code>序列化</code>和<code>反序列化</code>了。因为数据传输的数据包必须是二进制的，直接丢一个Java对象过去，人家可不认识，必须把Java对象序列化为二进制格式，传给Server端，Server端接收到之后，再反序列化为Java对象。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>REST API主要为第三方暴露接口，比如暴露给APP端，WEB端。</li><li>RPC主要在自家比较复杂的业务系统中使用，完成服务之间的通信。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200415094618623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式，RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Jenkins的流水线（Pipeline）构建项目</title>
      <link href="/2020/04/17/%E4%BD%BF%E7%94%A8Jenkins%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88Pipeline%EF%BC%89%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
      <url>/2020/04/17/%E4%BD%BF%E7%94%A8Jenkins%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88Pipeline%EF%BC%89%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p><code>Jenkins 2.x</code> 内置了强大的流水线功能，真的比传统的构建项目的方法方便了好多。</p><a id="more"></a><p><code>Jenkins 2.x</code> 内置了强大的流水线功能，真的比传统的构建项目的方法方便了好多。</p><ul><li><p>创建一个<code>流水线</code>类型的任务<br><img src="https://img-blog.csdnimg.cn/20190719171924828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>填写Pipeline脚本</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">node &#123;</span><br><span class="line">   def mvnHome</span><br><span class="line">   stage(&#39;Preparation&#39;) &#123; &#x2F;&#x2F; for display purposes</span><br><span class="line">      &#x2F;&#x2F; clone源码</span><br><span class="line">      git &#39;https:&#x2F;&#x2F;github.com&#x2F;BazookaW&#x2F;JavaGuide.git&#39;</span><br><span class="line">      &#x2F;&#x2F; 这里的maven必须跟全局工具配置中设置的Maven名称一致       </span><br><span class="line">      mvnHome &#x3D; tool &#39;maven&#39;</span><br><span class="line">   &#125;</span><br><span class="line">   stage(&#39;Build&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; Run the maven build</span><br><span class="line">      if (isUnix()) &#123;</span><br><span class="line">         sh &quot;&#39;$&#123;mvnHome&#125;&#x2F;bin&#x2F;mvn&#39; clean install&quot;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         bat(&#x2F;&quot;$&#123;mvnHome&#125;\bin\mvn&quot; clean install&#x2F;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，我们编写了一个流水线，该流水线包含两个阶段：</p><p><code>Preparation</code>：在该阶段中，我们Clone源码，同时，定义了一个变量叫mvnHome。<br><code>Build</code>：在该阶段中，我们执行 mvn clean install 命令，其中针对操作系统做了判断。<br><img src="https://img-blog.csdnimg.cn/20190719172002893.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p><code>Pipeline</code>脚本功能非常强大，默认支持数十个指令！你可能担心指令学习的成本，但这种担心其实是多余的——只需点击上图中的<code>流水线语法</code>按钮，就可以使用Pipeline语法啦！</p></li><li><p>效果图<br><img src="https://img-blog.csdnimg.cn/20190719173031474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD，自动化技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Jenkins构建风格自由的项目（图文）</title>
      <link href="/2020/04/17/%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BA%E9%A3%8E%E6%A0%BC%E8%87%AA%E7%94%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%9B%BE%E6%96%87%EF%BC%89/"/>
      <url>/2020/04/17/%E4%BD%BF%E7%94%A8Jenkins%E6%9E%84%E5%BB%BA%E9%A3%8E%E6%A0%BC%E8%87%AA%E7%94%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%9B%BE%E6%96%87%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>之前讲了讲了如何安装Jenkins，如果有需要的朋友可以去了解一下。本文主要讲解如何使用Jenkins<code>构建项目</code>。</p><a id="more"></a><p>之前讲了讲了如何安装Jenkins，如果有需要的朋友可以去了解一下。本文主要讲解如何使用Jenkins<code>构建项目</code>。</p><h5 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h5><ul><li>全局工具配置<br><img src="https://img-blog.csdnimg.cn/20190719111946856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>打开之后会看到一系列的配置，包括<code>JDK</code>、<code>Git</code>、<code>Gradle</code>、<code>Maven</code>、<code>Docker</code>等配置，当然不是所有的都要配置，请按需配置。<br><img src="https://img-blog.csdnimg.cn/20190719112654255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190719112702661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190719112711457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置好自己需要的东西之后，点击保存。</li><li>当然，Jenkins还有很多其他的配置选项，读者可自行在Jenkins左侧的系统管理自行挖掘。<h5 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h5><img src="https://img-blog.csdnimg.cn/20190719140240623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>创建一个自由风格的项目，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190719141243649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>接下来配置源码管理，因为我用github的仓库，所以选择Git，同理如果你是SVN就选SVN。<br><img src="https://img-blog.csdnimg.cn/20190719141714311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>配置maven，在<code>构建</code>中的<code>增加构建步骤</code>选择<code>Invoke top-level Maven targets</code><br><img src="https://img-blog.csdnimg.cn/20190719141815564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190719141914511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>点击构建项目，执行构建<br><img src="https://img-blog.csdnimg.cn/20190719145133404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>构建成功<br><img src="https://img-blog.csdnimg.cn/20190719145150147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h5 id="过程中遇到的问题及解决方案"><a href="#过程中遇到的问题及解决方案" class="headerlink" title="过程中遇到的问题及解决方案"></a>过程中遇到的问题及解决方案</h5><ul><li>ERROR: Error fetching remote repo ‘origin’<ul><li>分析：没有添加Git证书导致无法从github拉取代码。</li><li>解决方案：在源码管理里添加git的密钥<br><img src="https://img-blog.csdnimg.cn/20190719155848376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190719155733844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li><li>项目构建完成后没有启动成功<ul><li>分析：可能是进程被杀死了。</li><li>解决方案：用<code>screen -d -m java -jar xxx</code>替换 <code>java -jar xxx</code>，screen是一个把进程在执行进程退出后，仍然存活的命令。如果你本地的电脑没有<code>screen</code>，请先使用此命令安装<code>brew install screen</code>。<br><img src="https://img-blog.csdnimg.cn/20190719163438989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI/CD，自动化技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试驱动开发(TDD)在微服务中的应用</title>
      <link href="/2020/04/17/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD-%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2020/04/17/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD-%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章中用一个计算长方形面积的小例子介绍了如何使用TDD，感兴趣的小伙伴可以去阅读一下，今天主要介绍TDD是如何应用在微服务中的。我们还是先来回归一下TDD的三条实践准则。</p><a id="more"></a><p>在上一篇文章中用一个计算长方形面积的小例子介绍了如何使用TDD，感兴趣的小伙伴可以去阅读一下，今天主要介绍TDD是如何应用在微服务中的。我们还是先来回归一下TDD的三条实践准则。</p><h5 id="TDD的三条准则"><a href="#TDD的三条准则" class="headerlink" title="TDD的三条准则"></a>TDD的三条准则</h5><ul><li>除非为了使一个失败的单元测试通过，否则不允许编写任何业务代码。</li><li>在一个单元测试中，只允许写一个刚好导致失败的内容。</li><li>只允许编写刚好能够使一个失败的单元测试通过的业务代码。</li></ul><h5 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h5><ul><li>Java 8</li><li>Spring Boot 2.1.x</li><li>Spring Data JPA 2.0.9</li><li>TestNG 6.13</li><li>Mockito 1.10.19（创建虚拟对象，解耦依赖的类或者接口）</li></ul><h5 id="1-编写测试用例"><a href="#1-编写测试用例" class="headerlink" title="1.编写测试用例"></a>1.编写测试用例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">   @InjectMocks</span><br><span class="line">   SageTaxService sageTaxService &#x3D; new SageTaxServiceImpl();</span><br><span class="line"></span><br><span class="line">   @Mock</span><br><span class="line">   SageTaxRepository sageTaxRepository;</span><br><span class="line"></span><br><span class="line">   @Mock</span><br><span class="line">   CommonService commonService;</span><br><span class="line"></span><br><span class="line">   @Mock</span><br><span class="line">   WebContext webContext;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">   public void test_add_sage_tax() &#123;</span><br><span class="line">       UserInfo userInfo &#x3D; new UserInfo();</span><br><span class="line">       userInfo.setUserId(999);</span><br><span class="line">       Mockito.when(webContext.getUserInfo()).thenReturn(userInfo);</span><br><span class="line"></span><br><span class="line">       SageTax sageTax &#x3D; new SageTax();</span><br><span class="line">       sageTax.setEntryId(webContext.getUserInfo().getGlobalUserId());</span><br><span class="line">       sageTax.setEntryDatetime(commonService.getDbTimestamp());</span><br><span class="line">       sageTax.setTaxRate(BigDecimal.valueOf(0.011));</span><br><span class="line">       sageTax.setTaxIdCode(&quot;test&quot;);</span><br><span class="line">       sageTax.setCountryCode(&quot;CA&quot;);</span><br><span class="line">       sageTax.setTaxCode(&quot;qqq&quot;);</span><br><span class="line"></span><br><span class="line">       Mockito.when(sageTaxRepository.save(sageTax)).thenReturn(sageTax);</span><br><span class="line">       Assert.assertNotNull(sageTaxService.addSageTax(sageTax));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="2-运行测试用例"><a href="#2-运行测试用例" class="headerlink" title="2.运行测试用例"></a>2.运行测试用例</h5><p>就会看到测试case运行失败了（因为你还没写功能代码）</p><h5 id="3-编写业务代码"><a href="#3-编写业务代码" class="headerlink" title="3.编写业务代码"></a>3.编写业务代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public Boolean addSageTax(SageTax sageTaxVO) &#123;</span><br><span class="line">       List&lt;SageTax&gt; sageTaxList &#x3D; Lists.newArrayList();</span><br><span class="line">       if (sageTaxVO.getCountryCode() !&#x3D; null &amp;&amp; sageTaxVO.getTaxCode() !&#x3D; null) &#123;</span><br><span class="line">       &#x2F;&#x2F; countryCode and taxCode is unique key</span><br><span class="line">           sageTaxList &#x3D; getSageTax(sageTaxVO.getCountryCode(), sageTaxVO.getTaxCode());</span><br><span class="line">       &#125;</span><br><span class="line">       if (sageTaxList.size() &gt; 0) &#123;</span><br><span class="line">       &#x2F;&#x2F; if has data in DB, return false</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       SageTax sageTax &#x3D; new SageTax();</span><br><span class="line">       sageTax.setEntryId(webContext.getUserInfo().getGlobalUserId());</span><br><span class="line">       sageTax.setEntryDatetime(commonService.getDbTimestamp());</span><br><span class="line">       sageTax.setTaxId(sageTaxVO.getTaxId());</span><br><span class="line">       sageTax.setTaxIdCode(sageTaxVO.getTaxIdCode());</span><br><span class="line">       sageTax.setCountryCode(sageTaxVO.getCountryCode());</span><br><span class="line">       sageTax.setTaxCode(sageTaxVO.getTaxCode());</span><br><span class="line">       sageTax.setTaxRate(sageTaxVO.getTaxRate());</span><br><span class="line">       sageTaxRepository.save(sageTax);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="4-运行测试用例，然后看到测试用例通过了"><a href="#4-运行测试用例，然后看到测试用例通过了" class="headerlink" title="4.运行测试用例，然后看到测试用例通过了"></a>4.运行测试用例，然后看到测试用例通过了</h5><h5 id="5-对代码查缺补漏，进行重构"><a href="#5-对代码查缺补漏，进行重构" class="headerlink" title="5.对代码查缺补漏，进行重构"></a>5.对代码查缺补漏，进行重构</h5><ul><li>补充测试用例，因为可能在保存的时候会出错，所以新增一个case用来覆盖抛出exception的情况。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test(expectedExceptions &#x3D; Exception.class)</span><br><span class="line">   public void test_add_sage_tax_with_exception() &#123;</span><br><span class="line"> UserInfo userInfo &#x3D; new UserInfo();</span><br><span class="line">       userInfo.setUserId(999);</span><br><span class="line">       Mockito.when(webContext.getUserInfo()).thenReturn(userInfo);</span><br><span class="line"></span><br><span class="line">       SageTax sageTax &#x3D; new SageTax();</span><br><span class="line">       sageTax.setEntryId(webContext.getUserInfo().getGlobalUserId());</span><br><span class="line">       sageTax.setEntryDatetime(commonService.getDbTimestamp());</span><br><span class="line">       sageTax.setTaxRate(BigDecimal.valueOf(0.011));</span><br><span class="line">       sageTax.setTaxIdCode(&quot;test&quot;);</span><br><span class="line">       sageTax.setCountryCode(&quot;CA&quot;);</span><br><span class="line">       sageTax.setTaxCode(&quot;qqq&quot;);</span><br><span class="line">       </span><br><span class="line">       Mockito.when(sageTaxRepository.save(sageTax)).thenThrow(new Exception());</span><br><span class="line">       Mockito.when(sageTaxService.addSageTax(sageTaxVO)).thenThrow(new Exception());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>完善业务代码</li></ul><h5 id="总结和心得"><a href="#总结和心得" class="headerlink" title="总结和心得"></a>总结和心得</h5><ul><li>测试用例就是设计，因为每一个测试用例就是一个小的业务场景，大的业务也是由小的业务累积起来的。</li><li>TDD 要求开发人员按照测试，开发，重构，测试，开发，重构。。。。的过程来工作，一点一滴的完成设计。</li><li>推翻了瀑布式的开发（先写功能代码，遇到编译错误的地方，就直接Debug项目，然后让其编译通过），站在用户的角度上进行工作。</li><li>完善的安全网，不用担心重构代码的时候出错。</li></ul><h5 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h5><p>通常写完测试用例，我们都需要看一下我们代码的覆盖率，通常市面上常用的工具是<code>SonarQube</code>，但是我们的IDEA也可以看到我们代码覆盖率。如下：</p><ul><li>选中xxxxTest.java，右键Run “xxxxTest.java” with Coverage。</li><li>查看覆盖率，通常来说90%覆盖就好了。<br><img src="https://img-blog.csdnimg.cn/20190928152857750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190928152907461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 测试驱动开发(TDD) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敏捷开发，TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试驱动开发(TDD)的理论基础</title>
      <link href="/2020/04/17/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD-%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/04/17/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD-%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>在开始理论介绍之前，先思考一个问题：<strong>软件开发中最重要的是什么？</strong><br>可能有的小伙伴就会说：良好的数据库设计，一个健壮可扩展的架构，规范的编码风格，设计文档等。没错这些在开发中都很重要，但是其实做这些工作都是为了保证软件的<strong>质量</strong>，所以说<strong>质量</strong>才是最重要的。</p><a id="more"></a><p>在开始理论介绍之前，先思考一个问题：<strong>软件开发中最重要的是什么？</strong></p><ul><li>可能有的小伙伴就会说：良好的数据库设计，一个健壮可扩展的架构，规范的编码风格，设计文档等。</li><li>没错这些在开发中都很重要，但是其实做这些工作都是为了保证软件的<strong>质量</strong>，所以说<strong>质量</strong>才是最重要的。</li></ul><p>那么<strong>质量</strong>存在于软件生命周期中的哪一个阶段呢？<br><img src="https://img-blog.csdnimg.cn/20190918105343606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们大概可以将软件的开发周期分为这样的四个阶段，当然我们作为开发人员，我们需要在<code>编码阶段</code>保证软件的<strong>质量</strong>。在我们明确了目标（提供高质量的代码）之后，简单介绍一下TDD。</p><h5 id="什么是TDD"><a href="#什么是TDD" class="headerlink" title="什么是TDD"></a>什么是TDD</h5><ul><li>Test-Driven Development，测试驱动开发。<ul><li>这是我们最常见的对TDD的理解，以测试用例入手，先写好测试用例，然后再去写实现。</li></ul></li><li>Task-Driven Development，任务驱动开发，要对问题进行分析并进行任务分解。<ul><li>将大任务分解成为小任务，针对不同的小的任务去做TDD。</li></ul></li><li>Test-Driven Design，测试驱动设计<ul><li>让我们的代码更具可测性，方便设计和重构。</li></ul></li></ul><h5 id="为什么使用TDD"><a href="#为什么使用TDD" class="headerlink" title="为什么使用TDD"></a>为什么使用TDD</h5><ul><li>成本最低方式提高产品质量，因为不需要借助外部人员参与，只需要开发人员一边写测试用例，一边业务代码来推动项目前进。</li><li>快速反馈，因为有丰富的测试用例来覆盖业务代码，一旦业务代码出错，就可以及时发现问题并修正。</li><li>提前澄清需求，写测试用例的前提一定是弄懂需求之后才去做。</li><li>活文档，每一个测试用例其实都是对应的一种业务场景。</li><li>安全网，大量丰富的测试用例能够大面积的覆盖业务代码，尽管在重构的时候也不必担心写错代码。</li></ul><h5 id="我知道TDD好，可是我不想TDD"><a href="#我知道TDD好，可是我不想TDD" class="headerlink" title="我知道TDD好，可是我不想TDD"></a>我知道TDD好，可是我不想TDD</h5><p>的确，TDD还是比较有难度，而且对成员的要求也比较高，在团队中很难推广起来。因为有一些成员会有下面的想法：</p><ul><li>没有写测试用例的习惯。</li><li>觉得写测试用例既加大了工作量又浪费时间，因为写测试用例一般都是写业务代码的双倍或者更多的时间。</li><li>自己对写测试用例掌握的不是很熟练，比如Mock。</li><li>认为这是测试人员做的工作，开发人员只是负责写好业务代码。</li></ul><h5 id="TDD流程"><a href="#TDD流程" class="headerlink" title="TDD流程"></a>TDD流程</h5><p><img src="https://img-blog.csdnimg.cn/20190918112037100.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>画了个图可以一目了然的看清TDD的流程，其实也可以简单的总结为一下五个步骤：</p><ul><li>写一个新的测试用例。</li><li>运行下新加的测试用例，看到它失败（因为你还没写功能代码）。</li><li>编写业务代码，对开发代码做很小的修改，目的就是让新加的测试通过。</li><li>运行所有的测试用例，然后看到所有测试都通过了。</li><li>移掉重复的代码，对代码进行重构。</li></ul><h5 id="TDD的三条规则"><a href="#TDD的三条规则" class="headerlink" title="TDD的三条规则"></a>TDD的三条规则</h5><ul><li>除非为了使一个失败的单元测试通过，否则不允许编写任何业务代码。</li><li>在一个单元测试中，只允许写一个刚好导致失败的内容。</li><li>只允许编写刚好能够使一个失败的单元测试通过的业务代码。</li></ul><h5 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h5><p>每次在做TDD的时候，首先要分析好业务，心里清楚明白自己做的是什么，然后列一个TODO List，每写完一个就划掉，这样子会提高效率，也不会导致自己忘了做了什么没做什么。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过半篇文章对TDD(测试驱动开发)有了基本的理解，对TDD的带来的优点有了初步的认识，接下来的工作和学习中，我会转变思想，以“测试先行”的原则来开发稳定高质量的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 测试驱动开发(TDD) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敏捷开发，TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试驱动开发(TDD)实战体验</title>
      <link href="/2020/04/17/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD-%E5%AE%9E%E6%88%98%E4%BD%93%E9%AA%8C/"/>
      <url>/2020/04/17/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91-TDD-%E5%AE%9E%E6%88%98%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<p>今天这篇文章以一个简单的例子来体验一下TDD的过程。</p><a id="more"></a><p>在上一篇文章中写了关于TDD的理论，感兴趣的小伙伴可以去阅读一下。今天这篇文章以一个简单的例子来体验一下TDD的过程。</p><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><ul><li>Java 8</li><li>Junit 5</li></ul><h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p>我们有这样子的一个需求：客户需要一个长方形，能够给长方形设置宽和高，并且能够计算面积</p><h5 id="1-编写测试用例"><a href="#1-编写测试用例" class="headerlink" title="1.编写测试用例"></a>1.编写测试用例</h5><ul><li>此时的Rectangle类如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private double width;</span><br><span class="line"></span><br><span class="line">    private double height;</span><br><span class="line"></span><br><span class="line">    public void setWidth(double width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeight(double height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写测试case</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class RectangleTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void should_return_20_when_width_2_and_height_10() &#123;</span><br><span class="line"></span><br><span class="line">        double width &#x3D; 2;</span><br><span class="line"></span><br><span class="line">        double height &#x3D; 10;</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle &#x3D; new Rectangle();</span><br><span class="line"></span><br><span class="line">        rectangle.setWidth(width);</span><br><span class="line">        rectangle.setHeight(height);</span><br><span class="line"></span><br><span class="line">        assert (rectangle.count(width, height) &#x3D;&#x3D; 20);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-运行测试用例"><a href="#2-运行测试用例" class="headerlink" title="2.运行测试用例"></a>2.运行测试用例</h5><p>就会看到测试case运行失败了（因为你还没写功能代码）</p><h5 id="3-编写业务代码"><a href="#3-编写业务代码" class="headerlink" title="3.编写业务代码"></a>3.编写业务代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private double width;</span><br><span class="line"></span><br><span class="line">    private double height;</span><br><span class="line"></span><br><span class="line">    public void setWidth(double width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeight(double height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double count(double width, double height) &#123;</span><br><span class="line"> return width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-运行测试用例，然后看到测试用例通过了"><a href="#4-运行测试用例，然后看到测试用例通过了" class="headerlink" title="4.运行测试用例，然后看到测试用例通过了"></a>4.运行测试用例，然后看到测试用例通过了</h5><h5 id="5-对代码查缺补漏，进行重构"><a href="#5-对代码查缺补漏，进行重构" class="headerlink" title="5.对代码查缺补漏，进行重构"></a>5.对代码查缺补漏，进行重构</h5><ul><li>补充测试用例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class RectangleTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void should_return_20_when_width_2_and_height_10() &#123;</span><br><span class="line"></span><br><span class="line">        double width &#x3D; 2;</span><br><span class="line"></span><br><span class="line">        double height &#x3D; 10;</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle &#x3D; new Rectangle();</span><br><span class="line"></span><br><span class="line">        rectangle.setWidth(width);</span><br><span class="line">        rectangle.setHeight(height);</span><br><span class="line"></span><br><span class="line">        assert (rectangle.count(width, height) &#x3D;&#x3D; 20);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void should_throw_exception_when_width_given_error_value() &#123;</span><br><span class="line"></span><br><span class="line">        double width &#x3D; -10;</span><br><span class="line"></span><br><span class="line">        double height &#x3D; 10;</span><br><span class="line"></span><br><span class="line">        Rectangle rectangle &#x3D; new Rectangle();</span><br><span class="line"></span><br><span class="line">        assertThrows(IllegalArgumentException.class, () -&gt; rectangle.count(width, height));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行测试用例，发现失败了</li><li>然后补充代码，此时的Rectangle类如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    private double width;</span><br><span class="line"></span><br><span class="line">    private double height;</span><br><span class="line"></span><br><span class="line">    public void setWidth(double width) &#123;</span><br><span class="line">        this.width &#x3D; width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHeight(double height) &#123;</span><br><span class="line">        this.height &#x3D; height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double count(double width, double height) &#123;</span><br><span class="line">        if (width &lt;&#x3D; 0 || height &lt;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        return width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是一个简单的TDD的用例过程，其实还是很轻松愉快的。</p>]]></content>
      
      
      <categories>
          
          <category> 测试驱动开发(TDD) </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 敏捷开发，TDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我所了解的分布式事物</title>
      <link href="/2020/04/17/%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E7%89%A9/"/>
      <url>/2020/04/17/%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<p>因为公司的项目用到了<code>分布式事物</code>，一开始对这个概念了解的只是模棱两可，所以自己学习了一波并整理了此篇博客。众所周知，分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，尤其是在微服务中<code>分布式事物</code>是必须要解决的一个课题。</p><a id="more"></a><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>因为公司的项目用到了<code>分布式事物</code>，一开始对这个概念了解的只是模棱两可，所以自己学习了一波并整理了此篇博客。众所周知，分布式事务是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，尤其是在微服务中<code>分布式事物</code>是必须要解决的一个课题。</p><h5 id="All-or-Nothing"><a href="#All-or-Nothing" class="headerlink" title="All or Nothing"></a>All or Nothing</h5><ul><li>在了解<code>分布式事物</code>之前，有必要复习一下数据库本地事物。<br>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制。</li><li>事物的四大特性（ACID）<ul><li><strong>A 原子性</strong>(Atomicity)：一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。</li><li><strong>C 一致性</strong>(Consistency)，事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。</li><li><strong>I 隔离性</strong>(Isolation)，指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。</li><li><strong>D 持久性</strong>(Durability)，指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。</li></ul></li><li>在MySQL中，本地事物是如何实现的<ul><li>事务的 ACID 是通过 InnoDB 日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过 Redo Log（重做日志）来实现，原子性和一致性通过 Undo Log 来实现。</li><li>Undo Log 的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为 Undo Log）。然后进行数据的修改。</li><li>如果出现了错误或者用户执行了 Rollback 语句，系统可以利用 Undo Log 中的备份将数据恢复到事务开始之前的状态。 </li><li>和 Undo Log 相反，Redo Log 记录的是新数据的备份。在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。</li><li>当系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可以根据 Redo Log 的内容，将所有数据恢复到最新的状态。 </li></ul></li></ul><h5 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h5><ul><li><p>官方说法：分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p></li><li><p>个人理解：就是一个大的事物由不同的小事物组合而来，分布式事务的工作就是保证这些小事物要么全部成功，要么全部失败。</p></li><li><p><strong>CAP理论</strong></p><ul><li>CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出数据库设计时无法同时满足一下3个属性：<ul><li>一致性(Consistency) ： 客户端知道一系列的操作都会同时发生</li><li>可用性(Availability) ： 每个操作都必须以可预期的响应结束</li><li>分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成</li></ul></li></ul></li></ul><p><strong>CAP理论</strong>意思就是在任何数据库设计中，都无法同时满足这三个特性，最多只能同时支持两个特性并存。很显然，在设计数据库的时候，就需要在三个特性之间进行取舍，也就是说<code>必须在一致性与可用性之间做出选择</code>。</p><ul><li><strong>BASE理论</strong><br>在分布式系统中，我们往往追求的是可用性，所以可用性的优先级明显高于一致性。因此前辈们给我们我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的，是对CAP中AP的一个扩展。BASE理论指的是：<ul><li>Basically Available（基本可用）</li><li>Soft state（软状态）</li><li>Eventually consistent（最终一致性）</li></ul></li></ul><p>那么BASE理论是什么意思呢：<code>数据库设计时无法做到强一致，但每个小应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。很明显BASE理论和ACID是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</code></p><h5 id="分布式事物解决方案"><a href="#分布式事物解决方案" class="headerlink" title="分布式事物解决方案"></a>分布式事物解决方案</h5><p>分布式事物的基本理论写的差不多了，接下来了解一下常见的解决方案。</p><ul><li><p>两阶段提交（2PC）<br>在了解2PC之前，简单了解一下分布式事务中的 XA Transactions，在 XA 协议中分为两阶段</p><ul><li><p>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</p></li><li><p>事务协调器要求每个数据库提交数据，或者回滚数据。<br><img src="https://img-blog.csdnimg.cn/20190226101739138.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>2PC的核心思想就是：每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。需要引入一个协调者（Coordinator）来统一掌控所有参与者（Participant）的操作结果，并指示它们是否要把操作结果进行真正的提交（commit）或者回滚（rollback）。</p></li><li><p>2PC顾名思义分为两个阶段，其实施思路可概括为</p><pre><code>- 投票阶段（voting phase）：参与者将操作结果通知协调者- 提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚</code></pre></li></ul></li><li><p>补偿事务（TCC）<br>TCC事务补偿是基于2PC实现的业务层事务控制方案，它是Try、Confirm和Cancel三个单词的首字母，含义如下: </p><ul><li>Try 检查及预留业务资源，完成提交事务前的检查，并预留好资源。 </li><li>Confirm 确定执行业务操作，对try阶段预留的资源正式执行。 </li><li>Cancel 取消执行业务操作，对try阶段预留的资源释放。<br><img src="https://img-blog.csdnimg.cn/20190226102538885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>举个例子：<ul><li>Try 下单业务由订单服务和库存服务协同完成，在try阶段订单服务和库存服务完成检查和预留资源。订单服务检查当前是否满足提交订单的条件(比如:当前存在未完成订单的不允许提交新订单)。 库存服务检查当前是否有充足的库存，并锁定资源。</li><li>Confirm 订单服务和库存服务成功完成Try后开始正式执行资源操作。订单服务向订单写一条订单信息。库存服务减去库存。</li><li>Cancel 如果订单服务和库存服务有一方出现失败则全部取消操作。订单服务需要删除新增的订单信息。库存服务将减去的库存再还原。</li></ul></li><li>注意事项：TCC接口都需要实现等幂性。</li></ul></li><li><p>MQ事务消息<br>在几种常见的分布式事物解决方案中，这中方法可能是最简单的，但是缺点也是最明显的，就是非常的吃MQ的性能，而且有一些MQ不支持，这个方法我没有做过多的研究，所以就不写了。。。</p></li></ul><h5 id="打个广告"><a href="#打个广告" class="headerlink" title="打个广告"></a>打个广告</h5><p><img src="https://img-blog.csdnimg.cn/20190226104024187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://help.aliyun.com/product/48444.html" target="_blank" rel="noopener">GTS-阿里巴巴全新分布式事务解决方案</a>，这是一个基于云的事物中间件，感兴趣的小伙伴可以了解一下。</p><h5 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h5><p>通过自己的学习，对分布式事务中的CAP定理、BASE理论以及经典的解决方案有了一定的了解。微服务过多就会引出分布式事务，如果允许不建议采用上面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。</p>]]></content>
      
      
      <categories>
          
          <category> Spring/Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务，解决方案，分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂Spring中的事务管理</title>
      <link href="/2020/04/17/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2020/04/17/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要讲解Spring的事务机制。</p><a id="more"></a><h5 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h5><p>有一个最典型的例子用来描述事务：</p><p>在银行里，一个人A给另一个人B转账100元，那么银行会有以下两个操作：</p><ul><li>给A的账户扣100元</li><li>给B的账户增加100元</li></ul><p>但如果在转账的过程中银行系统出了问题，可能会有以下情况：</p><ul><li>A的账户扣了钱，B的账户没有增加钱</li><li>A的账户没扣钱，B的账户增加了钱</li></ul><p>上述两种情况都是不符合期望的，但故障总是可能会发生的，那怎么解决这个问题呢？就是用事务。事务是一系列的动作（比如给A账户扣100元和给B账户增加100元这两个动作），它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。</p><p>也就是说，不管是发生了哪种故障，事务都能回滚到最初的状态：A没有扣钱，B也没有加钱。这样，就能保证整个银行系统的数据是正常的。</p><p>在企业级应用程序开发中，事务管理必不可少的技术，主要应用于数据持久化层面（比如数据库），用来确保数据的完整性和一致性。</p><h5 id="事务有什么特性？"><a href="#事务有什么特性？" class="headerlink" title="事务有什么特性？"></a>事务有什么特性？</h5><p>事务主要有四个特性，我们根据它的英文大写字母简写成：ACID</p><ul><li>原子性（Atomicity）</li></ul><p>事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。所以你可以把一个事务看成一个原子操作。</p><ul><li>一致性（Consistency）</li></ul><p>一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。比如在银行转账的例子中，无论转账成功与否，都需要保证银行的总存款是不变的，这才符合业务的“一致”状态。</p><ul><li>隔离性（Isolation）</li></ul><p>可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。这里涉及到事务的几种隔离级别，将在下文详细介绍。比如多个人都像B转账，他们之间的事务互相不能影响。</p><ul><li>持久性（Durability）</li></ul><p>一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器（如数据库）中。</p><h5 id="Spring事务的核心接口"><a href="#Spring事务的核心接口" class="headerlink" title="Spring事务的核心接口"></a>Spring事务的核心接口</h5><p>先上图：<br><img src="https://img-blog.csdnimg.cn/20190712160015884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，Spring只提供事务的接口，不提供具体的实现。具体的实现是由不同的持久层框架自己去做的。这是典型的“门面模式”。主要有三个接口。</p><p><strong>这三个接口源码方法上都有大量的注释用于解释每个方法的用途和相应的规则，建议读者详细阅读这三个接口的源码</strong>。</p><ul><li>PlatformTransactionManager</li></ul><p>事务管理器，主要用于得到事务状态、提交、回滚等操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 得到当前事务或者创建一个新的事务（取决于事务的传播行为）</span><br><span class="line">TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交一个事务</span><br><span class="line">void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回滚一个事务</span><br><span class="line">void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TransactionDefinition</li></ul><p>用于定义事务的一些属性。这个类里面定义了一些常量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 传播行为</span><br><span class="line">int PROPAGATION_REQUIRED &#x3D; 0;</span><br><span class="line">int PROPAGATION_SUPPORTS &#x3D; 1;</span><br><span class="line">int PROPAGATION_MANDATORY &#x3D; 2;</span><br><span class="line">int PROPAGATION_REQUIRES_NEW &#x3D; 3;</span><br><span class="line">int PROPAGATION_NOT_SUPPORTED &#x3D; 4;</span><br><span class="line">int PROPAGATION_NEVER &#x3D; 5;</span><br><span class="line">int PROPAGATION_NESTED &#x3D; 6;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 隔离级别</span><br><span class="line">int ISOLATION_DEFAULT &#x3D; -1;</span><br><span class="line">int ISOLATION_READ_UNCOMMITTED &#x3D; Connection.TRANSACTION_READ_UNCOMMITTED;</span><br><span class="line">int ISOLATION_READ_COMMITTED &#x3D; Connection.TRANSACTION_READ_COMMITTED;</span><br><span class="line">int ISOLATION_REPEATABLE_READ &#x3D; Connection.TRANSACTION_REPEATABLE_READ;</span><br><span class="line">int ISOLATION_SERIALIZABLE &#x3D; Connection.TRANSACTION_SERIALIZABLE;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认-1表示不设置超时</span><br><span class="line">int TIMEOUT_DEFAULT &#x3D; -1;</span><br><span class="line"></span><br><span class="line">int getPropagationBehavior();</span><br><span class="line">int getIsolationLevel();</span><br><span class="line">int getTimeout();</span><br><span class="line">boolean isReadOnly();</span><br><span class="line"></span><br><span class="line">@Nullable</span><br><span class="line">String getName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TransactionStatus</li></ul><p>用于判断当前事务的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager, Flushable &#123;</span><br><span class="line">boolean isNewTransaction(); &#x2F;&#x2F; 是否是新的事务</span><br><span class="line">boolean hasSavepoint(); &#x2F;&#x2F; 是否有恢复点</span><br><span class="line">void setRollbackOnly(); &#x2F;&#x2F; 设置为只回滚</span><br><span class="line">boolean isRollbackOnly(); &#x2F;&#x2F; 是否为只回滚</span><br><span class="line">@Override</span><br><span class="line">void flush(); &#x2F;&#x2F; 刷新session，如果下游实现支持的话</span><br><span class="line">boolean isCompleted(); &#x2F;&#x2F; 是否已完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事务的属性"><a href="#事务的属性" class="headerlink" title="事务的属性"></a>事务的属性</h5><p>可以给事务定义一些属性，根据<code>TransactionDefinition</code>接口提供的方法来看，主要有传播行为、隔离级别、超时设置、是否只读等四个属性。这里再加上回滚条件，它是在其它地方定义的，但是也算是事务的属性之一。</p><ul><li>传播行为</li></ul><p>再回顾一下<code>TransactionDefinition</code>接口里面定义的关于传播行为的7个常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传播行为</span><br><span class="line">int PROPAGATION_REQUIRED &#x3D; 0;</span><br><span class="line">int PROPAGATION_SUPPORTS &#x3D; 1;</span><br><span class="line">int PROPAGATION_MANDATORY &#x3D; 2;</span><br><span class="line">int PROPAGATION_REQUIRES_NEW &#x3D; 3;</span><br><span class="line">int PROPAGATION_NOT_SUPPORTED &#x3D; 4;</span><br><span class="line">int PROPAGATION_NEVER &#x3D; 5;</span><br><span class="line">int PROPAGATION_NESTED &#x3D; 6;</span><br></pre></td></tr></table></figure><p>事务的传播行为主要用于控制方法间的互相调用的时候，事务的关系。在使用<code>@Transactional</code>注解的时候，也可以设置当前的事务传播行为，<code>@Transactional</code>内部有一个枚举类<code>TxType</code>，里面有前6中传播行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public enum TxType &#123;</span><br><span class="line">    REQUIRED,</span><br><span class="line">    REQUIRES_NEW,</span><br><span class="line">    MANDATORY,</span><br><span class="line">    SUPPORTS,</span><br><span class="line">    NOT_SUPPORTED,</span><br><span class="line">    NEVER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别介绍一下这七种传播行为。</p><p><strong>REQUIRED</strong><br>当前方法必须运行在事务中。如果当前事务存在，方法将在该事务中运行。否则，启动一个新的事务。这通常是默认设置，它能够满足我们绝大多数的事务需求。</p><p><strong>SUPPORTS</strong><br>当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行。</p><p><strong>MANDATORY</strong><br>当前方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常。</p><p><strong>REQUIRED_NEW</strong><br>当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。</p><p><strong>NOT_SUPPORTED</strong><br>当前方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager。</p><p><strong>NEVER</strong><br>当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常。</p><p><strong>NESTED</strong><br>如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。</p><p>如果当前事务不存在，那么其行为与<code>REQUIRED</code>一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务。</p><p><code>REQUIRES_NEW</code>和<code>NESTED</code>的最大区别在于，<code>REQUIRES_NEW</code>完全是一个新的事务，而NESTED则是外部事务的子事务，如果外部事务commit，嵌套事务也会被commit，这个规则同样适用于roll back。</p><ul><li>隔离级别</li></ul><p><strong>并发事务引起的问题</strong></p><p>就如同我们在本文开头谈到的案例，如果多个人同时向B汇款，那就会同时产生多个事务。抽象到程序设计里面，就是一个并发下的事务问题。多个事务并发运行，可能会导致以下问题：</p><ol><li>脏读：发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</li><li>不可重复读：发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</li><li>幻读：与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</li></ol><blockquote><p>Tips：不可重复读和幻读的区别是，不可重复读针对的是<strong>记录里面的值</strong>，而幻读针对的是<strong>记录的增加或删除</strong>。前者只需要锁住满足条件的记录，而后者需要锁住满足条件及其相近的记录。</p></blockquote><p>三种问题，越往后越满足事务的隔离性，但需要锁的东西也越多。</p><p><strong>隔离级别定义</strong></p><p>再回顾一下<code>TransactionDefinition</code>接口里面定义的关于隔离级别的5个常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 数据库默认</span><br><span class="line">int ISOLATION_DEFAULT &#x3D; -1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 允许读取尚未提交的数据变更</span><br><span class="line">&#x2F;&#x2F; 可能会导致所有类型的并发问题</span><br><span class="line">int ISOLATION_READ_UNCOMMITTED &#x3D; Connection.TRANSACTION_READ_UNCOMMITTED;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 允许读取并发事务已经提交的数据</span><br><span class="line">&#x2F;&#x2F; 可以解决 脏读</span><br><span class="line">int ISOLATION_READ_COMMITTED &#x3D; Connection.TRANSACTION_READ_COMMITTED;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改</span><br><span class="line">&#x2F;&#x2F; 可以解决 脏读 和 不可重复读</span><br><span class="line">int ISOLATION_REPEATABLE_READ &#x3D; Connection.TRANSACTION_REPEATABLE_READ;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 最高的隔离级别，完全服从ACID的隔离级别</span><br><span class="line">&#x2F;&#x2F; 可以阻止脏读、不可重复读以及幻读，</span><br><span class="line">&#x2F;&#x2F; 也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</span><br><span class="line">int ISOLATION_SERIALIZABLE &#x3D; Connection.TRANSACTION_SERIALIZABLE;</span><br></pre></td></tr></table></figure><ul><li>超时</li></ul><p>超时很好理解，因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</p><ul><li>是否只读</li></ul><p>如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。</p><ul><li>回滚条件</li></ul><p>默认情况下，事务只有遇到运行期异常<code>RuntimeException</code>时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）。<br>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p><p>这个回滚条件不是在<code>TransactionDefinition</code>接口里面定义的，我们可以在使用<code>@Transactional</code>注解的时候定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(rollbackOn &#x3D; &#123;RuntimeException.class, MyException.class&#125;, </span><br><span class="line">        dontRollbackOn &#x3D; &#123;FileNotFoundException.class&#125;)</span><br></pre></td></tr></table></figure><h5 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h5><p>从<code>TransactionStatus</code>接口的方法可以了解到事务主要有哪些状态。而<code>PlatformTransactionManager</code>管理事务也要依靠事务的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager, Flushable &#123;</span><br><span class="line">boolean isNewTransaction(); &#x2F;&#x2F; 是否是新的事务</span><br><span class="line">boolean hasSavepoint(); &#x2F;&#x2F; 是否有恢复点</span><br><span class="line">void setRollbackOnly(); &#x2F;&#x2F; 设置为只回滚</span><br><span class="line">boolean isRollbackOnly(); &#x2F;&#x2F; 是否为只回滚</span><br><span class="line">@Override</span><br><span class="line">void flush(); &#x2F;&#x2F; 刷新session，如果下游实现支持的话</span><br><span class="line">boolean isCompleted(); &#x2F;&#x2F; 是否已完成</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190712161239104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Spring的事务管理抽象主要提供了<code>DefaultTransactionStatus</code>和<code>SimpleTransactionStatus</code>两个实现。而<code>MultiTransactionStatus</code>是由Spring Data项目提供的实现。</p><p>这里主要介绍一下<code>Savepoint</code>和<code>RollbackOnly</code>两个概念。</p><ul><li>Savepoint</li></ul><p>Savepoint的概念是来自于SavepointManager接口，可以在一个事务中创建多个“恢复点”，在回滚的时候可以回滚到定义好的“恢复点”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface SavepointManager &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个恢复点</span><br><span class="line">Object createSavepoint() throws TransactionException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回滚到恢复点</span><br><span class="line">void rollbackToSavepoint(Object savepoint) throws TransactionException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除一个恢复点</span><br><span class="line">void releaseSavepoint(Object savepoint) throws TransactionException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>RollbackOnly</li></ul><p>这个其实是与事务的传播行为有关。在Spring中，默认的事务传播行为通常是REQUIRED，如果当前事务存在，方法将在该事务中运行。否则，启动一个新的事务。</p><p>那这种情况下，A方法调用B方法，需要等AB方法都执行完之后才能提交事务。如果在这个过程中，B方法发生了异常，Spring就会将该事务标志为<strong>RollbackOnly</strong>，在A方法执行完后提交事务之前会检查当前事务的RollbackOnly标志，如果是<strong>true</strong>，就会回滚。</p><p>所有在使用Spring Data JPA或Mybatis等框架时可能经常遇到报<strong>Transaction rolled back because it has been marked as rollback-only</strong>的异常，这个异常的原理就是这样的。解决这个问题的方式有两种：</p><ol><li>修改事务的传播行为</li><li>在使用<code>@Transactional</code>的时候设置好<code>dontRollbackOn</code>属性，忽略指定的异常。</li></ol><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><p><a href="https://blog.csdn.net/trigl/article/details/50968079" target="_blank" rel="noopener">Spring事务管理（详解+实例）</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring/Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务，Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot集成rabbitMQ实现消息推送</title>
      <link href="/2020/04/17/Spring-Boot%E9%9B%86%E6%88%90rabbitMQ%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
      <url>/2020/04/17/Spring-Boot%E9%9B%86%E6%88%90rabbitMQ%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot集成rabbitMQ实现消息推送，rabbitMQ为异步消息处理提出了一个很好的解决方案，它是一个非常好用的消息中间件。主要解决当生产者大量产生数据时，消费者无法快速消费的问题。这个时候需要一个中间层，保存这个数据，rabbitMQ是一个很好的解决方案。</p><a id="more"></a><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul><li>Spring Boot集成rabbitMQ实现消息推送，rabbitMQ为异步消息处理提出了一个很好的解决方案，它是一个非常好用的消息中间件。主要解决当生产者大量产生数据时，消费者无法快速消费的问题。这个时候需要一个中间层，保存这个数据，rabbitMQ是一个很好的解决方案。</li><li>Spring Boot为rabbitMQ提供了支持, Spring Boot为rabbitMQ准备了spring-boot-starter-amqp，并且为RabbitTemplate和rabbitMQ提供了自动配置选项。</li><li>AMQP协议，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</li></ul><h5 id="安装rabbitMQ"><a href="#安装rabbitMQ" class="headerlink" title="安装rabbitMQ"></a>安装rabbitMQ</h5><ul><li><p>安装brew<br><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></p></li><li><p>安装rabbitmq<br><code>brew install rabbitmq</code></p></li><li><p>启动rabbitmq server<br>  <code>cd /usr/local/sbin/</code><br>  <code>sudo ./rabbitmq-server</code></p></li><li><p>成功示例，端口是5672</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20190917154932979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><ul><li>通常我们谈到队列服务, 会有三个概念：发消息者、队列、收消息者，RabbitMQ在这个基本概念之上, 多做了一层抽象, 在发消息者和队列之间, 加入了交换器 (Exchange)。这样发消息者和队列就没有直接联系, 转而变成发消息者把消息给交换器, 交换器根据调度策略再把消息再给队列。<br><img src="https://img-blog.csdnimg.cn/20190917155030387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>Broker：简单来说就是消息队列服务器实体。</li><li>Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。</li><li>Queue：消息队列载体，每个消息都会被投入到一个或多个队列。</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。</li><li>Routing Key：路由关键字，exchange根据这个关键字进行消息投递。</li><li>Producer：消息生产者，就是投递消息的程序。</li><li>Consumer：消息消费者，就是接受消息的程序。</li><li>Channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。</li></ul><h5 id="基本使用过程"><a href="#基本使用过程" class="headerlink" title="基本使用过程"></a>基本使用过程</h5><ul><li>客户端连接到消息队列服务器，打开一个channel。</li><li>客户端声明一个exchange，并设置相关属性。</li><li>客户端声明一个queue，并设置相关属性。</li><li>客户端使用routing key，在exchange和queue之间建立好绑定关系。</li><li>客户端投递消息到exchange。</li><li>exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。<br><img src="https://img-blog.csdnimg.cn/20190917155125563.jpg" alt="在这里插入图片描述"><h5 id="Exchange四种类型"><a href="#Exchange四种类型" class="headerlink" title="Exchange四种类型"></a>Exchange四种类型</h5></li><li>Direct模式（常用）<ul><li>Direct exchange完全根据key进行投递，只有key与绑定时的routing-key完全一致的消息才会收到消息。</li></ul></li><li>Topic模式（常用）<ul><li>Topic exchange会根据key进行模式匹配然后进行投递，与设置的routing-key匹配上的队列才能收到消息。</li></ul></li><li>Fanout模式<ul><li>每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。fanout交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。</li></ul></li><li>Header模式（不常用）<ul><li>不太常用，可以自定义匹配规则。</li></ul></li></ul><h5 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h5><ul><li>RabbitMQ支持消息的持久化，即将消息数据持久化到磁盘上，如果消息服务器中途断开，下次开启会将持久化的消息重新发送。</li><li>声明交换机Exchange的时候设置 durable=true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TopicExchange exchange() &#123;</span><br><span class="line">      return new TopicExchange(EXCHANGE_NAME,true,false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>队列的持久化<ul><li>声明队列Queue的时候设置 durable=true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Queue queue() &#123;</span><br><span class="line">    &#x2F;&#x2F;durable：是否将队列持久化 true表示需要持久化 false表示不需要持久化</span><br><span class="line">    return new Queue(QUEUE_NAME, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>消息的持久化<ul><li>发送消息的时候设置消息的 deliveryMode = 2<br><code>new MessageProperties() --&gt; DEFAULT_DELIVERY_MODE = MessageDeliveryMode.PERSISTENT --&gt; deliveryMode = 2;</code><ul><li>出于数据安全考虑，一般消息都会进行持久化。</li></ul></li></ul></li></ul><h5 id="保证MQ消息的幂等性"><a href="#保证MQ消息的幂等性" class="headerlink" title="保证MQ消息的幂等性"></a>保证MQ消息的幂等性</h5><ul><li>mq内部会为每条消息生成一个全局唯一、与业务无关的消息id，当mq接收到消息时，会先根据该id判断消息是否重复发送，mq再决定是否接收该消息。<ul><li>Java自带的UUID</li><li>Twitter Snowflake</li></ul></li><li>利用MySQL的唯一索引UNIQUE KEY，如果重复了，数据就会插入失败。</li></ul><p><strong>代码都放在<a href="https://github.com/BazookaW/spring-boot-rabbitMQ/tree/master/spring_boot_rabbitMQ" target="_blank" rel="noopener">这里</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Spring/Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot，rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在微服务中使用Spring-Retry</title>
      <link href="/2020/04/17/%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8Spring-Retry/"/>
      <url>/2020/04/17/%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8Spring-Retry/</url>
      
        <content type="html"><![CDATA[<p><code>Spring-Retry</code>为Spring应用程序提供声明式重试机制。在微服务架构中，服务之间的调用会依赖网络，或者在调用第三方接口或者使用mq时，会出现网络抖动，连接超时等网络异常，所以需要重试。<code>Spring-Boot</code>项目使用<code>Spring-Retry</code>非常简单，在配置类加上@EnableRetry注解启用spring-retry，然后在需要失败重试的方法加@Retryable注解即可，<code>Spring-Retry</code>通过捕获异常来触发重试机制。为了使处理更加健壮并且不太容易出现故障，后续的尝试操作，有时候会帮助失败的操作最后执行成功。</p><a id="more"></a><ul><li><code>Spring-Retry</code>为Spring应用程序提供声明式重试机制。在微服务架构中，服务之间的调用会依赖网络，或者在调用第三方接口或者使用mq时，会出现网络抖动，连接超时等网络异常，所以需要重试。</li><li><code>Spring-Boot</code>项目使用<code>Spring-Retry</code>非常简单，在配置类加上@EnableRetry注解启用spring-retry，然后在需要失败重试的方法加@Retryable注解即可，<code>Spring-Retry</code>通过捕获异常来触发重试机制。为了使处理更加健壮并且不太容易出现故障，后续的尝试操作，有时候会帮助失败的操作最后执行成功。</li></ul><h5 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="入口类"><a href="#入口类" class="headerlink" title="入口类"></a>入口类</h5><p>需要在程序入口加<code>@EnableRetry</code>注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableRetry</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Service类"><a href="#Service类" class="headerlink" title="Service类"></a>Service类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retryable</span>(value = Exception<span class="class">.<span class="keyword">class</span>, <span class="title">maxAttempts</span> </span>= <span class="number">5</span>, backoff = <span class="meta">@Backoff</span>(delay = <span class="number">2000L</span>, multiplier = <span class="number">1.5</span>))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"retry"</span> + LocalTime.now());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteAccessException(<span class="string">"RemoteAccessException...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Recover</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(RemoteAccessException e)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"error message is"</span> + e.getMessage());</span><br><span class="line">        log.info(<span class="string">"recover...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Test类"><a href="#Test类" class="headerlink" title="Test类"></a>Test类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RetryService retryService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reteyTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">retryService.retry();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h5><p><img src="https://img-blog.csdnimg.cn/2019103116511468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><ul><li><code>@EnableRetry</code>能否重试。在spring-Boot中此参数写在程序入口即可。</li><li><code>@Retryable</code><ul><li>value：需要进行重试的异常，和参数includes是一个意思。默认为空，当参数exclude也为空时，所有异常都将要求重试。</li><li>include：需要进行重试的异常，默认为空。当参数exclude也为空时，所有异常都将要求重试。</li><li>exclude：不需要重试的异常。默认为空，当参include也为空时，所有异常都将要求重试。</li><li>stateful：标明重试是否是有状态的，异常引发事物失效的时候需要注意这个。该参数默认为false。远程方法调用的时候不需要设置，因为远程方法调用是没有事物的；只有当数据库更新操作的时候需要设置该值为true，特别是使用Hibernate的时候。抛出异常时，异常会往外抛，使事物回滚；重试的时候会启用一个新的有效的事物。</li><li>maxAttempts：最大重试次数，默认为3。包括第一次失败。</li><li>backoff：回避策略，默认为空。该参数为空时是，失败立即重试，重试的时候阻塞线程。</li></ul></li><li><code>@Recover</code>：该注解用于恢复处理方法，当全部尝试都失败时执行。返回参数必须和<code>@Retryable</code>修饰的方法返回参数完全一样。第一个参数必须是异常，其他参数和<code>@Retryable</code>修饰的方法参数顺序一致。</li><li><code>@Backoff</code><ul><li>value：重试延迟时间，单位毫秒，默认值1000，即默认延迟1秒。当未设置multiplier时，表示每隔value的时间重试，直到重试次数到达maxAttempts设置的最大允许重试次数。当设置了multiplier参数时，该值作为幂运算的初始值。等同<code>delay</code>参数，两个参数设置一个即可。</li><li>delay：等同<code>value</code>。</li><li>maxDelay：两次重试间最大间隔时间。当设置<code>multiplier</code>参数后，下次延迟时间根据是上次延迟时间乘以<code>multiplier</code>得出的，这会导致两次重试间的延迟时间越来越长，该参数限制两次重试的最大间隔时间，当间隔时间大于该值时，计算出的间隔时间将会被忽略，使用上次的重试间隔时间。</li><li>multiplier：作为乘数用于计算下次延迟时间。公式：<code>delay = delay * multiplier</code></li></ul></li><li>dsa</li></ul><h5 id="注意的地方"><a href="#注意的地方" class="headerlink" title="注意的地方"></a>注意的地方</h5><ul><li>使用了<code>@Retryable</code>的方法里面不能使用try…catch包裹，要在方法上抛出异常，不然不会触发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring/Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring，Spring-Retry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务中如何处理全局异常</title>
      <link href="/2020/04/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/04/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>微服务中，全局异常处理是一个必须解决的客观课题，如果这些异常处理不好的话，就会给用户看到一些不友好的错误信息，比如客户看到了空指针异常，SQL执行错误等异常，客户肯定是看不懂的，从而大大降低用户体验。</p><a id="more"></a><p>微服务中，全局异常处理是一个必须解决的客观课题，如果这些异常处理不好的话，就会给用户看到一些不友好的错误信息，比如客户看到了空指针异常，SQL执行错误等异常，客户肯定是看不懂的，从而大大降低用户体验。</p><h5 id="全局异常处理的常见解决方案"><a href="#全局异常处理的常见解决方案" class="headerlink" title="全局异常处理的常见解决方案"></a>全局异常处理的常见解决方案</h5><ul><li>定义一个处理异常的类，需要处理异常的Controller直接继承这个类，从而获取到异常处理的方法。虽然这种方式可以解决问题，但是极其不灵活，因为动用了继承机制就只为获取一个默认的方法，这显然是不好的。</li><li>将这个基类变为接口，提供此方法的默认实现（也就是接口中的default方法，java8开始支持接口方法的默认实现），几乎所有的Controller都需要进行异常处理，所以Controller都需要去写implement  XXXException，这个方法显然看起来不是很好。况且这种方式依赖java8才有的语法，这是一个很大的局限。</li><li>使用<code>@controllerAdvice + @ExpectionHandler</code>，接下来就以这种方式来实现一些全局异常处理。<code>@ControllerAdvice</code>作为Spring中默认的注解，提供对所有（你的项目包扫描范围内）Controller的异常捕获功能。</li></ul><h5 id="定义默认返回实体"><a href="#定义默认返回实体" class="headerlink" title="定义默认返回实体"></a>定义默认返回实体</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JsonEntity&lt;T&gt; implements java.io.Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -1771426378340695807L;</span><br><span class="line">    T data;</span><br><span class="line">    private int status &#x3D; 200;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public JsonEntity() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public JsonEntity(T data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; 省略getter&#x2F;setter</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;JsonEntity&#123;&quot; +</span><br><span class="line">               &quot;status&#x3D;&quot; + status +</span><br><span class="line">               &quot;, message&#x3D;&#39;&quot; + message + &#39;\&#39;&#39; +</span><br><span class="line">               &quot;, data&#x3D;&quot; + data +</span><br><span class="line">               &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义ExceptionResponse，当发生异常时返回的实体，放在JsonEntity的data里"><a href="#定义ExceptionResponse，当发生异常时返回的实体，放在JsonEntity的data里" class="headerlink" title="定义ExceptionResponse，当发生异常时返回的实体，放在JsonEntity的data里"></a>定义ExceptionResponse，当发生异常时返回的实体，放在JsonEntity的data里</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ExceptionResponse implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; -5599209786899732586L;</span><br><span class="line">    private String errorMessage;</span><br><span class="line">    private String classType;</span><br><span class="line">&#x2F;&#x2F; 省略getter&#x2F;setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义BaseException，继承RuntimeException"><a href="#定义BaseException，继承RuntimeException" class="headerlink" title="定义BaseException，继承RuntimeException"></a>定义BaseException，继承RuntimeException</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public abstract class BaseException extends RuntimeException implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 5047454682872098494L;</span><br><span class="line">    private int responseStatus &#x3D; HttpStatus.INTERNAL_SERVER_ERROR.value();</span><br><span class="line">    private Object[] parameters &#x3D; null;</span><br><span class="line">    private Logger logger &#x3D; LoggerFactory.getLogger(BaseException.class);</span><br><span class="line"></span><br><span class="line">    public BaseException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseException(Throwable cause) &#123;</span><br><span class="line">        super(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123;</span><br><span class="line">        super(message, cause, enableSuppression, writableStackTrace);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseException(Object[] parameters) &#123;</span><br><span class="line">        this.parameters &#x3D; parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseException(String message, Object[] parameters) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.parameters &#x3D; parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int determineResponseStatus(Throwable throwable) &#123;</span><br><span class="line">        if (throwable instanceof BaseException) &#123;</span><br><span class="line">            return ((BaseException) throwable).responseStatus();</span><br><span class="line">        &#125;</span><br><span class="line">        return HttpStatus.INTERNAL_SERVER_ERROR.value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int determineResponseStatus(Throwable throwable, int defaultValue) &#123;</span><br><span class="line">        if (throwable &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return defaultValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return determineResponseStatus(throwable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BaseException responseStatus(int responseStatus) &#123;</span><br><span class="line">        this.responseStatus &#x3D; responseStatus;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int responseStatus() &#123;</span><br><span class="line">        return responseStatus;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage(String fmt) &#123;</span><br><span class="line">        if (ObjectUtil.isEmpty(parameters)) &#123;&#x2F;&#x2F;NOPMD</span><br><span class="line">            return fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.format(fmt, parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return (super.getMessage() &#x3D;&#x3D; null ? &quot;&quot; : super.getMessage()) + formatParameters();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLocalizedMessage() &#123;</span><br><span class="line">        return getLocalizedMessage(LocaleContextHolder.getLocale());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLocalizedMessage(Locale locale) &#123;</span><br><span class="line">        Assert.notNull(locale);</span><br><span class="line">        return getFromMessageSource(super.getMessage(), parameters, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String getFromMessageSource(String messageCode, Object[] params, Locale locale) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MessageSource messageSource &#x3D; SpringContextHelper.afterSpringFullyStarted().getBeanSilently(MessageSource.class);</span><br><span class="line">            if (messageSource !&#x3D; null) &#123;</span><br><span class="line">                return messageSource.getMessage(messageCode, params, locale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.trace(&quot;error: &#123;&#125;, fallback to non-localized code, code: &#123;&#125;&quot;, e.getMessage(), messageCode);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.trace(&quot;messageSource absent, fallback to non-localized message, code: &#123;&#125;&quot;, messageCode);</span><br><span class="line">        return getMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String formatParameters() &#123;</span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">        if (!isEmpty(parameters)) &#123;</span><br><span class="line">            sb.append(&quot; [params: &quot;);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; parameters.length; i++) &#123;</span><br><span class="line">                sb.append(i).append(&quot;:&quot;).append(parameters[i]);</span><br><span class="line">                if (i &lt; parameters.length - 1) &#123;</span><br><span class="line">                    sb.append(&quot;, &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(&quot;] &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object[] getParameters() &#123;</span><br><span class="line">        return parameters;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void throwIf(boolean condition) &#123;</span><br><span class="line">        if (condition) &#123;</span><br><span class="line">            throw this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="定义BizException，继承BaseException用来处理业务异常"><a href="#定义BizException，继承BaseException用来处理业务异常" class="headerlink" title="定义BizException，继承BaseException用来处理业务异常"></a>定义BizException，继承BaseException用来处理业务异常</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class BizException extends BaseException &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 4328407468288938158L;</span><br><span class="line"></span><br><span class="line">    public BizException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message, int status) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.responseStatus(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message, Throwable cause, int status) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.responseStatus(status);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(Throwable cause) &#123;</span><br><span class="line">        super(cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(Throwable cause, int status) &#123;</span><br><span class="line">        super(cause);</span><br><span class="line">        this.responseStatus(status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123;</span><br><span class="line">        super(message, cause, enableSuppression, writableStackTrace);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(Object[] params) &#123;</span><br><span class="line">        super(params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BizException(String message, Object[] params) &#123;</span><br><span class="line">        super(message, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BaseException ofMessage(String message) &#123;</span><br><span class="line">        return new BizException(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义GlobalExceptionHandler，并使用-ControllerAdvice"><a href="#定义GlobalExceptionHandler，并使用-ControllerAdvice" class="headerlink" title="定义GlobalExceptionHandler，并使用@ControllerAdvice"></a>定义GlobalExceptionHandler，并使用<code>@ControllerAdvice</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    private ResponseStatusExceptionResolver responseStatusExceptionResolver;</span><br><span class="line"></span><br><span class="line">    @Autowired(required &#x3D; false)</span><br><span class="line">    private DefaultHandlerExceptionResolver defaultHandlerExceptionResolver;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public final void postInit() &#123;</span><br><span class="line">        if (responseStatusExceptionResolver &#x3D;&#x3D; null) &#123;</span><br><span class="line">            responseStatusExceptionResolver &#x3D; new ResponseStatusExceptionResolver();</span><br><span class="line">        &#125;</span><br><span class="line">        if (defaultHandlerExceptionResolver &#x3D;&#x3D; null) &#123;</span><br><span class="line">            defaultHandlerExceptionResolver &#x3D; new DefaultHandlerExceptionResolver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected ResponseEntity jsonResponse(HttpServletRequest request, HttpServletResponse response, int status, Exception e) &#123;&#x2F;&#x2F;NOPMD</span><br><span class="line">        JsonEntity&lt;ExceptionResponse&gt; resp &#x3D; ResponseHelper.createInstance(ExceptionUtil.getExceptionResponse(request, e));</span><br><span class="line">        resp.setStatus(status);</span><br><span class="line">        resp.setMessage(ExceptionUtil.getErrorMessage(e));</span><br><span class="line">        return new ResponseEntity&lt;&gt;(resp, HttpStatus.valueOf(status));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ExceptionHandler(value &#x3D; Exception.class)</span><br><span class="line">    @Order(Ordered.LOWEST_PRECEDENCE)</span><br><span class="line">    public final Object defaultErrorHandler(HttpServletRequest req, HttpServletResponse response, @Nullable Object handler, Exception e) &#123;</span><br><span class="line">        if (e instanceof InternalHttpException) &#123;</span><br><span class="line">            log.warn(e.getMessage());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        ErrorWrapperResponse wrapperResponse &#x3D; new ErrorWrapperResponse(response);</span><br><span class="line"></span><br><span class="line">        ModelAndView modelAndView &#x3D; responseStatusExceptionResolver.resolveException(req, wrapperResponse, handler, e);</span><br><span class="line">        if (modelAndView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            modelAndView &#x3D; defaultHandlerExceptionResolver.resolveException(req, wrapperResponse, handler, e);</span><br><span class="line">        &#125;</span><br><span class="line">        int status;</span><br><span class="line"></span><br><span class="line">        if (modelAndView &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (e instanceof BaseException) &#123;</span><br><span class="line">                status &#x3D; ((BaseException) e).responseStatus();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                status &#x3D; HttpStatus.INTERNAL_SERVER_ERROR.value();</span><br><span class="line">            &#125;</span><br><span class="line">            modelAndView &#x3D; new ModelAndView();</span><br><span class="line">            req.setAttribute(&quot;javax.servlet.error.exception&quot;, e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            status &#x3D; wrapperResponse.getStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (WebUtil.isAjax(req)) &#123;</span><br><span class="line">            return jsonResponse(req, response, status, e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return htmlResponse(req, response, modelAndView, status, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object htmlResponse(HttpServletRequest request, HttpServletResponse response, ModelAndView modelAndView, int status, Exception e) &#123;&#x2F;&#x2F;NOPMD</span><br><span class="line">        modelAndView.addObject(&quot;requestId&quot;, WebUtil.getRequestId());</span><br><span class="line">        modelAndView.addObject(&quot;javax.servlet.error.exception&quot;, e);</span><br><span class="line">        modelAndView.addObject(&quot;errorStatus&quot;, status);</span><br><span class="line">        modelAndView.setStatus(HttpStatus.valueOf(status));</span><br><span class="line">        switch (status) &#123;</span><br><span class="line">            case 400:</span><br><span class="line">            case 401:</span><br><span class="line">            case 403:</span><br><span class="line">            case 404:</span><br><span class="line">            case 405:</span><br><span class="line">            case 410:</span><br><span class="line">            case 415:</span><br><span class="line">            case 500:</span><br><span class="line">                modelAndView.setViewName(&quot;error&#x2F;&quot; + status);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                modelAndView.setViewName(&quot;error&#x2F;500&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ErrorWrapperResponse extends HttpServletResponseWrapper &#123;</span><br><span class="line"></span><br><span class="line">        private int status &#x3D; 200;</span><br><span class="line"></span><br><span class="line">        private String message;</span><br><span class="line"></span><br><span class="line">        private boolean hasErrorToSend &#x3D; false;</span><br><span class="line"></span><br><span class="line">        ErrorWrapperResponse(HttpServletResponse response) &#123;</span><br><span class="line">            super(response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void sendError(int status) throws IOException &#123;</span><br><span class="line">            sendError(status, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void sendError(int status, String message) throws IOException &#123;</span><br><span class="line">            this.status &#x3D; status;</span><br><span class="line">            this.message &#x3D; message;</span><br><span class="line">            this.hasErrorToSend &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int getStatus() &#123;</span><br><span class="line">            if (this.hasErrorToSend) &#123;</span><br><span class="line">                return this.status;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return super.getStatus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String getMessage() &#123;</span><br><span class="line">            return this.message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasErrorToSend() &#123;</span><br><span class="line">            return this.hasErrorToSend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul><li><a href="https://blog.csdn.net/andy_zhang2007/article/details/100041219" target="_blank" rel="noopener">注解@ControllerAdvice的工作原理</a></li><li><a href="https://www.cnblogs.com/wudimanong/p/10710923.html" target="_blank" rel="noopener">Spring Cloud微服务如何设计异常处理机制？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring/Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务，解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中两种动态代理：JDK动态代理和CGLib动态代理</title>
      <link href="/2020/04/17/Spring%E4%B8%AD%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9AJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2020/04/17/Spring%E4%B8%AD%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9AJDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CCGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>自Java 1.3以后，Java提供了动态代理技术，允许开发者在运行期创建接口的代理实例，后来这项技术被用到了Spring的很多地方。</p><a id="more"></a><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul><li><p>自Java 1.3以后，Java提供了动态代理技术，允许开发者在运行期创建接口的代理实例，后来这项技术被用到了Spring的很多地方。</p></li><li><p>JDK动态代理主要涉及java.lang.reflect包下边的两个类：Proxy和InvocationHandler。其中，InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑贬值在一起。</p></li><li><p>JDK动态代理的话，他有一个限制，就是它只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，如何创建动态代理实例哪？答案就是CGLib。</p></li><li><p>CGLib采用底层的字节码技术，全称是：Code Generation Library，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑。</p></li></ul><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ul><li><h6 id="JDK动态代理："><a href="#JDK动态代理：" class="headerlink" title="JDK动态代理："></a>JDK动态代理：</h6><ul><li><p>通过实现InvocationHandlet接口创建自己的调用处理器；</p></li><li><p>通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理；</p></li><li><p>通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；</p></li><li><p>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入；</p></li><li><p>注意Proxy.newProxyInstance()方法接受三个参数：</p><ul><li>ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的</li><li>Class&lt;?&gt;[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型</li><li>InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法</li></ul></li></ul></li><li><h6 id="CGLib动态代理："><a href="#CGLib动态代理：" class="headerlink" title="CGLib动态代理："></a>CGLib动态代理：</h6><ul><li>利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li><li>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代理的类，重写父类的方法，从而实现CGLib动态代理。使用CGLib的时候需要引入CGLIB库（asm-5.2.jar,cglib-3.2.5.jar。版本自行选择）。</li></ul></li><li><h6 id="对比："><a href="#对比：" class="headerlink" title="对比："></a>对比：</h6><ul><li>JDK动态代理是面向接口的。</li><li>CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么会失败）。</li></ul></li></ul><h5 id="如何在Spring中强制使用CGLIB"><a href="#如何在Spring中强制使用CGLIB" class="headerlink" title="如何在Spring中强制使用CGLIB"></a>如何在Spring中强制使用CGLIB</h5><ul><li>在Spring中动态代理默认使用的是JDK动态代理</li><li>在application.yml里修改</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">aop:</span><br><span class="line">    proxy-target-class: false</span><br></pre></td></tr></table></figure><h5 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h5><p>以买房子为例，需要房产中介帮忙练习买家等操作可以理解为代理模式。</p><ul><li>JDK动态代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">private Object object;</span><br><span class="line"></span><br><span class="line">public DynamicProxyHandler(final Object object) &#123;</span><br><span class="line">this.object &#x3D; object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;动态代理开始---------&gt;&quot;);</span><br><span class="line">Object result &#x3D; method.invoke(object, args);</span><br><span class="line">System.out.println(&quot;动态代理结束---------&gt;&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] agrs) &#123;</span><br><span class="line">&#x2F;&#x2F; 动态代理</span><br><span class="line">Subject subject &#x3D; new LianJia();</span><br><span class="line">Subject dynamicProxy &#x3D; (Subject) Proxy.newProxyInstance(Subject.class.getClassLoader(), new Class[] &#123; Subject.class &#125;,</span><br><span class="line">new DynamicProxyHandler(subject));</span><br><span class="line">dynamicProxy.buyHouse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CGLib动态代理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CglibProxy implements MethodInterceptor &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;定义获取代理对象方法</span><br><span class="line">    public Object getCglibProxy(Object objectTarget)&#123;</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(objectTarget.getClass());</span><br><span class="line">        enhancer.setCallback(this); </span><br><span class="line">        Object result &#x3D; enhancer.create(); </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;Cglib动态代理开始---------&gt;&quot;);</span><br><span class="line">        </span><br><span class="line">        Object invoke &#x3D; proxy.invokeSuper(obj, args);</span><br><span class="line">       </span><br><span class="line">        System.out.println(&quot;Cglib动态代理结束---------&gt;&quot;);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">        CglibProxy cglib &#x3D; new CglibProxy(); </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取代理对象</span><br><span class="line">        Subject cglibDynamic &#x3D;  (Subject) cglib.getCglibProxy(new LianJia());</span><br><span class="line">       </span><br><span class="line">        cglibDynamic.buyHouse();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="使用注意："><a href="#使用注意：" class="headerlink" title="使用注意："></a>使用注意：</h5><ul><li><p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）；</p></li><li><p>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring/Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring/Spring Boot重点知识整理</title>
      <link href="/2020/04/17/Spring-Spring-Boot%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2020/04/17/Spring-Spring-Boot%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要整理了Spring/SpringBoot的重点知识。</p><a id="more"></a><h5 id="Why-Spring"><a href="#Why-Spring" class="headerlink" title="Why Spring"></a>Why Spring</h5><ul><li><strong>非侵入式</strong>：支持基于POJO的编程模式，不强制性的要求实现Spring框架中的接口或继承Spring框架中的类，这些功能赋予了将其与其他技术结合使用的灵活性。例如，我们可以使用@Inject不是基于Spring的注解的注解来注入依赖项。</li><li><strong>IOC容器</strong>：IoC容器帮助应用程序管理对象以及对象之间的依赖关系，对象之间的依赖关系如果发生了改变只需要修改配置文件而不是修改代码，因为代码的修改可能意味着项目的重新构建和完整的回归测试。有了IoC容器，程序员再也不需要自己编写工厂、单例，这一点特别符合Spring的精神“不要重复的发明轮子”。</li><li><strong>AOP（面向切面编程）</strong>：将所有的横切关注功能封装到切面（aspect）中，通过配置的方式将横切关注功能动态添加到目标代码上，进一步实现了业务逻辑和系统服务之间的分离。另一方面，有了AOP程序员可以省去很多自己写代理类的工作。</li><li><strong>事务管理</strong>：Spring以宽广的胸怀接纳多种持久层技术，并且为其提供了声明式的事务管理，在不需要任何一行代码的情况下就能够完成事务管理。</li><li><strong>MVC</strong>：Spring的MVC框架是非常优秀的，为Web表示层提供了更好的解决方案。</li><li><strong>异常处理</strong>：Spring Framework提供了多个选项，以更好，更灵活的方式处理异常。</li></ul><h5 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h5><p>IOC即Inversion of control，直译过来就是控制反转，它的意思是将对象，以及对象之间的引用关系，交给容器管理（The IOC container）。</p><p>在IOC出现以前，组件之间的协调关系是由程序内部代码来控制的，或者说，以前我们使用New object()这样子的语法实现两组件之间的依赖关系的。这种方式就造成了组件之间的互相耦合。IOC(控制反转)就是来解决这个问题的，它将实现组件间的关系从程序内部提到外部容器来管理（The IOC container）。也就是说，由容器在运行期将组件间的某种依赖关系动态的注入组件中。</p><p><strong>Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</strong></p><p>IOC是基于工厂模式加反射机制实现的。</p><h5 id="Spring-Bean作用域"><a href="#Spring-Bean作用域" class="headerlink" title="Spring Bean作用域"></a>Spring Bean作用域</h5><table><thead><tr><th>作用域</th><th>含义</th></tr></thead><tbody><tr><td>singleton</td><td>单例模式，在整个Spring IoC容器中，singleton作用域的Bean将只生成一个实例，为Spring的默认值</td></tr><tr><td>prototype</td><td>每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的Bean。</td></tr><tr><td>request</td><td>对于一次HTTP请求，request作用域的Bean将只生成一个实例，这意味着，在同一次HTTP请求内，程序每次请求该Bean，得到的总是同一个实例。</td></tr><tr><td>session</td><td>该作用域将 bean 的定义限制为 HTTP 会话。在web应用中为每一个会话创建一个Bean实例。</td></tr></tbody></table><p>通常可以这样子设置Bean的作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br></pre></td></tr></table></figure><p>或者这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;xx&quot; class&#x3D;&quot;xx.xx.xx&quot; scope&#x3D;&quot;prototype&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h5 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h5><p><img src="https://img-blog.csdnimg.cn/20200218153558956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>Spring对Bean进行实例化</li><li>Spring将值和Bean的引用注入到Bean对应的属性中</li><li>如果Bean实现了BeanNameAware接口，Spring将Bean的ID传给setBean-Name()方法</li><li>如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li><li>如果Bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将Bean所在的应用上下文的引用传入进来</li><li>如果Bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法</li><li>如果Bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似的，如果Bean使用了init-method生命了初始化方法，该方法也会被调用。</li><li>如果Bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法</li><li>至此，Bean已经准备就绪，可以被应用程序使用了</li><li>如果Bean实现了DisposableBean接口，Spring将调用它的destory()方法。同样，如果Bean使用了destory-method声明了销毁方法，该方法也会被调用。</li></ol><h5 id="Bean注入的三种方式"><a href="#Bean注入的三种方式" class="headerlink" title="Bean注入的三种方式"></a>Bean注入的三种方式</h5><ul><li>基于XML的bean定义（需要提供setter方法）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">private Teacher teacher;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Teacher getTeacher() &#123;</span><br><span class="line">return teacher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">this.teacher &#x3D; teacher;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.demo.ioc.Bean.Student&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;张三&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;teacher&quot; ref&#x3D;&quot;teacher&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;bean id&#x3D;&quot;teacher&quot; class&#x3D;&quot;com.demo.ioc.Bean.Teacher&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;李四&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import com.demo.ioc.Bean.Student;</span><br><span class="line">import com.demo.ioc.Bean.Teacher;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) throws Exception&#123;</span><br><span class="line">        FileSystemXmlApplicationContext context &#x3D; new FileSystemXmlApplicationContext(&quot;src&#x2F;main&#x2F;resources&#x2F;bean1.xml&quot;);</span><br><span class="line">        Student student &#x3D; (Student) context.getBean(&quot;student&quot;);</span><br><span class="line">        Teacher teacher &#x3D; (Teacher) context.getBean(&quot;teacher&quot;);</span><br><span class="line">        System.out.println(&quot;学生的姓名：&quot;+student.getName()+&quot;。老师是&quot;+student.getTeacher().getName());</span><br><span class="line">        System.out.println(&quot;老师的姓名：&quot;+teacher.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于注解的bean定义（不需要提供setter方法）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component(&quot;student&quot;)</span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">@Value(&quot;张三&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Resource</span><br><span class="line">private Teacher teacher;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;public void setName(String name) &#123;</span><br><span class="line">&#x2F;&#x2F;this.name &#x3D; name;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">public Teacher getTeacher() &#123;</span><br><span class="line">return teacher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;public void setTeacher(Teacher teacher) &#123;</span><br><span class="line">&#x2F;&#x2F;this.teacher &#x3D; teacher;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component(&quot;teacher&quot;)</span><br><span class="line">public class Teacher &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;李四&quot;)</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;public void setName(String name) &#123;</span><br><span class="line">&#x2F;&#x2F;this.name &#x3D; name;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">       http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!--扫描组件的包目录--&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.demo.ioc.Bean&quot;&#x2F;&gt;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import com.demo.ioc.Bean.Student;</span><br><span class="line">import com.demo.ioc.Bean.Teacher;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) throws Exception&#123;</span><br><span class="line">        FileSystemXmlApplicationContext context &#x3D; new FileSystemXmlApplicationContext(&quot;src&#x2F;main&#x2F;resources&#x2F;bean2.xml&quot;);</span><br><span class="line">        Student student &#x3D; (Student) context.getBean(&quot;student&quot;);</span><br><span class="line">        Teacher teacher &#x3D; (Teacher) context.getBean(&quot;teacher&quot;);</span><br><span class="line">        System.out.println(&quot;学生的姓名：&quot;+student.getName()+&quot;。老师是&quot;+student.getTeacher().getName());</span><br><span class="line">        System.out.println(&quot;老师的姓名：&quot;+teacher.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于JavaConfig定义（需要提供setter方法）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class BeansConfiguration &#123;</span><br><span class="line"> </span><br><span class="line">    @Bean</span><br><span class="line">    public Student student()&#123;</span><br><span class="line">        Student student&#x3D;new Student();</span><br><span class="line">        student.setName(&quot;张三&quot;);</span><br><span class="line">        student.setTeacher(teacher());</span><br><span class="line">        return student;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Bean</span><br><span class="line">    public Teacher teacher()&#123;</span><br><span class="line">        Teacher teacher&#x3D;new Teacher();</span><br><span class="line">        teacher.setName(&quot;李四&quot;);</span><br><span class="line">        return teacher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line">import com.demo.ioc.Bean.BeansConfiguration;</span><br><span class="line">import com.demo.ioc.Bean.Student;</span><br><span class="line">import com.demo.ioc.Bean.Teacher;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) throws Exception&#123;</span><br><span class="line">AnnotationConfigApplicationContext context &#x3D; new AnnotationConfigApplicationContext(BeansConfiguration.class);</span><br><span class="line">&#x2F;&#x2F;        FileSystemXmlApplicationContext context &#x3D; new FileSystemXmlApplicationContext(&quot;src&#x2F;main&#x2F;resources&#x2F;bean2.xml&quot;);</span><br><span class="line">        Student student &#x3D; (Student) context.getBean(&quot;student&quot;);</span><br><span class="line">        Teacher teacher &#x3D; (Teacher) context.getBean(&quot;teacher&quot;);</span><br><span class="line">        System.out.println(&quot;学生的姓名：&quot;+student.getName()+&quot;。老师是&quot;+student.getTeacher().getName());</span><br><span class="line">        System.out.println(&quot;老师的姓名：&quot;+teacher.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Spring如何标记首选的Bean"><a href="#Spring如何标记首选的Bean" class="headerlink" title="Spring如何标记首选的Bean"></a>Spring如何标记首选的Bean</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Primary</span><br><span class="line">public class Student &#123;</span><br><span class="line">&#x2F;&#x2F; todo...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="限定自动装配的Bean"><a href="#限定自动装配的Bean" class="headerlink" title="限定自动装配的Bean"></a>限定自动装配的Bean</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">   @Qualifier(&quot;student&quot;)</span><br><span class="line">   public void setName(String policyName) &#123;</span><br><span class="line">       this.policyName &#x3D; policyName;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="Spring-自动装配Bean的方法"><a href="#Spring-自动装配Bean的方法" class="headerlink" title="Spring 自动装配Bean的方法"></a>Spring 自动装配Bean的方法</h5><ul><li>no：默认值，表示没有自动装配，应使用显式 bean 引用进行装配。</li><li>byName：它根据 bean 的名称注入对象依赖项。</li><li>byType：它根据类型注入对象依赖项。</li><li>构造函数：通过构造函数来注入依赖项，需要设置大量的参数。</li><li>autodetect：容器首先通过构造函数使用 autowire 装配，如果不能，则通过 byType 自动装配。</li></ul><h5 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h5><ul><li>BeanFactory：是Spring里面最底层的接口，包含了各种Bean的定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。ApplicationContext接口作为BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：<ul><li>继承MessageSource，因此支持国际化。</li><li>统一的资源文件访问方式。</li><li>提供在监听器中注册bean的事件。</li><li>同时加载多个配置文件。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul></li><li>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，我们就不能发现一些存在的Spring的配置问题。如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常。</li><li>BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。</li><li>BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</li></ul><h5 id="Autowire如何实现注入Bean"><a href="#Autowire如何实现注入Bean" class="headerlink" title="@Autowire如何实现注入Bean"></a>@Autowire如何实现注入Bean</h5><ul><li>这是@Autowire注解的定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Autowired &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Declares whether the annotated dependency is required.</span><br><span class="line"> * &lt;p&gt;Defaults to &#123;@code true&#125;.</span><br><span class="line"> *&#x2F;</span><br><span class="line">boolean required() default true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Java中注解的实现方式是通过反射来实现，反射的大概步骤如下：</p><ul><li>利用反射机制获取一个类的Class对象</li><li>通过这个class对象可以去获取他的每一个方法method，或字段Field等等</li><li>Method，Field等类提供了类似于getAnnotation的方法来获取这个一个字段的所有注解</li><li>拿到注解之后，我们可以判断这个注解是否是我们要实现的注解，如果是则实现注解逻辑</li></ul></li><li><p>所有的实现逻辑都在<code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code>，核心代码如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">private InjectionMetadata buildAutowiringMetadata(final Class&lt;?&gt; clazz) &#123;</span><br><span class="line">List&lt;InjectionMetadata.InjectedElement&gt; elements &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F; 需要处理的目标类</span><br><span class="line">Class&lt;?&gt; targetClass &#x3D; clazz;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">final List&lt;InjectionMetadata.InjectedElement&gt; currElements &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F; 通过反射获取所有字段，通过findAutowiredAnnotation查找每个字段的注解，如果用autowired修饰则返回autowired相关属性</span><br><span class="line">ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="line">AnnotationAttributes ann &#x3D; findAutowiredAnnotation(field);</span><br><span class="line">if (ann !&#x3D; null) &#123;</span><br><span class="line">&#x2F;&#x2F; 是否用在了static字段上</span><br><span class="line">if (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">if (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(&quot;Autowired annotation is not supported on static fields: &quot; + field);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; required属性是否赋值，默认true</span><br><span class="line">boolean required &#x3D; determineRequiredStatus(ann);</span><br><span class="line">currElements.add(new AutowiredFieldElement(field, required));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 同理通过反射获取所有方法并处理被autowired修饰的方法</span><br><span class="line">ReflectionUtils.doWithLocalMethods(targetClass, method -&gt; &#123;</span><br><span class="line">Method bridgedMethod &#x3D; BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes ann &#x3D; findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">if (ann !&#x3D; null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">&#x2F;&#x2F; 是否用在static方法上</span><br><span class="line">if (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">if (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(&quot;Autowired annotation is not supported on static methods: &quot; + method);</span><br><span class="line">&#125;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (method.getParameterCount() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">if (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(&quot;Autowired annotation should only be used on methods with parameters: &quot; +</span><br><span class="line">method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">boolean required &#x3D; determineRequiredStatus(ann);</span><br><span class="line">PropertyDescriptor pd &#x3D; BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">currElements.add(new AutowiredMethodElement(method, required, pd));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 用@Autowired修饰的注解可能不止一个，因此都加在currElements这个容器里面，一起处理</span><br><span class="line">elements.addAll(0, currElements);</span><br><span class="line">targetClass &#x3D; targetClass.getSuperclass();</span><br><span class="line">&#125;</span><br><span class="line">while (targetClass !&#x3D; null &amp;&amp; targetClass !&#x3D; Object.class);</span><br><span class="line">&#x2F;&#x2F; 返回所有包含autowire注解修饰的一个InjectionMetadata集合</span><br><span class="line">return new InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码就获取到了所有被autowire注解修饰的目标类和所有elements集合。<br>有了目标类，与所有需要注入的元素集合之后，我们就可以实现autowired的依赖注入逻辑了，实现的方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public PropertyValues postProcessPropertyValues(</span><br><span class="line">PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException &#123;</span><br><span class="line">&#x2F;&#x2F; 这里是之前找到的目标类和所有elements集合组成的metadata</span><br><span class="line">InjectionMetadata metadata &#x3D; findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; 然后调用metadata的inject方法</span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line">&#125;</span><br><span class="line">catch (BeanCreationException ex) &#123;</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">return pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inject也使用了反射技术并且依然是分成字段和方法去处理的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">protected void inject(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)</span><br><span class="line">throws Throwable &#123;</span><br><span class="line">&#x2F;&#x2F; 如果autowired修饰的是属性，则赋值</span><br><span class="line">if (this.isField) &#123;</span><br><span class="line">Field field &#x3D; (Field) this.member;</span><br><span class="line">ReflectionUtils.makeAccessible(field);</span><br><span class="line">field.set(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (checkPropertySkipping(pvs)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 否则autowired修饰在方法上，则调用method.invoke</span><br><span class="line">try &#123;</span><br><span class="line">Method method &#x3D; (Method) this.member;</span><br><span class="line">ReflectionUtils.makeAccessible(method);</span><br><span class="line">method.invoke(target, getResourceToInject(target, requestingBeanName));</span><br><span class="line">&#125;</span><br><span class="line">catch (InvocationTargetException ex) &#123;</span><br><span class="line">throw ex.getTargetException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是@Autowired注解实现的所有逻辑。</p><h5 id="Spring中的循环依赖问题"><a href="#Spring中的循环依赖问题" class="headerlink" title="Spring中的循环依赖问题"></a>Spring中的循环依赖问题</h5><ul><li><p>构造器的循环依赖 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;testA&quot; class&#x3D;&quot;com.bean.TestA&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;testB&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;testB&quot; class&#x3D;&quot;com.bean.TestB&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;testC&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;testC&quot; class&#x3D;&quot;com.bean.TestC&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;testA&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><ul><li>解决方法：spring无法解决这种问题，为何？只能抛出BeanCurrentlyInCreationException异常来终止该依赖。 </li><li>具体的处理步骤如下： </li></ul></li></ul><pre><code>1. Spring将每个正在创建的bean的标识符放在一个池子里 2. 如果bean在创建的时候发现自己已经存在于这个池子里 3. 则抛出异常，中断循环依赖。</code></pre><ul><li><p>属性的循环依赖， setter循环依赖</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;testA&quot; class&#x3D;&quot;com.bean.TestA&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;testB&quot; ref&#x3D;&quot;testB&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;testB&quot; class&#x3D;&quot;com.bean.TestB&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;testC&quot; ref&#x3D;&quot;testC&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;testC&quot; class&#x3D;&quot;com.bean.TestC&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;testA&quot; ref&#x3D;&quot;testA&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure><ul><li>解决方法：</li></ul><ol><li>spring将已经完成了构造注入但是未完成setter注入的bean暴露出来 </li><li>当进行setter注入时，发现这个需被注入的bean已经被暴露出来（存在该bean的引用），直接注入即可，而不需要再次加载所需的bean(无需再经历从头开始加载一个bean的过程，也就不会报错了)。</li></ol></li></ul><h5 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h5><ul><li><p>Spring AOP是Spring框架中的重中之重，是基于JDK动态代理和CGLib动态代理实现的，至于动态代理的知识点可以参考我的这篇<a href="https://blog.csdn.net/wangchengming1/article/details/104357744" target="_blank" rel="noopener">文章</a>，Spring AOP默认采用JDK动态代理实现机制。</p></li><li><p>AOP利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。</p></li><li><p>通俗来讲，在我们的应用中，诸如常见的日志、安全、异常处理和事物等逻辑都很重要，在不适用AOP的过去，我们需要将共同部分的这段代码写在一个独立的类独立的方法里，然后再去调用。但是有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。</p></li><li><p>AOP的基本概念</p><ul><li>通知（Advice）<br>通知定义了切面是什么以及什么时候使用。Spring切面可以应用五种类型的通知：<ul><li>前置通知（Before）： 在目标方法被调用之前通知功能。</li><li>后置通知（After）：在目标方法被调用之后通知功能。</li><li>返回通知（After-returning）：在目标方法执行成功之后调用通知。</li><li>异常通知（After-throwing）：在目标方法抛出异常之后调用通知。</li><li>环绕通知（Around）：通知包含了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</li></ul></li><li>连接点（Join Point）：在应用中执行过程中能够插入切面的一个点。</li><li>切点（Pointcut）：切点定义了匹配通知在何处织入。</li><li>切面（Aspect）：切面是通知和切点的集合。通知和切点共同定义了切面的全部内容–它是什么、在何时在何处完成功能</li></ul></li><li><p>AOP切点表达式</p></li></ul><table><thead><tr><th>AspectJ指示器</th><th>描述</th></tr></thead><tbody><tr><td>arg()</td><td>限制连接点匹配参数由指定类型的执行方法</td></tr><tr><td>@arg()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>execution()</td><td>用于匹配是连接点的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象</td></tr><tr><td>within()</td><td>限制连接点匹配指定的类型</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标注的类型</td></tr><tr><td>@annotation</td><td>限制连接点匹配有指定注解的连接点</td></tr></tbody></table><ul><li>AOP使用场景<ul><li>Authentication 权限</li><li>Caching 缓存</li><li>Context passing 内容传递</li><li>Error handling 错误处理</li><li>Lazy loading　懒加载</li><li>Debugging　　调试</li><li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</li><li>Performance optimization　性能优化</li><li>Persistence　　持久化</li><li>Resource pooling　资源池</li><li>Synchronization　同步</li><li>Transactions 事务</li></ul></li></ul><h5 id="Spring事物"><a href="#Spring事物" class="headerlink" title="Spring事物"></a>Spring事物</h5><p>事务主要有四个特性，我们根据它的英文大写字母简写成：ACID</p><ul><li>原子性（Atomicity）</li></ul><p>事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。所以你可以把一个事务看成一个原子操作。</p><ul><li>一致性（Consistency）</li></ul><p>一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。比如在银行转账的例子中，无论转账成功与否，都需要保证银行的总存款是不变的，这才符合业务的“一致”状态。</p><ul><li>隔离性（Isolation）</li></ul><p>可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。这里涉及到事务的几种隔离级别，将在下文详细介绍。比如多个人都像B转账，他们之间的事务互相不能影响。</p><ul><li>持久性（Durability）</li></ul><p>一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器（如数据库）中。</p><ul><li>事物的隔离级别<ul><li>Isolation.DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li>Isolation.READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li><li>Isolation.READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li><li>Isolation.REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li><li>Isolation.SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li><li>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</li><li>不可重复读 ：是指在一个事务内，多次读同一数据。</li><li>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</li></ul></li></ul><h5 id="Spring事务的传播属性"><a href="#Spring事务的传播属性" class="headerlink" title="Spring事务的传播属性"></a>Spring事务的传播属性</h5><p>在Spring的事务机制中对数据库存在7种传播行为，通过枚举类Propagation定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public enum Propagation &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 需要事务，默认传播性行为。</span><br><span class="line">     * 如果当前存在事务，就沿用当前事务，否则新建一个事务运行子方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    REQUIRED(0),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 支持事务，如果当前存在事务，就沿用当前事务，</span><br><span class="line">     * 如果不存在，则继续采用无事务的方式运行子方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SUPPORTS(1),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 必须使用事务，如果当前没有事务，抛出异常</span><br><span class="line">     * 如果存在当前事务,就沿用当前事务</span><br><span class="line">     *&#x2F;</span><br><span class="line">    MANDATORY(2),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 无论当前事务是否存在，都会创建新事务允许方法</span><br><span class="line">     * 这样新事务就可以拥有新的锁和隔离级别等特性，与当前事务相互独立</span><br><span class="line">     *&#x2F;</span><br><span class="line">    REQUIRES_NEW(3),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 不支持事务，当前存在事务时，将挂起事务，运行方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NOT_SUPPORTED(4),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 不支持事务，如果当前方法存在事务，将抛出异常，否则继续使用无事务机制运行</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NEVER(5),</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 在当前方法调用子方法时，如果子方法发生异常</span><br><span class="line">     * 只回滚子方法执行过的SQL，而不回滚当前方法的事务</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NESTED(6);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常开发中基本只会使用到REQUIRED(0),REQUIRES_NEW(3),NESTED(6)三种。</p><h5 id="Spring-MVC有哪些组件"><a href="#Spring-MVC有哪些组件" class="headerlink" title="Spring MVC有哪些组件"></a>Spring MVC有哪些组件</h5><ul><li>前置控制器 DispatcherServlet。</li><li>映射控制器 HandlerMapping。</li><li>处理器 Controller。</li><li>模型和视图 ModelAndView。</li><li>视图解析器 ViewResolver。</li></ul><h5 id="Spring-MVC的运行流程"><a href="#Spring-MVC的运行流程" class="headerlink" title="Spring MVC的运行流程"></a>Spring MVC的运行流程</h5><ul><li>先将请求发送给 DispatcherServlet。</li><li>DispatcherServlet 查询一个或多个 HandlerMapping，找到处理请求的 Controller。</li><li>DispatcherServlet 再把请求提交到对应的 Controller。</li><li>Controller 进行业务逻辑处理后，会返回一个ModelAndView。</li><li>Dispathcher 查询一个或多个 ViewResolver 视图解析器，找到 ModelAndView 对象指定的视图对象。</li><li>视图对象负责渲染返回给客户端。</li></ul><h5 id="Why-Spring-Boot"><a href="#Why-Spring-Boot" class="headerlink" title="Why Spring Boot"></a>Why Spring Boot</h5><ul><li>自动配置</li><li>上手简单，简化配置，使程序人员注重在业务开发上，节省配置的时间，提升开发效率</li><li>Spring Boot Stater提供了开箱即用的整合，配合Maven或者Gradle构建项目</li><li>内嵌式Servlet容器（spring-boot-starter-web），默认是tomcat。如果想使用jetty，则需要从spring-boot-starter-web中将spring-bootstarter-tomcat排除，只留有spring-boot-starter-jetty</li><li>无代码生成和 xml 配置</li></ul><h5 id="Spring-Boot的核心配置文件"><a href="#Spring-Boot的核心配置文件" class="headerlink" title="Spring Boot的核心配置文件"></a>Spring Boot的核心配置文件</h5><p>Spring Boot 核心的两个配置文件：</p><ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)：用于 spring boot 项目的自动化配置。</li></ul><h5 id="Spring-Boot是如何实现自动配置的"><a href="#Spring-Boot是如何实现自动配置的" class="headerlink" title="Spring Boot是如何实现自动配置的"></a>Spring Boot是如何实现自动配置的</h5><p>众所周知，Spring Boot程序中启动类上有一个<code>@SpringBootApplication</code>注解，包含了@SpringBootConfiguration（打开是@Configuration），@EnableAutoConfiguration，@ComponentScan注解。点进去看到如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters &#x3D; &#123;</span><br><span class="line">@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; TypeExcludeFilter.class),</span><br><span class="line">@Filter(type &#x3D; FilterType.CUSTOM, classes &#x3D; AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Exclude specific auto-configuration classes such that they will never be applied.</span><br><span class="line"> * @return the classes to exclude</span><br><span class="line"> *&#x2F;</span><br><span class="line">@AliasFor(annotation &#x3D; EnableAutoConfiguration.class)</span><br><span class="line">Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Exclude specific auto-configuration class names such that they will never be</span><br><span class="line"> * applied.</span><br><span class="line"> * @return the class names to exclude</span><br><span class="line"> * @since 1.3.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@AliasFor(annotation &#x3D; EnableAutoConfiguration.class)</span><br><span class="line">String[] excludeName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Base packages to scan for annotated components. Use &#123;@link #scanBasePackageClasses&#125;</span><br><span class="line"> * for a type-safe alternative to String-based package names.</span><br><span class="line"> * @return base packages to scan</span><br><span class="line"> * @since 1.3.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@AliasFor(annotation &#x3D; ComponentScan.class, attribute &#x3D; &quot;basePackages&quot;)</span><br><span class="line">String[] scanBasePackages() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Type-safe alternative to &#123;@link #scanBasePackages&#125; for specifying the packages to</span><br><span class="line"> * scan for annotated components. The package of each class specified will be scanned.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * Consider creating a special no-op marker class or interface in each package that</span><br><span class="line"> * serves no purpose other than being referenced by this attribute.</span><br><span class="line"> * @return base packages to scan</span><br><span class="line"> * @since 1.3.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@AliasFor(annotation &#x3D; ComponentScan.class, attribute &#x3D; &quot;basePackageClasses&quot;)</span><br><span class="line">Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@SpringBootConfiguration，这里的启动类标注了@Configuration之后，本身其实也是一个IoC容器的配置类。</li><li>@ComponentScan，@ComponentScan的功能其实就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。</li><li>可以看到有一个注解<code>@EnableAutoConfiguration</code>，这个注解就是开启了自动配置，借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，在点进去看看</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(AutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY &#x3D; &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Exclude specific auto-configuration classes such that they will never be applied.</span><br><span class="line"> * @return the classes to exclude</span><br><span class="line"> *&#x2F;</span><br><span class="line">Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Exclude specific auto-configuration class names such that they will never be</span><br><span class="line"> * applied.</span><br><span class="line"> * @return the class names to exclude</span><br><span class="line"> * @since 1.3.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">String[] excludeName() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面最关键的是@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。接下来我们看一下AutoConfigurationImportSelector，核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">if (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">return NO_IMPORTS;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 获取元数据</span><br><span class="line">AutoConfigurationMetadata autoConfigurationMetadata &#x3D; AutoConfigurationMetadataLoader</span><br><span class="line">.loadMetadata(this.beanClassLoader);</span><br><span class="line">AnnotationAttributes attributes &#x3D; getAttributes(annotationMetadata);</span><br><span class="line">&#x2F;&#x2F; 扫描具有META-INF&#x2F;spring.factories文件的jar包</span><br><span class="line">List&lt;String&gt; configurations &#x3D; getCandidateConfigurations(annotationMetadata,</span><br><span class="line">attributes);</span><br><span class="line">&#x2F;&#x2F; 去重</span><br><span class="line">configurations &#x3D; removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions &#x3D; getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations &#x3D; filter(configurations, autoConfigurationMetadata);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">return StringUtils.toStringArray(configurations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,</span><br><span class="line">AnnotationAttributes attributes) &#123;</span><br><span class="line">&#x2F;&#x2F; 加载spring.factories</span><br><span class="line">List&lt;String&gt; configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations,</span><br><span class="line">&quot;No auto configuration classes found in META-INF&#x2F;spring.factories. If you &quot;</span><br><span class="line">+ &quot;are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 扫描具有MEAT-INF&#x2F;spring.factories文件的jar包，得到所有的配置类</span><br><span class="line">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;</span><br><span class="line">&#x2F;&#x2F; 自动配置器会跟根据传入的factoryClass.getName()到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。</span><br><span class="line">       String factoryClassName &#x3D; factoryClass.getName();</span><br><span class="line">       return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">   &#125;</span><br><span class="line">&#x2F;&#x2F; 调用loadSpringFactories</span><br><span class="line">   private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">       MultiValueMap&lt;String, String&gt; result &#x3D; (MultiValueMap)cache.get(classLoader);</span><br><span class="line">       if (result !&#x3D; null) &#123;</span><br><span class="line">           return result;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               Enumeration&lt;URL&gt; urls &#x3D; classLoader !&#x3D; null ? classLoader.getResources(&quot;META-INF&#x2F;spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF&#x2F;spring.factories&quot;);</span><br><span class="line">               LinkedMultiValueMap result &#x3D; new LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">               while(urls.hasMoreElements()) &#123;</span><br><span class="line">                   URL url &#x3D; (URL)urls.nextElement();</span><br><span class="line">                   UrlResource resource &#x3D; new UrlResource(url);</span><br><span class="line">                   Properties properties &#x3D; PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                   Iterator var6 &#x3D; properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                   while(var6.hasNext()) &#123;</span><br><span class="line">                       Entry&lt;?, ?&gt; entry &#x3D; (Entry)var6.next();</span><br><span class="line">                       List&lt;String&gt; factoryClassNames &#x3D; Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue()));</span><br><span class="line">                       result.addAll((String)entry.getKey(), factoryClassNames);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               cache.put(classLoader, result);</span><br><span class="line">               return result;</span><br><span class="line">           &#125; catch (IOException var9) &#123;</span><br><span class="line">               throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF&#x2F;spring.factories]&quot;, var9);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>至此实现了自动配置。</p><h5 id="Spring-Boot是如何启动的"><a href="#Spring-Boot是如何启动的" class="headerlink" title="Spring Boot是如何启动的"></a>Spring Boot是如何启动的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">StopWatch stopWatch &#x3D; new StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context &#x3D; null;</span><br><span class="line">Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line">&#x2F;&#x2F; 通过SpringFactoriesLoader查找并加载所有的 SpringApplicationRunListeners，通过调用starting()方法通知所有的SpringApplicationRunListeners：应用开始启动了</span><br><span class="line">SpringApplicationRunListeners listeners &#x3D; getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line">try &#123;</span><br><span class="line">ApplicationArguments applicationArguments &#x3D; new DefaultApplicationArguments(</span><br><span class="line">args);</span><br><span class="line">&#x2F;&#x2F; 创建并配置当前应用将要使用的 Environment</span><br><span class="line">ConfigurableEnvironment environment &#x3D; prepareEnvironment(listeners,</span><br><span class="line">applicationArguments);</span><br><span class="line">configureIgnoreBeanInfo(environment);</span><br><span class="line">&#x2F;&#x2F; SpringBoot应用在启动时会输出一个大大的banner</span><br><span class="line">Banner printedBanner &#x3D; printBanner(environment);</span><br><span class="line">&#x2F;&#x2F; 创建不同的ApplicationContext容器</span><br><span class="line">context &#x3D; createApplicationContext();</span><br><span class="line">exceptionReporters &#x3D; getSpringFactoriesInstances(</span><br><span class="line">SpringBootExceptionReporter.class,</span><br><span class="line">new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">&#x2F;&#x2F; 初始化ApplicationContext</span><br><span class="line">prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">printedBanner);</span><br><span class="line">&#x2F;&#x2F; 调用ApplicationContext的refresh()方法</span><br><span class="line">refreshContext(context);</span><br><span class="line">&#x2F;&#x2F; 空方法</span><br><span class="line">afterRefresh(context, applicationArguments);</span><br><span class="line">stopWatch.stop();</span><br><span class="line">if (this.logStartupInfo) &#123;</span><br><span class="line">new StartupInfoLogger(this.mainApplicationClass)</span><br><span class="line">.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 由 SpringApplicationRunListener 来发出 started 消息，完成最终的程序启动</span><br><span class="line">listeners.started(context);</span><br><span class="line">&#x2F;&#x2F; 查找当前context中是否注册有CommandLineRunner和ApplicationRunner，如果有则遍历执行它们</span><br><span class="line">callRunners(context, applicationArguments);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; 由 SpringApplicationRunListener 来发出 running 消息，告知程序已运行起来了</span><br><span class="line">listeners.running(context);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">handleRunFailure(context, ex, exceptionReporters, null);</span><br><span class="line">throw new IllegalStateException(ex);</span><br><span class="line">&#125;</span><br><span class="line">return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringApplicationRunListener的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class SpringApplicationRunListeners &#123;</span><br><span class="line"></span><br><span class="line">private final Log log;</span><br><span class="line"></span><br><span class="line">private final List&lt;SpringApplicationRunListener&gt; listeners;</span><br><span class="line"></span><br><span class="line">SpringApplicationRunListeners(Log log,</span><br><span class="line">Collection&lt;? extends SpringApplicationRunListener&gt; listeners) &#123;</span><br><span class="line">this.log &#x3D; log;</span><br><span class="line">this.listeners &#x3D; new ArrayList&lt;&gt;(listeners);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void starting() &#123;</span><br><span class="line">for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">listener.starting();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">listener.environmentPrepared(environment);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">listener.contextPrepared(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">listener.contextLoaded(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line">for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">listener.started(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">listener.running(context);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">for (SpringApplicationRunListener listener : this.listeners) &#123;</span><br><span class="line">callFailedListener(listener, context, exception);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void callFailedListener(SpringApplicationRunListener listener,</span><br><span class="line">ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">listener.failed(context, exception);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">if (exception &#x3D;&#x3D; null) &#123;</span><br><span class="line">ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">&#125;</span><br><span class="line">if (this.log.isDebugEnabled()) &#123;</span><br><span class="line">this.log.error(&quot;Error handling failed&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">String message &#x3D; ex.getMessage();</span><br><span class="line">message &#x3D; (message !&#x3D; null) ? message : &quot;no error message&quot;;</span><br><span class="line">this.log.warn(&quot;Error handling failed (&quot; + message + &quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Spring-Boot定义不同的环境配置"><a href="#Spring-Boot定义不同的环境配置" class="headerlink" title="Spring Boot定义不同的环境配置"></a>Spring Boot定义不同的环境配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">applcation.yml</span><br><span class="line"></span><br><span class="line">application-dev.yml</span><br><span class="line"> </span><br><span class="line">application-test.yml</span><br><span class="line"> </span><br><span class="line">application-prod.yml</span><br></pre></td></tr></table></figure><p>通过<code>@Profile(&quot;dev&quot;)</code>来切换不同的环境配置</p><h5 id="Spring-Boot如何实现跨域"><a href="#Spring-Boot如何实现跨域" class="headerlink" title="Spring Boot如何实现跨域"></a>Spring Boot如何实现跨域</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class CorsConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">    &#x2F;&#x2F; 设置允许跨域的路径</span><br><span class="line">    registry.addMapping(&quot;&#x2F;**&quot;)</span><br><span class="line">        &#x2F;&#x2F; 设置允许跨域请求的域名</span><br><span class="line">        .allowedOrigins(&quot;*&quot;)</span><br><span class="line">        &#x2F;&#x2F; 是否允许证书 不再默认开启</span><br><span class="line">        .allowCredentials(true)</span><br><span class="line">        &#x2F;&#x2F; 设置允许的方法</span><br><span class="line">        .allowedMethods(&quot;*&quot;)</span><br><span class="line">        &#x2F;&#x2F; 跨域允许时间</span><br><span class="line">        .maxAge(3600);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Spring-Boot实现多数据源配置"><a href="#Spring-Boot实现多数据源配置" class="headerlink" title="Spring Boot实现多数据源配置"></a>Spring Boot实现多数据源配置</h5><p><a href="https://www.jianshu.com/p/34730e595a8c" target="_blank" rel="noopener">请参考这篇文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring/Spring Boot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring/Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud - 链路追踪（Zipkin）</title>
      <link href="/2020/04/17/Spring-Cloud-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%EF%BC%88Zipkin%EF%BC%89/"/>
      <url>/2020/04/17/Spring-Cloud-%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%EF%BC%88Zipkin%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>传统分布式项目有一个痛点，就是如果API比较多，彼此之间的调用关系复杂，遇到了问题很难定位。解决方案是在项目的README或Confluence等文档工具中附上该API与其它API的交互关系、架构图等，然后给每个业务请求生成一个ID，然后整条调用线都会记录下这个id，每个API在打印自己的日志的时候都把这个ID打下来。</p><a id="more"></a><p>传统分布式项目有一个痛点，就是如果API比较多，彼此之间的调用关系复杂，遇到了问题很难定位。解决方案是在项目的README或Confluence等文档工具中附上该API与其它API的交互关系、架构图等，然后给每个业务请求生成一个ID，然后整条调用线都会记录下这个id，每个API在打印自己的日志的时候都把这个ID打下来。</p><p>这样做非常复杂，你需要在开发每个微服务的时候都要去创建相应的接口和类去处理这个ID，去记录日志。</p><h5 id="什么是链路追踪？"><a href="#什么是链路追踪？" class="headerlink" title="什么是链路追踪？"></a>什么是链路追踪？</h5><p>而在微服务架构中，这个问题已经有了现成的解决方案，那就是“链路追踪”。链路追踪会收集微服务与微服务之间的调用日志，把它们统计起来，形成一个调用关系图。除了调用关系图以外，它还可以统计请求的比例，请求耗时等等。也就是说，它还可以<code>分析微服务系统在大压力下的可用性和性能</code>。</p><p>Google开源了Dapper链路追踪组件，并在2010年发表了论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》，这篇文章是业内实现链路追踪的标杆和理论基础，具有非常大的参考价值。</p><p>目前，链路追踪组件有Google的Dapper，Twitter 的Zipkin，以及阿里的Eagleeye （鹰眼）等，它们都是非常优秀的链路追踪开源组件。</p><p>Spring Cloud提供了<code>Spring Cloud Sleuth</code>这个组件来支持链路追踪的功能。它可以非常方便地与Zipkin集成。本文主要以<code>Zipkin</code>为例来介绍链路追踪。</p><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>SpringBoot对Zipkin的自动配置可以使得所有RequestMapping匹配到的endpoints得到监控，以及强化了RestTemplate，对其加了一层拦截器，使得由它发起的HTTP请求也同样被监控。</p><p>其实查看源码可以发现，Spring Cloud Sleuth可以支持很多种类型的请求，并对每种请求类型分别做了处理。比如Messaging，Hystrix，Feign，Async等等。详细原理可以参考这篇文章：<a href="https://blog.csdn.net/xichenguan/article/details/77448288" target="_blank" rel="noopener">《Spring Cloud Sleuth消息追踪原理》</a>。<br>Spring Cloud Sleuth中有这样几个概念：</p><ul><li>Span：一个工作单元，请求到了每个微服务，都会有不同的span。span里面有一个64位的- SpanId，还记录了时间戳等信息。</li><li>Trace：一系列spans组成的一个树状结构。每个Trace有一个TraceID，在一个业务的调用链路中，它是不变的。</li><li>Annotation：记录一个事件。事件有四种：<ul><li>cs - Client Sent：客户端发起一个请求，描述这个span的开始；</li><li>sr - Server Received：服务端获得请求并准备开始处理它；</li><li>ss - Server Sent：请求处理的完成(当请求返回客户端)；</li><li>cr - Client Received:表明Span的结束，客户端成功接收到服务端的回复。</li></ul></li></ul><p>其中每个Annotation都会记录下自己的时间戳。所以我们可以得到：</p><ul><li>sr - cs = 网络延迟</li><li>ss - sr = 处理时间</li><li>cr - cs = 请求总耗时</li></ul><p>这里有一张来自官方文档的原理图：</p><p><img src="https://img-blog.csdnimg.cn/2019070514430421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>以及介绍ParentId的图：</p><p><img src="https://img-blog.csdnimg.cn/20190705144321383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h5><ul><li>下载<a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/" target="_blank" rel="noopener">Zipkin</a>，之后启动，启动的命令：</li></ul><blockquote><p>java -jar zipkin-server-2.9.4-exec.jar</p></blockquote><p>启动好的样子如下</p><p><img src="https://img-blog.csdnimg.cn/201907051612077.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>之后在浏览器输入<code>localhost:9411</code>，大概就是这个样子的</p><p><img src="https://img-blog.csdnimg.cn/20190705161240792.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>创建一个项目，因为之前有<a href="https://github.com/BazookaW/springcloud-sample/tree/master/Feign-sample" target="_blank" rel="noopener">Feign</a>的例子，所以我这里只是简单的改动一下。</li></ul><p>在<code>service-client</code>，<code>service-feign</code>指定zipkin server的地址，通过配置<code>spring.zipkin.base-url</code>指定，在<code>application.yml</code>里加，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">    client:</span><br><span class="line">        serviceUrl:</span><br><span class="line">            defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">    port: 8765</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-feign</span><br><span class="line">    zipkin:</span><br><span class="line">        base-url&#x3D;http:&#x2F;&#x2F;localhost:9411</span><br></pre></td></tr></table></figure><p>然后分别启动<code>eureka-server</code>，<code>service-client</code>，<code>service-feign</code>，在浏览器输入<code>http://localhost:8765/sayHello?name=Beck Wang</code></p><ul><li>查看效果</li></ul><p>在依赖分析这里可以看到依赖关系</p><p><img src="https://img-blog.csdnimg.cn/201907051619354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>当然如果微服务多的话，效果会更好，可以看到微服务之间的调用，用时之类的信息。</p><p><a href="https://github.com/BazookaW/springcloud-sample/tree/master/Zipkin-sample-feign" target="_blank" rel="noopener">源码-feign</a></p><p><a href="https://github.com/BazookaW/springcloud-sample/tree/master/Zipkin-sample" target="_blank" rel="noopener">源码</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud - 熔断（Hystrix）</title>
      <link href="/2020/04/17/Spring-Cloud-%E7%86%94%E6%96%AD%EF%BC%88Hystrix%EF%BC%89/"/>
      <url>/2020/04/17/Spring-Cloud-%E7%86%94%E6%96%AD%EF%BC%88Hystrix%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要讲解一下熔断的实现机制。</p><a id="more"></a><h5 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h5><p>小铭同学最近正在学Spring Cloud，最近学到熔断这块的知识点，不是很理解，于是请教了公司的大佬老王。</p><p>小铭趁空闲时间找到老王：“王哥，我最近在学习Spring Cloud，看到所有书上都说熔断是微服务必须的，可我不用熔断，系统好像也能正常工作。那为什么说它是必须的呢？”</p><p>“正常工作是没问题，那发生异常了呢？某个服务挂了或者网络不通的时候会发生什么？”老王反问小铭。</p><p>“让我思考一下，如果一个微服务不可用了，那调用它的微服务这个服务就会抛异常，一直到最上层。可这跟熔断又有什么关系？”小铭心中还是有一些疑惑。</p><p>老王笑了笑，解释道：“可不只是抛异常怎么简单。在Java中，每一个HTTP请求都会开启一个新线程。而下游服务挂了或者网络不可达，通常线程会阻塞住，直到Timeout。你想想看，如果并发量多一点，这些阻塞的线程就会占用大量的资源，很有可能把自己本身这个微服务所在的机器资源耗尽，导致自己也挂掉。”</p><p>小铭有些明白了，追问道：“那是不是最终所有上游微服务都有可能挂掉？”</p><p>“是的，这也是称为<code>‘雪崩效应’</code>。最开始是一个微服务挂掉了。随着时间地推移，可能会导致整个系统都不可用。”老王一边回答，一边快速地在电脑上搜出了下面这个图：<br><img src="https://img-blog.csdnimg.cn/2019062114272964.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>“那熔断具体是怎么解决这个问题的？”小铭点点头，然后继续追问。</p><p>老王见小铭似乎有些明悟，但知识点还没有串联起来，便一步一步地引导他：“那你知道Spring Cloud断路器的三种状态吗？”</p><p>似乎终于到了小铭自己比较熟悉的知识点，自信地说到：“这个我知道，Spring Cloud一般使用Hystrix来做断路器。就跟电路上的闸差不多。它有三种状态：<code>关闭，开启和半开</code>。最开始是关闭状态的，这个时候所有请求都可以通过；如果错误请求达到一定的<code>阈值</code>，就会变成开启状态，就会让所有请求短路，直接返回失败的响应；一段时间后，断路器会变成半开状态，如果下一个请求成功了，就关闭断路器，反之就开启断路器。”</p><p>“那这个阈值具体是什么？”</p><p>“这里主要就要用到三个属性了：”小铭快速答道</p><ol><li>hystrix.command.default.circuitBreaker.requestVolumeThreshold（当在配置时间窗口内达到此数量的失败后，进行短路。默认20个）简言之，10s内请求失败数量达到20个，断路器就会变成打开状态。</li><li>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds（短路多久以后开始尝试是否恢复，默认5s）</li><li>hystrix.command.default.circuitBreaker.errorThresholdPercentage（出错百分比阈值，当达到此阈值后，开始短路。默认50%）</li></ol><h5 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h5><p>“非常正确！你知道Hystrix的底层原理吗？”</p><p>于是小铭祭出了官方的图：<br><img src="https://img-blog.csdnimg.cn/20190621144810332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>“Hystrix主要使用的是RxJava来做异步请求，RxJava是一个异步框架，是对观察者模式的一个应用。Hystrix会把对每个微服务的请求放到线程池里面，具体分配到哪个线程池可以使用HystrixThreadPoolKey来指定”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(threadPoolKey &#x3D; &quot;user-hello&quot;)</span><br><span class="line">String getUserHello();</span><br></pre></td></tr></table></figure><p>老王继续问：“那你知道为什么要有这个key吗？它是用来干嘛的？”小铭摇了摇头，表示自己还不知道。</p><p>“你看源码就知道了，Hystrix使用了一个ConcurrentHashMap来保存线程池。”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap&lt;String, HystrixThreadPool&gt; threadPools</span><br></pre></td></tr></table></figure><p>小铭心中出现了一个新的问题：那为什么我们需要多个线程池呢？</p><p>此时老王继续说道：“这个其实叫资源隔离。应用程序会被完全保护起来，即使依赖的一个服务出问题了，也不会影响到应用程序的其他部分。使用多个线程池就是一种资源隔离方式，也是默认的隔离方式。而且Hystrix底层是使用的RxJava，使用线程池可以让你很方便地实现异步操作。”</p><p>“那除了线程池隔离，还有其它隔离方式吗？”</p><p>“有的，Hystrix提供了两种隔离方式：线程池隔离和信号量（Semaphore）隔离。”</p><p>“是的，线程池隔离就是上面说的那样。信号量主要起一个限流的作用。如果信号量耗尽了，它就直接走fallback流程所以也能防止雪崩。但大多数情况，我们更倾向于使用线程池。”</p><h5 id="fallback"><a href="#fallback" class="headerlink" title="fallback"></a>fallback</h5><p>“刚刚你提到了一个词叫‘fallback流程’？”</p><p>“是的，fallback翻译过来是<code>‘回退’</code>的意思，有时候我们也会称它<code>‘服务降级’</code>。”</p><p>“那什么时候会触发fallback呢？”</p><p>“其实你应该已经可以总结出来了，主要这五种情况会触发fallback：”</p><ul><li>执行超时</li><li>执行过程抛出异常</li><li>断路器打开状态</li><li>线程池拒绝（池满后的拒绝策略）</li><li>信号量拒绝（信号量耗完）</li></ul><p>“那触发fallback后会发生什么？”</p><p>老王熟练的打开源码，并快速敲下了一个Demo。“这个你得看HystrixCommand这个类的源码和使用方式。”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AuthCommand extends HystrixCommand&lt;Boolean&gt; &#123;</span><br><span class="line">  public Boolean run() &#123;</span><br><span class="line">    return authService.authenticate(user);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  protected Boolean getFallback() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“我们在使用Hystrix的时候，一般是继承<code>HystrixCommand</code>这个类，重写<code>run</code>和<code>getFallback</code>这两个方法。正常情况它是走run方法的。如果发生了fallback，它就会调用getFallback方法。”</p><p>小铭看着这段代码，问到：“这看起来有点麻烦，在Spring Cloud中，有更简单的使用方式吗？”</p><p>“当然。在Spring Cloud中，<code>Hystrix可以和OpenFeign无缝集成</code>。OpenFeign接口上的每个方法都会被Hystrix断路器包裹（这也是一种典型的AOP实现）。你可以在注解上配置fallback方法：”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@HystrixCommand(fallbackMethod &#x3D; &quot;getByIdFallback&quot;)</span><br><span class="line">public String getById(String id) &#123;...&#125;</span><br><span class="line"></span><br><span class="line">private String getByIdFallback(String id) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>感觉熔断这一块的知识点差不多理通了，小铭认真道谢，回到自己的位置继续撸代码……</p><h5 id="Feign中使用断路器"><a href="#Feign中使用断路器" class="headerlink" title="Feign中使用断路器"></a>Feign中使用断路器</h5><p>Feign是自带断路器的，在D版本的Spring Cloud之后，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feign:</span><br><span class="line">    hystrix:</span><br><span class="line">        enabled: true</span><br></pre></td></tr></table></figure><p>基于service-feign工程进行改造</p><ul><li>实现UserClient 接口，并注入到Ioc容器中，代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserClientHystrix implements UserClient &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String sayHello(String name) &#123;</span><br><span class="line">        return &quot;sorry &quot; + name + &quot; 上游服务断开, 服务降级&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String timeOut() throws InterruptedException &#123;</span><br><span class="line">        return &quot;链接超时，服务降级&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String exception() throws Exception &#123;</span><br><span class="line">        return &quot;发生异常，服务降级&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在FeignClient的UserClient接口的注解中加上fallback的指定类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;service-client&quot;, fallback &#x3D; UserClientHystrix.class)</span><br><span class="line">public interface UserClient &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;client&quot;)</span><br><span class="line">    String sayHello(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;timeOut&quot;)</span><br><span class="line">    String timeOut() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;exception&quot;)</span><br><span class="line">    String exception() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动<code>eureka-server</code>，然后再启动<code>service-client</code>，最后启动<code>service-feign</code>，在浏览器输入<code>http://localhost:8765/sayHello?name=Beck Wang</code>，会看如下效果</li></ul><p><img src="https://img-blog.csdnimg.cn/20190621152128911.gif" alt="在这里插入图片描述"></p><ul><li>接下来我关掉<code>service-client</code>，就会看到如下效果：浏览器上显示了<code>sorry Beck Wang，上游服务断开, 服务降级</code>，就证明我们的熔断器起作用了，否则就会报500。</li></ul><p><img src="https://img-blog.csdnimg.cn/20190624150718357.gif" alt="在这里插入图片描述"></p><ul><li>比较常见的还有timeout，如果上游服务timeout，hystrix也是可以做出处理，首先要配置超时时间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 设置超时时间</span><br><span class="line">feign:</span><br><span class="line">    httpclient:</span><br><span class="line">        connection-timeout: 5000</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190624150906684.gif" alt="在这里插入图片描述"></p><ul><li>还有就是上游服务抛出exception，hystrix也是可以处理<br><img src="https://img-blog.csdnimg.cn/201906241509394.gif" alt="在这里插入图片描述"></li><li>那么熔断之后，到底要怎么做呢？<ul><li>检查日志，修好它。</li><li>fallback就写你业务上可以返回的默认值</li></ul></li></ul><p><a href="https://github.com/BazookaW/springcloud-sample/tree/master/Hystrix-sample" target="_blank" rel="noopener">源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud - 网关（Spring Cloud Gateway）</title>
      <link href="/2020/04/17/Spring-Cloud-%E7%BD%91%E5%85%B3%EF%BC%88Spring-Cloud-Gateway%EF%BC%89/"/>
      <url>/2020/04/17/Spring-Cloud-%E7%BD%91%E5%85%B3%EF%BC%88Spring-Cloud-Gateway%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要讲解一下网关。</p><a id="more"></a><p>老王正准备下班，路过小铭的位置，发现他正在阅读Spring Cloud Gataway的<a href="https://cloud.spring.io/spring-cloud-gateway/spring-cloud-gateway.html" target="_blank" rel="noopener">官方文档</a>。</p><p>看了看时间，等公交车还有一会儿，顺便就和小铭交流一下，便问道：“你在学习Spring Cloud网关吗？”</p><p>小铭听到声音后转过身来，便看到老王拉了一把椅子坐下。正好自己有一些疑惑的地方，也想找人交流学习一下。</p><p>“是啊，我最近不是在学习微服务这部分知识吗，现在学到网关这部分了。其实我不是特别明白，为什么我们的微服务需要网关呢？”</p><h5 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h5><p>老王神秘一笑，说道：“我给你看两张图你就明白了。”然后在小铭的电脑上搜出了<a href="http://blog.daocloud.io/microservices-2/" target="_blank" rel="noopener">这篇文章</a>里面的两张图。</p><p>“我们假设你现在要做一个电商应用，前端是移动端的APP，后端是各种微服务。那你可能某个页面需要调用多个服务的数据来展示。如果没有网关，你的系统看起来就是这个样子的：”<br><img src="https://img-blog.csdnimg.cn/20190626104854159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>“而如果加上了网关，你的系统就会变成这个样子：”<br><img src="https://img-blog.csdnimg.cn/20190626104910398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>“嗯，这看起来是一个‘高内聚，低耦合’的思想，如果不使用网关，可能有什么坏处呢？”小铭问道。</p><p>“这个其实从刚刚的第一张图你就看得出来，如果没有网关，你的客户端就会变得非常麻烦。对每一个微服务，可能都要做权限认证、负载均衡等工作；而且后端的微服务可能还使用了不同的消息通信协议；最重要的是，如果你想对微服务进行重构，比如拆分或者合并为服务器，那也必须得修改客户端，增加了复杂性。”</p><h5 id="网关的技术选型"><a href="#网关的技术选型" class="headerlink" title="网关的技术选型"></a>网关的技术选型</h5><p>小铭：“那看来网关确实是至关重要，现在市面上有哪些微服务网关呢？”</p><p>“我们在实现网关的时候，需要考虑到的是它的性能和可扩展性。对于现成的产品来说，NGINX Plus是一个很不错的选择，NGINX Plus 提供了一个成熟的、可扩展的、高性能 web 服务器和一个易于部署的、可配置可编程的反向代理。NGINX Plus 可以管理身份验证、访问控制、负载均衡请求、缓存响应，并提供应用程序可感知的健康检查和监控。除此之外，你还可以使用Node.js或者Netty根据自己的需求去自己写一个网关。而且Spring Cloud也提供了一些已经写好的微服务网关框架，你知道有哪些吗？”</p><p>“我查了一下，好像<code>Spring Cloud Gataway</code>和<code>Netflix的Zuul</code>都挺不错的。但Netflix的套件暂停开发了，所以我现在主要在看Spring Cloud Gateway。”</p><p>老王点点头，道：“是的，Netflix很多组件到停止开发了。前两天我们讨论的Hystrix也是，但是Hystrix的替代产品还在孵化中。但网关方面，Spring Cloud Gateway已经孵化完成了，可以用来替代Zuul。那你知道Spring Cloud Gateway的原理吗？”</p><h5 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h5><p>小铭把刚刚自己正在看的官方文档打开，然后给老王看了官网文档的这个图，一边说道：“Spring Cloud Gateway是基于Spring Boot 2.0, Spring WebFlux, Reactor项目构建的，底层是Netty。它的流程其实和Zuul很相似，使用一系列的过滤器去处理请求，达到我们自己想要的定制化。”<br><img src="https://img-blog.csdnimg.cn/20190626105311740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>老王问：“那里刚刚看完了官方文档，可以跟我总结一下它有哪些功能吗？”</p><p>“Spring Cloud Gateway几乎可以满足绝大多数网关的需求。它主要有下面一些功能：”</p><ul><li>Predicate</li></ul><p>断言可以指定在什么情况下可以匹配某个路由。断言是基于Java 8提供的<code>Predicate</code>接口。Gateway（以下简称Spring Cloud Gateway为Gateway）提供了一些默认的断言。你可以在<a href="https://cloud.spring.io/spring-cloud-gateway/spring-cloud-gateway.html#gateway-request-predicates-factories" target="_blank" rel="noopener">官方文档</a>查看具体有哪些断言以及它们的用法。</p><p>支持时间、Cookie、Header、Host、HTTP Method、相对路径、URL查询语句、远程IP等来做断言。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: method_route</span><br><span class="line">        uri: https:&#x2F;&#x2F;example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Method&#x3D;GET</span><br></pre></td></tr></table></figure><ul><li>网关过滤器 GatewayFilter</li></ul><p>Gateway也提供了一些已经写好的过滤器。可以查看<a href="https://cloud.spring.io/spring-cloud-gateway/spring-cloud-gateway.html#_gatewayfilter_factories" target="_blank" rel="noopener">官方文档</a>。主要有重写request或者response的header、parameter、body、session、安全、重写路径、重试以及对熔断的一些支持。</p><ul><li>全局过滤器 Global Filters</li></ul><p>全局过滤器与网关过滤器类似，只是默认会给所有的请求都添加上全局过滤器。当然，也可以自己定义全局过滤器。过滤器的顺序可以通过<code>@Order</code>注解来指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Order(-1)</span><br><span class="line">public GlobalFilter a() &#123;</span><br><span class="line">    return (exchange, chain) -&gt; &#123;</span><br><span class="line">        log.info(&quot;first pre filter&quot;);</span><br><span class="line">        return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            log.info(&quot;third post filter&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@Order(0)</span><br><span class="line">public GlobalFilter b() &#123;</span><br><span class="line">    return (exchange, chain) -&gt; &#123;</span><br><span class="line">        log.info(&quot;second pre filter&quot;);</span><br><span class="line">        return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            log.info(&quot;second post filter&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@Order(1)</span><br><span class="line">public GlobalFilter c() &#123;</span><br><span class="line">    return (exchange, chain) -&gt; &#123;</span><br><span class="line">        log.info(&quot;third pre filter&quot;);</span><br><span class="line">        return chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            log.info(&quot;first post filter&quot;);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其它功能</li></ul><p>Gateway还提供了其它很多功能，比如说SSL方面的配置、基于netty的access log、跨域、actuator端点等等。</p><p>尤其是actuator端点，它可以让我们使用HTTP请求去动态地获取、新增、删除路由。具体的使用方法和参数查看<a href="https://cloud.spring.io/spring-cloud-gateway/spring-cloud-gateway.html#_retrieving_the_routes_defined_in_the_gateway" target="_blank" rel="noopener">官方文档</a>。</p><h5 id="与注册中心配合"><a href="#与注册中心配合" class="headerlink" title="与注册中心配合"></a>与注册中心配合</h5><p>老王：“嗯，上面基本上把Spring Cloud Gateway的功能总结全了。它还可以与Spring Cloud的注册中心无缝集成。”</p><p>小铭接着老王的话，说道：“是的，Gateway可以很方便地与注册中心配合起来使用，默认使用Ribbon实现了负载均衡。”</p><h5 id="网关本身的负载均衡"><a href="#网关本身的负载均衡" class="headerlink" title="网关本身的负载均衡"></a>网关本身的负载均衡</h5><p>说完后，小铭问道：“那所有微服务就只有一个网关，万一并发量上去了，网关承受不住怎么办？”</p><p>老王笑道：“正如你上面所说，Spring Cloud Gateway底层是Netty的，它本身就能承受比较大的并发。如果还是承受不了并发量，那可以注册多个Gateway实例，然后在前面弄一个Nginx或者F5等负载均衡器。大概图是这样：”<br><img src="https://img-blog.csdnimg.cn/20190626112139446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>如果是微服务和微服务之间的内部调用，就不需要配置网关，直接用Feign，因为Feign集成了网关和负载均衡组件，超方便。</li><li>如果是外部调用微服务，比如APP或者Web程序调用微服务，还是需要配置网关的。</li><li>网关优先于负载均衡。</li></ul><p><a href="https://github.com/BazookaW/springcloud-sample/tree/master/Gateway-sample" target="_blank" rel="noopener">源码</a><br>源码来源于<a href="https://spring.io/guides/gs/gateway/" target="_blank" rel="noopener">官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud - 负载均衡和远程调用（OpenFeign）</title>
      <link href="/2020/04/17/Spring-Cloud-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%88OpenFeign%EF%BC%89/"/>
      <url>/2020/04/17/Spring-Cloud-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%EF%BC%88OpenFeign%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>负载均衡，使用微服务后，为了能够承担高并发的压力，同一个服务可能会启动多个实例。这时候消费者就需要负载均衡，把请求分散到各个实例。负载均衡主要有两种设计：服务端负债均衡；客户端负债均衡。</p><a id="more"></a><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><p>使用微服务后，为了能够承担高并发的压力，同一个服务可能会启动多个实例。这时候消费者就需要负载均衡，把请求分散到各个实例。负载均衡主要有两种设计：</p><ul><li>服务端负债均衡</li><li>客户端负债均衡</li></ul><p>对于传统的分布式服务来说，大多使用服务端负债均衡。一般会使用Nginx或者ELB等工具作为负载均衡器，如下图：<br><img src="https://img-blog.csdnimg.cn/20190620164957482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>而在Spring Cloud中，使用的是<code>客户端负载均衡</code>的方式，使用Ribbon组件来实现客户端的负载均衡。主要引入了微服务注册中心依赖，就会自动引入Ribbon依赖。客户端负载均衡原理如下图：<br><img src="https://img-blog.csdnimg.cn/20190620165135803.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="Ribbon的原理"><a href="#Ribbon的原理" class="headerlink" title="Ribbon的原理"></a>Ribbon的原理</h5><p><code>Ribbon</code>利用了<code>RestTemplate</code>的拦截器（接口是<code>ClientHttpRequestInterceptor</code>）机制，在拦截器中实现的负载均衡。负载均衡的基本实现就是利用从服务注册中心获取可用的服务地址列表，然后通过一定算法负载，决定使用哪一个服务地址来进行HTTP调用。</p><p>详情可以查看<code>LoadBalancerInterceptor</code>这个类，在<code>org.springframework.cloud.client.loadbalancer</code>包下。</p><h5 id="负债均衡策略"><a href="#负债均衡策略" class="headerlink" title="负债均衡策略"></a>负债均衡策略</h5><p>查看<code>IRule</code>接口的实现类，可以看到Ribbon的所有负载均衡策略，查看各实现类顶部的注释可以看到它的具体策略：</p><p><img src="https://img-blog.csdnimg.cn/20190620165601961.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>RandomRule：随机选择；</li><li>RoundRobinRule：轮询；</li><li>WeightedResponseTimeRule：根据每个服务的响应时间设置权重，响应时间越长，所占权重越少；</li><li>AvailabilityFilteringRule：过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值）；</li><li>ZoneAvoidanceRule：使用<code>CompositePredicate</code>根据区域和可用性过滤服务器的规则；</li><li>BestAvailableRule：选择一个最小的并发请求的server；</li><li>RetryRule：在现有的策略基础上，添加重试机制，因为<code>IRule</code>支持级联。</li></ul><h5 id="远程调用（OpenFeign）"><a href="#远程调用（OpenFeign）" class="headerlink" title="远程调用（OpenFeign）"></a>远程调用（OpenFeign）</h5><p>Spring Cloud提供了<code>OpenFeign</code>组件（以前叫Feign）来进行远程的HTTP调用。它是对<code>RestTemplate</code>的一个封装。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p><ul><li>Feign 采用的是基于接口的注解</li><li>Feign 整合了ribbon，具有负载均衡的能力</li><li>整合了Hystrix，具有熔断的能力</li></ul><p>Feign是一个声明式Web Service客户端。使用Feign能让编写Web Service客户端更加简单。Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与微服务注册中心和Ribbon组合使用以支持负载均衡。</p><h5 id="使用OpenFeign"><a href="#使用OpenFeign" class="headerlink" title="使用OpenFeign"></a>使用OpenFeign</h5><p>因为Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果，所以已Feign为例。</p><ul><li><p>准备：</p><ul><li>启动<code>eureka-server</code>。</li><li>启动service-client工程，它的端口为8762；然后将service-client的配置文件的端口改为8763，并启动。</li></ul></li><li><p>首先创建一个项目service-feign，引入依赖<code>spring-cloud-starter-openfeign</code>、Eureka的起步依赖<code>spring-cloud-starter-netflix-eureka-client</code>，完整的pom如下：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;service-feign&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;service-feign&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;Feign-sample&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为<code>http://localhost:8761/eureka/</code> ，完整的application.yml如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">    client:</span><br><span class="line">        serviceUrl:</span><br><span class="line">            defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">    port: 8765</span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-feign</span><br></pre></td></tr></table></figure><ul><li>第二步，启动配置，在启动类上添加@EnableFeignClients注解：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class ServiceFeignApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(ServiceFeignApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三步，声明调用接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(&quot;service-client&quot;)</span><br><span class="line">public interface UserClient &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;client&quot;)</span><br><span class="line">    String sayHello(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第四步：使用，注解使用<code>@Autowired</code>注解注入就可以了：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserClient userClient;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;sayHello&quot;)</span><br><span class="line">    public String sayHello(@RequestParam String name)&#123;</span><br><span class="line">        return userClient.sayHello(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第五步，启动程序会看到浏览器交替显示如下</li></ul><blockquote><p>hi Beck Wang ,i am from port:8762<br>hi Beck Wang ,i am from port:8763</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190620172353105.gif" alt="在这里插入图片描述"></p><ul><li>此时的架构示意图</li></ul><p><img src="https://img-blog.csdnimg.cn/20190621094151637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><a href="https://github.com/BazookaW/springcloud-sample/tree/master/Feign-sample" target="_blank" rel="noopener">源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud - 注册中心</title>
      <link href="/2020/04/17/Spring-Cloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2020/04/17/Spring-Cloud-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>微服务注册中心最主要的功能正是用来“管理”微服务的。它相当于一个信息中心，保存着每个微服务的ip地址等信息。这样当其它微服务要调用这个微服务时，就可以去注册中心拿到ip，再根据ip去访问相应的微服务。</p><a id="more"></a><h5 id="什么是微服务注册中心？"><a href="#什么是微服务注册中心？" class="headerlink" title="什么是微服务注册中心？"></a>什么是微服务注册中心？</h5><p>在上一篇文章《Spring Cloud介绍》中，提到有一句话：微服务框架可以为这些微小的服务提供统一的管理和必要的工具，使它们更易于开发和维护。</p><p>“统一的管理和必要的工具”正是微服务框架与单纯地“分布式应用”的区别所在。我们在后续的文章也主要是介绍这样一些Spring Cloud提供的管理微服务的组件和工具。</p><p>微服务注册中心最主要的功能正是用来“管理”微服务的。它相当于一个信息中心，保存着每个微服务的ip地址等信息。这样当其它微服务要调用这个微服务时，就可以去注册中心拿到ip，再根据ip去访问相应的微服务。如下图：<br><img src="https://img-blog.csdnimg.cn/20190619142501195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="为什么需要注册中心？"><a href="#为什么需要注册中心？" class="headerlink" title="为什么需要注册中心？"></a>为什么需要注册中心？</h5><p>注册中心相当于“婚介所”或者“房屋中介所”。试想一下，如果没有一个这样的中间角色，当一个微服务（消费者）需要调用另一个微服务（生产者）时，它需要保存生产者的地址（如ip，端口等信息）。而这个时候一旦生产者的地址产生了变化，比如：</p><ul><li>新增了节点</li><li>减少了节点</li><li>原有结点的ip或端口变化</li></ul><p>就会导致所有的消费者更改配置。传统分布式系统是对每个API创建一个对外的网关，一般使用ELB等负载均衡工具再配上DNS系统来实现<br><img src="https://img-blog.csdnimg.cn/20190619142558489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样虽然一定程度上能解决服务调用之间的问题，但仍然需要维护大量的ELB/DNS等信息，而且当结点想要动态地增加或删除时，需要去修改ELB的配置。</p><p>使用注册中心后，结点的注册、删除、健康检查等功能都能自动化。消费者再也不需要手动去挨个寻找和维护任何生产者的地址信息，只是定时去注册中心取一下就行。</p><h5 id="注册中心技术选型"><a href="#注册中心技术选型" class="headerlink" title="注册中心技术选型"></a>注册中心技术选型</h5><table><thead><tr><th>Feature</th><th>eureka</th><th>Consul</th><th>zookeeper</th><th>etcd</th></tr></thead><tbody><tr><td>服务健康检查</td><td>可配支持</td><td>服务状态，内存，硬盘等</td><td>(弱)长连接，keepalive</td><td>连接心跳</td></tr><tr><td>多数据中心</td><td>—</td><td>支持</td><td>—</td><td>—</td></tr><tr><td>kv 存储服务</td><td>—</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>一致性算法</td><td>—</td><td>raft</td><td>paxos增强</td><td>raft</td></tr><tr><td>cap</td><td>ap</td><td>cp</td><td>cp</td><td>cp</td></tr><tr><td>使用接口(多语言能力)</td><td>http（sidecar）</td><td>支持 http 和 dns</td><td>客户端</td><td>http/grpc</td></tr><tr><td>watch 支持</td><td>支持 long polling/大部分增量</td><td>全量/支持long polling</td><td>支持</td><td>支持 long polling</td></tr><tr><td>自身监控</td><td>metrics</td><td>metrics</td><td>—</td><td>metrics</td></tr><tr><td>安全</td><td>—</td><td>acl /https    acl</td><td>https</td><td>支持（弱）</td></tr><tr><td>spring cloud 集成</td><td>已支持</td><td>已支持</td><td>已支持</td><td>已支持</td></tr></tbody></table><p>关于分布式CAP的理论，本文不细讲，有兴趣的读者自己去了解一下。C代表一致性，A代表高可用性，P代表分区容错性。在分布式系统中，三者不能同时满足，而P是一定需要满足的，所以常见的分布式系统要么满足AP，要么满足CP。</p><p>本文以<code>Eureka</code>为例来搭建和使用注册中心，<code>Eureka</code>是Netflix自己开发的，它是通过在客户端配置所有注册中心结点来实现高可用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        hostname: localhost</span><br><span class="line">client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">        defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><h5 id="使用Eureka"><a href="#使用Eureka" class="headerlink" title="使用Eureka"></a>使用Eureka</h5><ul><li>首先创建一个主Maven工程，在其pom文件引入依赖，<code>Spring Boot</code>版本为<code>2.1.5.RELEASE</code>，<code>Spring Cloud</code>版本为<code>Finchley.RELEASE</code>。这个pom文件作为父pom文件，起到依赖版本控制的作用，其他module工程继承该pom。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;</span><br><span class="line">         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;Eureka-sample&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;com.bazooka&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;eureka-server&lt;&#x2F;module&gt;</span><br><span class="line">        &lt;module&gt;service-client&lt;&#x2F;module&gt;</span><br><span class="line">    &lt;&#x2F;modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">        &lt;spring-cloud.version&gt;Finchley.RELEASE&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">    &lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">            &lt;&#x2F;dependency&gt;</span><br><span class="line">        &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><ul><li>创建eureka-server，作为服务注册中心。<br>File -&gt; New -&gt; Project…</li></ul><p><img src="https://img-blog.csdnimg.cn/20190619144805206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选择cloud discovery-&gt;eureka server ,然后一直下一步就行了。</p><p><img src="https://img-blog.csdnimg.cn/20190619144855932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>创建好之后其pom继承了父pom文件，并引入<code>spring-cloud-starter-netflix-eureka-server</code>的依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;eureka-server&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;Eureka-sample&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>首先需要在springboot工程的启动application类上加<code>@EnableEurekaServer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer</span><br><span class="line">public class EurekaServerApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。eureka server的配置文件appication.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8761</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">    instance:</span><br><span class="line">        hostname: localhost</span><br><span class="line">client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">        defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: eurka-server</span><br></pre></td></tr></table></figure><p>通过eureka.client.registerWithEureka：false和fetchRegistry：false来表明自己是一个eureka server。<br>启动项目之后，输入如下链接可以看到页面</p><p><img src="https://img-blog.csdnimg.cn/2019061914550629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>创建一个eureka client作为服务提供者</li></ul><p>创建过程同eureka server，不再赘述，创建好的eureka client的pom如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;service-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;service-client&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;com.bazooka&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;Eureka-sample&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line">&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><p>通过注解<code>@EnableEurekaClient</code> 表明自己是一个eureka client。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@RestController</span><br><span class="line">public class ServiceClientApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(</span><br><span class="line">ServiceClientApplication.class, args );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">String port;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;client&quot;)</span><br><span class="line">public String home(@RequestParam(value &#x3D; &quot;name&quot;, defaultValue &#x3D; &quot;bazooka&quot;) String name) &#123;</span><br><span class="line">return &quot;hi &quot; + name + &quot; ,i am from port:&quot; + port;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅@EnableEurekaClient是不够的，还需要在配置文件中注明自己的服务注册中心的地址，application.yml配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">    port: 8762</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">    application:</span><br><span class="line">        name: service-client</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">    client:</span><br><span class="line">        serviceUrl:</span><br><span class="line">            defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure><p>启动项目，会在client端看到如下文字。</p><p><img src="https://img-blog.csdnimg.cn/20190619145857449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>同时在server端也可以看到如下效果。</p><p><img src="https://img-blog.csdnimg.cn/20190619145933919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这个时候就会发现一个服务已经在注册中心了。</p><p><a href="https://github.com/BazookaW/springcloud-sample/tree/master/Eureka-sample" target="_blank" rel="noopener">源码地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud介绍</title>
      <link href="/2020/04/17/Spring-Cloud%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/04/17/Spring-Cloud%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud是什么？Spring Cloud是一个主流的<code>微服务框架</code>。微服务的概念源于2014年3月Martin Fowler所写的一篇文章。</p><a id="more"></a><h5 id="Spring-Cloud是什么？"><a href="#Spring-Cloud是什么？" class="headerlink" title="Spring Cloud是什么？"></a>Spring Cloud是什么？</h5><p>Spring Cloud是一个主流的<code>微服务框架</code>。微服务的概念源于2014年3月Martin Fowler所写的一篇文章<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Microservices</a>。</p><p>微服务是一种解决复杂应用的架构模式。它的理念是将复杂应用拆分成一个个微小的服务，每个服务运行在独立的环境（进程、虚拟机、容器等）中，彼此之间互不干扰，独立开发，独立构建和部署。最终集成在一起，相互协调，为用户提供价值。</p><p>微服务框架可以为这些微小的服务提供统一的管理和必要的工具，使它们更易于开发和维护。</p><h5 id="为什么需要微服务？"><a href="#为什么需要微服务？" class="headerlink" title="为什么需要微服务？"></a>为什么需要微服务？</h5><p>微服务解决了什么痛点？你的应用到底需不需要微服务？</p><p>首先，如果对于业务简单、并发量较小的应用来说，其实是不需要使用微服务架构的，比如一些小的网站。但对于复杂的大型应用来说，是推荐使用微服务的。先来看看一个大型的单体应用可能有哪些痛点？</p><ul><li>所有代码集成到一个项目，任何业务修改都需要重新部署整个项目</li><li>一个项目里面的代码量太大，难以管理，很难重构，出了BUG也很难排查</li><li>所有业务逻辑都在一个项目，测试量很大，每次都需要跑很久测试</li><li>难以水平扩展，很难处理突发流量激增的情况。</li><li>…</li></ul><p>在微服务概念出现以前，有的团队为了解决上述痛点，开始使用“分布式系统”的理念去设计系统。</p><p>把应用拆成一个个小的应用，独立开发和部署。但由于缺乏统一的服务治理工具，所以需要集成一些外部的工具来完善这个系统。比如负载均衡、权限网关、路由、配置管理、状态监控等等工作都得自己做或者使用其它软件。这在一定程度上其实也增加了复杂性，尤其是运维的复杂性。</p><h5 id="为什么使用Spring-Cloud？"><a href="#为什么使用Spring-Cloud？" class="headerlink" title="为什么使用Spring Cloud？"></a>为什么使用Spring Cloud？</h5><p>在<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">Spring Cloud</a>流行以前，其实已经有一些微服务解决方案。使用最广泛的就是阿里的<code>Dubbo</code>了。但<code>Dubbo</code>只提供了一些基础的功能，有点类似于上面提到的“分布式系统”的升级版，还不具备一个完善的微服务框架的功能。所以<code>Dubbo</code>往往也需要与其他框架进行集成，比如使用<code>Zookeeper</code>进行服务注册和发现。</p><p><code>Spring Cloud</code>是Spring团队开发和维护，具有更完善的功能、更快的迭代速度、用户更多的特点。所以<code>Spring Cloud</code>是企业开始使用微服务的一个很好的技术选型。</p><p>还有最近比较火的Service Mesh的概念，被称为“下一代微服务”，它具有更先进的设计理念，把服务划分为一个个服务网格，并且架构更抽象，使得开发和运维分离，开发人员不需要学习太多的微服务知识便可以实现微服务。有兴趣的读者可以去了解一下Service Mesh，应该是以后的趋势。后续我可能也会学习Service Mesh并写点文章。</p><p>但身为一个开发人员，我认为还是有必要去学习一下<code>Spring Cloud</code>，可以让我们更深入地了解一些微服务的设计理念。之前也学习过<code>Spring Cloud</code>，但不够系统和深入。这次重新学习一遍，配合文章加深自己的理解。</p><p>所以最近会写一些<code>Spring Cloud</code>系列的文章，把自己所学的东西分享出来，欢迎关注。</p><h5 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h5><ul><li><a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">Spring Cloud</a></li><li><a href="https://springcloud.cc/" target="_blank" rel="noopener">中文版Spring Cloud</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring Cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的并发控制</title>
      <link href="/2020/04/17/Mysql%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/04/17/Mysql%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>MySQL的逻辑架构图如下：</p><a id="more"></a><h5 id="Mysql的逻辑架构"><a href="#Mysql的逻辑架构" class="headerlink" title="Mysql的逻辑架构"></a>Mysql的逻辑架构</h5><p>Mysql的逻辑架构如下图：</p><p><img src="https://img-blog.csdnimg.cn/20190804170458874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>最上层是处理客户端过来的连接的。主要做连接处理、授权认证、安全等。Mysql在这一层维护了一个线程池，用于处理来自客户端的连接。</p><p>第二层由三部分组成：查询缓存、解析器、优化器。解析器用来解析SQL语句，优化器会对解析之后的语句进行优化。在解析查询前，服务器会先检查查询缓存，如果能在其中找到对应的查询结果，则无需再进行查询解析、优化等过程，直接返回查询结果。存储过程、触发器、视图等都在这一层实现。</p><p>第三层是存储引擎，存储引擎负责在MySQL中存储数据、提取数据、开启一个事务等等。存储引擎通过API与上层进行通信，这些API屏蔽了不同存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎不会去解析SQL。</p><blockquote><p>Mysql最常用的存储引擎是InnoDB</p></blockquote><h5 id="Mysql的并发控制"><a href="#Mysql的并发控制" class="headerlink" title="Mysql的并发控制"></a>Mysql的并发控制</h5><ul><li>读写锁</li></ul><p>如果多个线程都只是读数据，其实可以一起读，不会互相影响，这个时候应该使用“读锁”，也称为共享锁。获取读锁的线程之间互相不会阻塞，可以同时读取一个资源。</p><p>如果有一个线程需要写数据，则应该使用“写锁”，也成为排它锁。写锁会阻塞其它的写锁和读锁，直至写操作完成。</p><ul><li>锁粒度</li></ul><p>首先明确一个概念：在给定的资源上，需要加锁的数据越少，系统能够承载的并发量就越高。但加锁也是需要消耗资源的，如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受影响。</p><p>所以一个好的“锁策略”就是要在锁的开销和数据的安全性之间寻求平衡，Mysql支持多个存储引擎的架构，每种存储引擎都可以实现自己的锁策略和锁粒度。</p><ul><li>表锁和行锁</li></ul><p>表锁顾名思义就是锁住整张表。表锁开销比较小。对表加写锁后，其它用户对这张表的所有读写操作都会被阻塞。在Mysql中，尽管存储引擎可以提供自己的锁，但Mysql有时候也会使用表锁，比如<code>ALTER TABLE</code>之类的语句。</p><blockquote><p>写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。</p></blockquote><p>行级锁即锁住整行，可以最大程度地支持并发处理，但加解锁的开销也会比较大。行级锁只在储存引擎层实现，所有的存储引擎都以自己的方式实现了行级锁。</p><h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h5><p>MVCC即“多版本并发控制”，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。</p><p>主流的关系型数据库都实现了MVCC，但实现机制各有不同。实际上MVCC也没有一个统一的标准。但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p><p>MVCC保证的是每个事务里面在执行期间看到的数据都是一致的。但不同的事务由于开始的时间不同，所以可能对同一张表，同一时刻看到的数据是不一样的。</p><p>在Mysql的InnoDB引擎，是通过给每行记录后面保存两个隐藏的列来实现的。一个是保存行的创建时间，另一个保存了行的过期时间（或删除时间）。</p><blockquote><p>实际上存储的并不是实际的一个时间戳，而是“系统版本号”。</p></blockquote><p>每次开启一个事务，系统版本号都会递增。事务开始时，系统版本号会作为事务的版本号，用来和查询到的行的版本号进行比较。下面分别介绍常见的CRUD操作中版本号是怎么工作的：</p><ul><li>INSERT</li></ul><p>保存当前系统版本号作为行版本号</p><ul><li>DELETE</li></ul><p>保存当前的系统版本号到这行数据的“删除版本”。</p><ul><li>UPDATE</li></ul><p>插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行的“删除版本”。</p><ul><li><p>SELECT</p><ul><li>只查找版本早于当前事务版本的行。这样可以保证事务读取都的行，要么之前就存在，要么是这个事务本身自己插入或者修改的。</li><li>行的“删除版本”要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务之前没有被删除。</li></ul></li></ul><p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，其它两个隔离级别不能工作。因为READ UNCOMMITTED总是读取最新的数据防，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL，MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL查询优化</title>
      <link href="/2020/04/17/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2020/04/17/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>什么查询会慢？查询慢的原因可能很多，比如网络原因、锁争用等等。但最基本的原因可能是访问的数据太多。要么可能访问了太多的行，要么可能访问了太多的列，要么可能MySQL在查询的时候需要分析大量超过需要的行。</p><a id="more"></a><h5 id="为什么查询会慢？"><a href="#为什么查询会慢？" class="headerlink" title="为什么查询会慢？"></a>为什么查询会慢？</h5><p>查询慢的原因可能很多，比如网络原因、锁争用等等。但最基本的原因可能是访问的数据太多。要么可能访问了太多的行，要么可能访问了太多的列，要么可能MySQL在查询的时候需要分析大量超过需要的行。</p><h5 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h5><p>一个查询根据不同的场景，一般可以通过下面的方式来进行优化：</p><ul><li>使用COUNT *</li></ul><p>在使用COUNT统计行数时，<code>COUNT(*)</code>是性能最高的。</p><ul><li>使用LIMIT</li></ul><p>有时候查询并不需要返回所有的结果集，这时候可以加LIMIT限制返回多少。这在分页的场景下很常见。</p><p>MySQL在进行UNION操作的时候，如果把LIMIT写在外查询里，会先将两个子查询的所有数据放在临时表，然后取前xx行。这样性能其实是比较低的，更推荐的做法是把LIMIT同时也到子查询里。</p><p>有时候可以使用<code>LIMIT 1</code>来代替<code>MIN</code>和<code>MAX</code>函数。因为这两个函数需要全表扫描。</p><ul><li>不要查询所有列</li></ul><p>有时候为了方便，会直接写<code>SELECT *</code>来查询所有列的数据。但可能使用的时候不一定要使用到所有列。这个时候可以只查询部分需要用到的列。</p><p>但有时候可能也有例外，因为这样做确实可以简化开发，而且有时候应用程序里面可能会有缓存机制，这样多个查询可能可以复用这个缓存。</p><ul><li>经常查询的列建立索引</li></ul><p>在前面的文章《MySQL索引原理》《MySQL索引使用策略和优化》中，我们介绍了MySQL的索引。在经常查询的列上面建立索引，可以让MySQL尽可能地扫描少的行。</p><p>但这里也需要注意，维护索引是有代价的，所以需要自己去权衡时候使用索引。还有一点就是MySQL的索引是基于“最左匹配”原则的。详情可以参考之前的文章。</p><ul><li>分解复杂查询</li></ul><p>有时候一个复杂查询可能会“很大”，需要扫描许多行，关联很多表。这个时候可以把它分解成很多个小的查询。这样做有很多好处：</p><pre><code>1.让缓存的效率更高2.执行单个查询可以减少锁的竞争3.更容易对数据库进行拆分4.减少冗余记录的查询：有时候关联查询可能会重复查询同样的数据行。</code></pre><p>当然，分解后也会带来弊端，就是发生的查询数量多了，MySQL的连接数就多了，可能会带来网络上的一些开销。但MySQL一般是放在内网的，网络一般会很快，所以不会有太大的影响。</p><ul><li>反范式设计数据表</li></ul><p>在设计数据表的时候，为了性能上的优化，可以反范式地设计表。这样可以减小表的关联，加快查询的速度。</p><ul><li>使用IN</li></ul><p>MySQL在查询的时候使用<code>IN()</code>时，会先将IN列表中的数据进行排序，然后通过二分查找的方式来确定列表中的值时候满足条件，这是一个O(log n)复杂度的操作，而如果是OR的话，复杂度是O(n)，所以如果对IN列表中有大量取值的时候，使用IN会更快一些。</p><p>但尽量不要使用IN加子查询。因为MySQL会将相关的外层表压到子查询中，效率很低。如果是需要用到IN加子查询的时候，建议使用<code>EXISTS()</code>等效查询来做。</p><ul><li>不使用OFFSET</li></ul><p>OFFSET在分页的时候很常见。一旦页码过大，OFFSET和导致MySQL扫描大量不需要的行然后丢掉。那如何解决这个问题呢？有两种方式。</p><p>第一种方式是从前端就限制了用户不能直接访问太大的页码。比如百度搜索结果下面的分页，限制了用户很难访问到很大的页码。</p><p>第二种方式是使用主键来辅助。比如上一页返回的id的1000，那下一页就可以直接WHERE查找id大于1000且小于1020。这样查的时候就可以不用OFFSET了，MySQL也只需要扫描很少的行。但这样有一个弊端，就是有些数据可能被删掉了，那每页的范围和数量就不太好控制。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>总的来说，主要是针对MySQL本身的查询流程和引擎实现来做优化。但实际我们开发程序的时候，在应用层可以做缓存来优化性能，这样可以大大减少MySQL的请求和查询次数。</p><p>另一方面，MySQL的索引非常重要，理解索引的原理，创建合适的索引可以极大地提升查询的性能。使用索引的主要好处就是可以在查询的时候扫描更少的行。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL语句优化利器EXPLAIN</title>
      <link href="/2020/04/17/MySQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8EXPLAIN/"/>
      <url>/2020/04/17/MySQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8EXPLAIN/</url>
      
        <content type="html"><![CDATA[<p>EXPLAIN是什么？使用<code>EXPLAIN</code>关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。<code>EXPLAIN</code>可以帮助选择更好的索引和写出更优化的查询语句。在MySQL5.6以及以后的版本中，除过select，其他比如insert，update和delete均可以使用<code>EXPLAIN</code>查看执行计划。</p><a id="more"></a><h5 id="EXPLAIN是什么"><a href="#EXPLAIN是什么" class="headerlink" title="EXPLAIN是什么"></a>EXPLAIN是什么</h5><p>使用<code>EXPLAIN</code>关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。<code>EXPLAIN</code>可以帮助选择更好的索引和写出更优化的查询语句。在MySQL5.6以及以后的版本中，除过select，其他比如insert，update和delete均可以使用<code>EXPLAIN</code>查看执行计划。</p><h5 id="通过EXPLAIN，我们可以分析出以下结果："><a href="#通过EXPLAIN，我们可以分析出以下结果：" class="headerlink" title="通过EXPLAIN，我们可以分析出以下结果："></a>通过EXPLAIN，我们可以分析出以下结果：</h5><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><h5 id="EXPLAIN语法"><a href="#EXPLAIN语法" class="headerlink" title="EXPLAIN语法"></a>EXPLAIN语法</h5><blockquote><p>EXPLAIN SELECT * FROM table</p></blockquote><h5 id="执行计划各字段含义"><a href="#执行计划各字段含义" class="headerlink" title="执行计划各字段含义"></a>执行计划各字段含义</h5><p><img src="https://img-blog.csdnimg.cn/20190823145028435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>id<br>SELECT识别符。这是SELECT的查询序列号。id相同，执行顺序从上往下，<br>id不同，id值越大，优先级越高，越先执行。</li><li>select_type<br>查询类型，主要用于区别普通查询，联合查询，子查询等的复杂查询。<ul><li>simple ——简单的select查询，查询中不包含子查询或者UNION</li><li>primary ——查询中若包含任何复杂的子部分，最外层查询被标记</li><li>subquery——在select或where列表中包含了子查询</li><li>derived——在from列表中包含的子查询被标记为derived（衍生），MySQL会递归执行这些子查询，把结果放到临时表中</li><li>union——如果第二个select出现在UNION之后，则被标记为UNION，如果union包含在from子句的子查询中，外层select被标记为derived</li><li>union result:UNION 的结果</li></ul></li><li>table<br>查询所涉及的表。</li><li>partitions<br>版本5.7以前，该项是explain partitions显示的选项，5.7以后成为了默认选项。该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。</li><li>type<ul><li><code>system</code>：表中仅有一行（=系统表）这是const联结类型的一个特例。</li><li><code>const</code>：表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数据，所以如果将主键置于where列表中，mysql能将该查询转换为一个常量</li><li><code>eq_ref</code>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于唯一索引或者主键扫描</li><li><code>ref</code>：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体</li><li><code>range</code>：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是where语句中出现了between,in等范围的查询。这种范围扫描索引扫描比全表扫描要好，因为它开始于索引的某一个点，而结束另一个点，不用全表扫描</li><li><code>index</code>：index 与all区别为index类型只遍历索引树。通常比all快，因为索引文件比数据文件小很多。</li><li><code>all</code>：遍历全表以找到匹配的行</li><li>从好到坏的顺序一次是：<code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</code></li></ul></li><li>possible_keys<br>查询可能使用到的索引都会在这里列出来</li><li>key<br>查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。</li><li>key_len<br>表示索引中使用的字节数，该列计算查询中使用的索引的长度在不损失精度的情况下，长度越短越好。如果键是NULL,则长度为NULL。该字段显示为索引字段的最大可能长度，并非实际使用长度。</li><li>ref<br>显示索引的哪一列被使用了，如果有可能是一个常数，哪些列或常量被用于查询索引列上的值</li><li>rows<br>根据表统计信息以及索引选用情况，大致估算出找到所需的记录所需要读取的行数</li><li>filtered<br>查询条件过滤的行数的百分比</li><li>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容<ul><li><code>distinct</code>：在select部分使用了distinct关键字</li><li><code>Using filesort</code>：当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li><li><code>Using index</code>：”覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错<ul><li><code>Using temporary</code>：查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中一条SELECT语句是如何执行的</title>
      <link href="/2020/04/17/MySQL%E4%B8%AD%E4%B8%80%E6%9D%A1SELECT%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>/2020/04/17/MySQL%E4%B8%AD%E4%B8%80%E6%9D%A1SELECT%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>查询操作是关系数据库中使用最为频繁的操作，也是构成其他SQL语句（如DELETE、UPDATE）的基础。</p><a id="more"></a><p>查询操作是关系数据库中使用最为频繁的操作，也是构成其他SQL语句（如DELETE、UPDATE）的基础。</p><h5 id="SELECT语法如下"><a href="#SELECT语法如下" class="headerlink" title="SELECT语法如下"></a>SELECT语法如下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(5)SELECT DISTINCT &lt;select_list&gt;                     </span><br><span class="line"></span><br><span class="line">(1)FROM &lt;left_table&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; ON &lt;on_predicate&gt;</span><br><span class="line"></span><br><span class="line">(2)WHERE &lt;where_predicate&gt;</span><br><span class="line"></span><br><span class="line">(3)GROUP BY &lt;group_by_specification&gt;</span><br><span class="line"></span><br><span class="line">(4)HAVING &lt;having_predicate&gt;</span><br><span class="line"></span><br><span class="line">(6)ORDER BY &lt;order_by_list&gt;</span><br><span class="line"></span><br><span class="line">(7)LIMIT n, m</span><br></pre></td></tr></table></figure><h5 id="SELECT语句的处理过程"><a href="#SELECT语句的处理过程" class="headerlink" title="SELECT语句的处理过程"></a>SELECT语句的处理过程</h5><ul><li>FROM阶段</li><li>WHERE阶段</li><li>GROUP BY阶段</li><li>HAVING阶段</li><li>SELECT阶段</li><li>ORDER BY阶段</li><li>LIMIT阶段</li></ul><h5 id="FROM阶段"><a href="#FROM阶段" class="headerlink" title="FROM阶段"></a>FROM阶段</h5><p>一条查询的sql语句先执行的是FROM table负责把数据库的表文件加载到内存中去</p><h5 id="WHERE阶段"><a href="#WHERE阶段" class="headerlink" title="WHERE阶段"></a>WHERE阶段</h5><p>WHERE会把表中的数据进行过滤，取出符合条件的记录行，生成一张临时表</p><h5 id="GROUP-BY阶段"><a href="#GROUP-BY阶段" class="headerlink" title="GROUP BY阶段"></a>GROUP BY阶段</h5><p>GROUP BY阶段按照指定的列名切分成若干临时表</p><h5 id="HAVING阶段"><a href="#HAVING阶段" class="headerlink" title="HAVING阶段"></a>HAVING阶段</h5><p>该阶段根据HAVING子句中出现的谓词对虚拟表进行分组进行筛选</p><h5 id="SELECT阶段"><a href="#SELECT阶段" class="headerlink" title="SELECT阶段"></a>SELECT阶段</h5><p>这个阶段是投影的过程，处理SELECT子句提到的元素</p><ul><li>计算SELECT列表中的表达式</li><li>若有DISTINCT，则删除重复行</li></ul><h5 id="ORDER-BY阶段"><a href="#ORDER-BY阶段" class="headerlink" title="ORDER BY阶段"></a>ORDER BY阶段</h5><p>根据ORDER BY子句中指定的字段进行排序</p><h5 id="LIMIT阶段"><a href="#LIMIT阶段" class="headerlink" title="LIMIT阶段"></a>LIMIT阶段</h5><p>取出指定行的记录，产生临时表，并返回给查询用户</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中一条SQL到底是如何执行的</title>
      <link href="/2020/04/17/MySQL%E4%B8%AD%E4%B8%80%E6%9D%A1SQL%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
      <url>/2020/04/17/MySQL%E4%B8%AD%E4%B8%80%E6%9D%A1SQL%E5%88%B0%E5%BA%95%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>能够清楚的弄明白SQL的执行过程，知道每一个阶段做了什么事情，对于SQL调优是很有必要和帮助的。</p><a id="more"></a><p>能够清楚的弄明白SQL的执行过程，知道每一个阶段做了什么事情，对于SQL调优是很有必要和帮助的。</p><h5 id="MySQL执行一个查询的过程"><a href="#MySQL执行一个查询的过程" class="headerlink" title="MySQL执行一个查询的过程"></a>MySQL执行一个查询的过程</h5><p><img src="https://img-blog.csdnimg.cn/20190810210346986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图片来源于《高性能MySQL》pdf版。从图片中可以清楚的看到：</p><ul><li>客户端发送一条查询给服务器；</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段；</li><li>服务器段进行SQL解析、预处理，在优化器生成对应的执行计划；</li><li>mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li><li>将结果返回给客户端。</li></ul><h5 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h5><p>负责与客户端建立连接、获取权限、位置和管理连接。主要是<code>TCP握手</code>、<code>认证你的身份</code>、<code>获取权限</code>这三个环节。</p><h5 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h5><p>在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据。MySql 在执行查询时会先对查询缓存进行查询，是否之前执行过此查询，之前执行过的语句会以key-value形式，被直接缓存在内存当中key为语句，value是查询结果，查询后2种结果：</p><ol><li>查询缓存命中：直接返回结果（效率很高）</li><li>查询缓存未命中： 继续直行后面的阶段，执行完成后，执行结果会被存入查询缓存中</li><li><h5 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h5></li></ol><p>如果没有命中查询缓存，就要开始真正执行语句了。首先 Mysql 需要 知道你要执行什么，所以要对sql语句做解析</p><ul><li><p>词法分析</p><ul><li>你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”</li></ul></li><li><p>语法分析</p><ul><li>根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这SQL语句是否满足 MySQL 语法。如果你的语句不对，就会收到<code>“You have an erroin your SQL syntax”</code>的错误提醒。这个错误往往在我们写SQL出错的时候出现过，是不是很眼熟，哈哈哈。</li></ul></li></ul><h5 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h5><p>经过分析器之后，MySQL就知道你需要做什么，在执行之前还要经过优化器的处理。当语法树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的链接顺序等等。</p><h5 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h5><p>MySQL不会生成查询字节码来执行查询，MySQL生成查询的一棵指令树，然后通过存储引擎执行完成这棵指令树并返回结果。最终的执行计划包含了重构查询的全部信息。</p><p>执行语句需要：</p><ul><li>判断你是否有查询权限有就继续执行没有就返回权限错误</li><li>执行器根据表的引擎定义去掉用引擎接口（例：InnoDB）<ul><li>无索引：<br>调用innoDB引擎接口取出这个表的第一行，判断ID是否等于1，如果不是则跳过，如果是则将这行存在结果集中；调用引擎接口取 ‘下一行’ 执行相同判断逻辑，直到取到表的最后一行<br>执行器将所有满足条件的行 组成的记录作为结果集返回给客户端</li><li>有索引<br>与无索引逻辑差不多，第一次调用的是“取满足条件的第一行”这个接口，之后循环的是“满足条件的下一行”这个几口，接口在引擎中已经定义好。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引使用策略和优化</title>
      <link href="/2020/04/17/MySQL%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E5%92%8C%E4%BC%98%E5%8C%96/"/>
      <url>/2020/04/17/MySQL%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E5%92%8C%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>在前面的文章里，我们介绍了MySQL索引的原理。那么在实际开发中，应该如何去使用索引以及如何去优化呢？</p><a id="more"></a><p>在前面的文章里，我们介绍了MySQL索引的原理。那么在实际开发中，应该如何去使用索引以及如何去优化呢？</p><h5 id="什么时候不应该使用索引？"><a href="#什么时候不应该使用索引？" class="headerlink" title="什么时候不应该使用索引？"></a>什么时候不应该使用索引？</h5><p>索引并不都是有效的。有些场合，可能我们并不需要使用索引，甚至使用了索引反而会影响性能。</p><ul><li>查询很少用到的列</li></ul><p>如果某些列在查询时很少用到，那加不加索引的速度其实是差不多的。而增加索引会增加系统维护索引的开销，所以不值得创建索引。</p><ul><li>表的数据量很少</li></ul><p>如果在测试数据库里只有几百条数据记录，它们往往在执行完第一条查询命令之后就被全部加载到内存里，这将使后续的查询命令都执行得非常快，不管有没有使用索引。只有当数据库里的记录超过了1000条、数据总量也超过了MySQL服务器上的内存总量时，数据库的性能测试结果才有意义。</p><ul><li>列的取值范围太小</li></ul><p>列的取值范围太小，比如“性别”列。本来查询的结果集合占表中的数据行很大的比例，相当于全表查询了，所以没有必要建立索引。</p><ul><li>有大量重复的列</li></ul><p>这个其实跟上述条件类似。如果有某列在很多行数据里都有重复值，那不管是不是用索引，查询出来的结果集合都会占全表中的数据行很大的比例，所以也不需要建立索引。</p><ul><li>读少写多的场景</li></ul><p>由于索引会降低写的性能，增加读的性能。所以并不适合读少写多的场景。创建和维护索引是需要消耗系统资源的，所以不适合使用索引。</p><h5 id="什么时候应该使用索引？"><a href="#什么时候应该使用索引？" class="headerlink" title="什么时候应该使用索引？"></a>什么时候应该使用索引？</h5><ul><li>主键</li></ul><p>主键会自动建立“主键”索引，它也是一个唯一索引。</p><ul><li>作为查询和排序条件的列</li></ul><p>经常作为查询条件在<code>WHERE</code>或者<code>ORDER BY</code>语句中出现的列要建立索引。同理，作为排序的列也应该建立索引。从前面的文章中我们知道，基于BTree及其变种的引擎在排序时，使用基于索引的排序会大大提升性能。</p><ul><li>外键</li></ul><p>与其它表的关联字段，往往会经常在查询中用到，所以也建议使用索引。</p><ul><li>聚合函数用到的列</li></ul><p>用于聚合函数的列可以建立索引，例如使用了<code>max(column_1)</code>或者<code>count(column_1)</code>时的<code>column_1</code>列就需要建立索引。</p><h5 id="什么时候索引会失效？"><a href="#什么时候索引会失效？" class="headerlink" title="什么时候索引会失效？"></a>什么时候索引会失效？</h5><p>建立索引后，如果不注意索引的原理，有时候查询可能会不能使用索引。下面列出一些常见的索引失效的场景。</p><ul><li>组合索引中的NULL</li></ul><p>在组合索引（即多列索引）中不能有列的值为NULL，如果有，那么这一列对组合索引就是无效的。</p><ul><li>一个查询只使用一次</li></ul><p>在一个SELECT语句中，一个索引只能使用一次。比如如果在WHERE中使用了，那么在ORDER BY中就不会再使用了。</p><ul><li>LIKE操作</li></ul><p>LIKE操作中，’%xxx%’不会使用索引，也就是索引会失效，但是’xxx%’可以使用索引。</p><ul><li>OR连接多个条件</li></ul><p>在查询条件中使用<code>OR</code>连接多个条件会导致索引失效，除非<code>OR</code>连接的每个条件都加上索引，这时应该改为多次查询，然后用<code>UNION ALL</code>连接起来。</p><ul><li>使用表达式或者函数</li></ul><p>使用MySQL内部函数导致索引失效，对于这样情况应当创建基于函数的索引。比如：</p><p><img src="https://img-blog.csdnimg.cn/20190804165931974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>结果集太大</li></ul><p>如果MySQL估计使用全表扫描要比使用索引快,则不使用索引。MySQL会使用一个叫基于数据访问路径的CBO成本计算模型来估计它。</p><ul><li>多个范围查询</li></ul><p>对于范围条件查询，MySQL无法再使用范围列后面的其它索引列了。但是对于“多个等值条件查询”则没有这个限制。这里有一个小技巧，如果范围不大，可以使用IN来代替。如下代码：</p><p><img src="https://img-blog.csdnimg.cn/20190804170020171.png" alt="在这里插入图片描述"></p><h5 id="索引的优化"><a href="#索引的优化" class="headerlink" title="索引的优化"></a>索引的优化</h5><ul><li>最左前缀</li></ul><p>索引的最左前缀和和B+Tree中的“最左前缀原理”有关，举例来说，如果设置了组合索引<code>col1,col2,col3</code>那么以下3中情况可以使用索引：<code>col1</code>，<code>col1,col2</code>，<code>col1,col2,col3</code>，其他情况都是不能使用索引的。</p><p>根据最左前缀原则，我们一般把<code>排序分组频率最高的列放在最左边</code>，以此类推。</p><ul><li>模糊查询优化</li></ul><p>在上面已经提到，使用LIKE进行模糊查询的时候，’%aaa%’不会使用索引，也就是索引会失效。如果是这种情况，只能使用全文索引来进行优化。之前的文章也提到了，目前版本的MySQL InnoDB引擎已经支持全文索引，但不支持中文，可以通过使用ngram插件开始支持中文。</p><p>使用全文索引后，相应的查询语句也需要修改，不再是<code>WHERE</code>了，而是全文索引查询的关键字<code>MATCH</code>和<code>ANGAINST</code>。</p><ul><li>使用短索引</li></ul><p>对字符串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20 个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。</p><h5 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h5><p>《高性能MySQL》</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中常用的存储引擎</title>
      <link href="/2020/04/17/MySQL%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2020/04/17/MySQL%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>什么是存储引擎？关系数据库表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时去很差；而我们在实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，也就是需要不同存储引擎。</p><a id="more"></a><h5 id="什么是存储引擎"><a href="#什么是存储引擎" class="headerlink" title="什么是存储引擎"></a>什么是存储引擎</h5><p>关系数据库表是用于存储和组织信息的数据结构，可以将表理解为由行和列组成的表格，类似于Excel的电子表格的形式。有的表简单，有的表复杂，有的表根本不用来存储任何长期的数据，有的表读取时非常快，但是插入数据时去很差；而我们在实际开发过程中，就可能需要各种各样的表，不同的表，就意味着存储不同类型的数据，也就是需要不同存储引擎。</p><h5 id="MySQL都有哪些存储引擎"><a href="#MySQL都有哪些存储引擎" class="headerlink" title="MySQL都有哪些存储引擎"></a>MySQL都有哪些存储引擎</h5><p><img src="https://img-blog.csdnimg.cn/20190803205115668.gif" alt="在这里插入图片描述"><br>可以看到，MySQL中一共有这么多存储引擎，但是实际开发中我们常用的只有<code>InnoDB</code>和<code>MyISAM</code>，如果想要看MySQL默认使用的引擎可以使用这个命令<code>SHOW VARIABLES LIKE &#39;storage_engine&#39;;</code>，MySQL5.5以后默认使用InnoDB存储引擎。</p><h5 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h5><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，而且InnoDB是默认的MySQL引擎。</p><ol><li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合。</li><li>InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的。</li><li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上。</li><li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键。</li><li>InnoDB被用在众多需要高性能的大型数据库站点上。<h4 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h4></li></ol><ul><li>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但<code>不支持事物</code></li><li>不支持行锁(MyISAM只有表锁)，读取时对需要读到的所有表加锁，写入时则对表加排他锁</li><li>不支持外键</li><li>不支持崩溃后的安全恢复</li><li>一般应用在如下情况：<ul><li>选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。 </li><li>插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。</li></ul></li></ul><h5 id="InnoDB和MyISAM对比"><a href="#InnoDB和MyISAM对比" class="headerlink" title="InnoDB和MyISAM对比"></a>InnoDB和MyISAM对比</h5><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>256TB</td></tr><tr><td>事物</td><td>支持</td><td></td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td></tr><tr><td>全文索引</td><td></td><td>支持</td></tr><tr><td>数据缓存</td><td>支持</td><td></td></tr><tr><td>空间使用</td><td>高</td><td>低</td></tr><tr><td>内存使用</td><td>高</td><td>低</td></tr><tr><td>支持外键</td><td>支持</td><td></td></tr><tr><td>关注点</td><td>事物</td><td>性能</td></tr></tbody></table><h5 id="如何选择合适的引擎"><a href="#如何选择合适的引擎" class="headerlink" title="如何选择合适的引擎"></a>如何选择合适的引擎</h5><p>其实这个很灵活，既然MySQL默认的引擎是InnoDB，也就说InnoDB能做你绝大多数想做的东西。其实选择合适的引擎只用考虑如下几点就好：</p><ul><li>事物</li><li>数据恢复</li><li>热备份</li><li>锁<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5>《高性能MySQL》</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL，InnoDB，MyISAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引原理</title>
      <link href="/2020/04/17/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
      <url>/2020/04/17/MySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>什么是索引？<br>“索引”是为了能够更快地查询数据。比如一本书的目录，就是这本书的内容的索引，读者可以通过在目录中快速查找自己想要的内容，然后根据页码去找到具体的章节。</p><a id="more"></a><h5 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h5><p>“索引”是为了能够更快地查询数据。比如一本书的目录，就是这本书的内容的索引，读者可以通过在目录中快速查找自己想要的内容，然后根据页码去找到具体的章节。</p><p>数据库也是一样，如果查询语句使用到了索引，会先去索引里面查询，取得数据所在行的物理地址，进而访问数据。</p><h5 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h5><ul><li>优势：以快速检索，减少I/O次数，加快检索速度；根据索引分组和排序，可以加快分组和排序。</li><li>劣势：索引本身也是表，因此会占用存储空间。索引的维护和创建需要时间成本，这个成本随着数据量增大而增大；构建索引会降低数据表的修改操作（删除，添加，修改）的效率，因为在修改数据表的同时还需要修改索引表。</li></ul><h5 id="索引的使用原则"><a href="#索引的使用原则" class="headerlink" title="索引的使用原则"></a>索引的使用原则</h5><ul><li>对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引，</li><li>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。</li><li>在一同值少的列上(字段上)不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</li></ul><h5 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h5><p>在MySQL中，常见的索引类型有：<code>主键索引</code>、<code>唯一索引</code>、<code>普通索引</code>、<code>全文索引</code>、<code>组合索引</code>。</p><p>创建语法分别为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#39;table_name&#39; ADD PRIMARY KEY pk_index(&#39;col&#39;);</span><br><span class="line">ALTER TABLE &#39;table_name&#39; ADD UNIQUE index_name(&#39;col&#39;);</span><br><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col&#39;);</span><br><span class="line">ALTER TABLE &#39;table_name&#39; ADD FULLTEXT INDEX ft_index(&#39;col&#39;);</span><br><span class="line">ALTER TABLE &#39;table_name&#39; ADD INDEX index_name(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;);</span><br></pre></td></tr></table></figure><p>其中，组合索引又称为多列索引，上述代码中最后一个例子就是建立了3列的索引。MySQL在根据索引查询时，会遵循<code>“最左匹配”</code>原则，即先根据<code>col1</code>的条件查，再根据<code>col2</code>的条件查，然后再根据<code>col3</code>的条件去查。</p><p>如果跳过了一个列直接查后面的列，比如下面的语句，就不能使用上面创建的索引了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE clo2&#x3D;2;</span><br></pre></td></tr></table></figure><blockquote><p>这里有一个小技巧，如果你前面的列是一个简单的枚举类型，比如性别等，可以用在where语句中加 col1 in(MALE, FEMALE) 来“跳过” col1 列，并使用上述索引。</p></blockquote><p>对于某列如果是字符串且比较长（比如UUID），推荐使用前缀索引，即匹配前n个字符。具体这个n取值多少是根据你的数据来的，<code>《高性能MySQL》</code>里提供了一个技巧：通过使用<code>LEFT</code>函数查询，从1开始，不断增加n的值，直到查询结果的行数接近完整列的查询结果的行数，就是合适的n的值。</p><p><img src="https://img-blog.csdnimg.cn/20190804162017624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a>索引的实现原理</h5><p>MySQL的索引是由<code>存储引擎</code>来实现的。由于存储引擎不同，所以具有不同的索引类型，如BTree索引，B+Tree索引，哈希索引，全文索引等。这里由于主要介绍BTree索引和B+Tree索引，我们平时使用最多的InnoDB引擎就是基于B+Tree索引的。</p><blockquote><p>目前版本的MySQL InnoDB引擎已经支持全文索引，但不支持中文，可以通过使用ngram插件开始支持中文。</p></blockquote><ul><li><p>从二叉搜索树聊起</p><ul><li><p>了解过数据结构的朋友应该知道一种叫二叉树的数据结构。二叉树根据用途不同，衍生了不同的变种，比如堆，比如二叉搜索树。</p></li><li><p>而二叉搜索树中，为了防止极端情况树的高度过大影响查询效率，所以衍生出了一些平衡二叉查找树，最典型的就是AVL和红黑树。</p></li><li><p>但二叉树在数据量较大时，深度过深，不太适合数据库的查询，所以数据库使用了多叉树。</p></li></ul></li><li><p>BTree</p></li></ul><p>BTree（又称为B-Tree）是一个<code>平衡搜索多叉树</code>。BTree的结构如下图：<br><img src="https://img-blog.csdnimg.cn/2019080416225064.png" alt="在这里插入图片描述"><br>设树的度为2d（d&gt;1），高度为h，那么BTree有以下性质：</p><pre><code>1.每个叶子结点的高度一样，等于h；2.每个非叶子结点由n-1个key和n个指针组成，key和指针相互隔离，结点两端一定是key3.叶子结点指针为null；4.非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的其它列的数据；</code></pre><p>在BTree中，对索引列是顺序存储的，所以很适合查找范围数据和<code>ORDER BY</code>操作。</p><ul><li>B+Tree</li></ul><p>B+Tree是BTree的一种变种。B+Tree和BTree的不同主要在于：</p><pre><code>1.B+Tree中的非叶子结点不存储数据，只存储键值；2.B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；3.B+Tree的每个非叶子节点由n个键值key和n个指针point组成；</code></pre><p>结构图：</p><p><img src="https://img-blog.csdnimg.cn/20190804163412461.png" alt="在这里插入图片描述"></p><ul><li>B+Tree对比BTree的优点</li></ul><p>一般来说B+Tree比BTree更适合实现外存的索引结构，因为存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构。</p><p>磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找。</p><p>已知内存的读取速度是外存读取I/O速度的几百倍，那么提升查找速度的关键就在于尽可能少的磁盘I/O，那么可以知道，每个节点中的key个数越多，那么树的高度越小，需要I/O的次数越少，因此一般来说B+Tree比BTree更快，因为B+Tree的非叶节点中不存储data，就可以存储更多的key。</p><h5 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h5><p>MySQL中最常见的两种存储引擎分别是<code>MyISAM</code>和<code>InnoDB</code>，分别实现了非聚簇索引和聚簇索引。</p><p>前段时间看到一个问题：“你知道为什么InnoDB非主键索引普遍比主键索引要慢吗？”答案是InnoDB使用了聚簇索引，主键索引主需要查询一次，而非主键索引需要查询两次。</p><p>为什么非主键索引需要查询两次呢？且看接下来的内容。</p><ul><li>主索引与辅助索引</li></ul><p>首先介绍一下基础的概念。在索引的分类中，我们可以按照索引的键是否为主键来分为“主索引”和“辅助索引”，使用主键键值建立的索引称为“主索引”，其它的称为“辅助索引”。因此主索引只能有一个，辅助索引可以有很多个。</p><p>为什么需要用到辅助索引？因为前面我们介绍了，查询语句如果想要使用索引，是需要满足<code>最左匹配</code>原则的。有时候我们的查询并不会使用到主键列，所以需要在其它列建立索引，即辅助索引。</p><ul><li>非聚簇索引</li></ul><p>非聚簇索引的主索引和辅助索引几乎是一样的，只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。</p><p>非聚簇索引的数据表和索引表是分开存储的。非聚簇索引中的数据是根据数据的插入顺序保存。因此非聚簇索引更适合<code>单个数据</code>的查询。插入顺序不受键值影响。</p><ul><li>聚簇索引</li></ul><p>聚簇索引的主索引的叶子结点存储的是键值对应的数据本身，辅助索引的叶子结点存储的是<code>键值对应的数据的主键</code>键值。因此主键的值长度越小越好，类型越简单越好。</p><p>聚簇索引的数据和主键索引存储在一起。</p><p>聚簇索引的数据是根据主键的顺序保存。因此适合按主键索引的区间查找，可以有更少的磁盘I/O，加快查询速度。但是也是因为这个原因，聚簇索引的插入顺序最好按照主键单调的顺序插入，否则会频繁的引起页分裂（BTree插入时的一个操作），严重影响性能。</p><p>在InnoDB中，如果只需要查找索引的列，就尽量不要加入其它的列，这样会提高查询效率。</p><p>一张图说明聚簇索引与非聚簇索引的区别：</p><p><img src="https://img-blog.csdnimg.cn/20190804163842406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>《高性能MySQL》</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring中涉及的设计模式总结</title>
      <link href="/2020/04/17/Spring%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/17/Spring%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>这篇文章主要整理了Spring中的9种设计模式。</p><a id="more"></a><p>原文地址：<a href="https://blog.csdn.net/caoxiaohong1005/article/details/80039656" target="_blank" rel="noopener">https://blog.csdn.net/caoxiaohong1005/article/details/80039656</a></p><h5 id="1-简单工厂"><a href="#1-简单工厂" class="headerlink" title="1.简单工厂"></a>1.简单工厂</h5><ul><li><p>实现方式：</p><ul><li><strong>BeanFactory</strong>。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得Bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。</li></ul></li><li><p>实质：</p><ul><li>由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</li></ul></li><li><p>实现原理：</p><ul><li>bean容器的启动阶段：<ul><li>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。</li><li>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。</li><li>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的切口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。<br>典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。</li></ul></li><li>容器中bean的实例化阶段：<ul><li>实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：</li><li>各种的Aware接口，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。</li><li>BeanPostProcessor接口，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。</li><li>InitializingBean接口，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。</li><li>DisposableBean接口，实现了BeanPostProcessor接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。</li></ul></li><li>设计意义：<ul><li>松耦合。可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.</li><li>bean的额外处理。通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。<strong>[非常重要]</strong></li></ul></li></ul></li></ul><h5 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2.工厂方法"></a>2.工厂方法</h5><ul><li>实现方式：<ul><li>FactoryBean接口。</li></ul></li><li>实现原理：<ul><li>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以<strong>返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</strong></li></ul></li><li>例子：<ul><li>典型的例子有spring与mybatis的结合。</li><li>代码示例：<br><img src="https://img-blog.csdnimg.cn/20200316145547933.png" alt="在这里插入图片描述"></li></ul></li><li>说明：<br>我们看上面该bean，因为实现了FactoryBean接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是它的 SqlSessionFactoryBean.getObject() 的返回值。</li></ul><h5 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h5><ul><li>Spring依赖注入Bean实例默认是单例的。</li><li>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</li><li>分析getSingleton()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Object getSingleton(String beanName)&#123;</span><br><span class="line">    &#x2F;&#x2F;参数true设置标识允许早期依赖</span><br><span class="line">    return getSingleton(beanName,true);</span><br><span class="line">&#125;</span><br><span class="line">protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123;</span><br><span class="line">    &#x2F;&#x2F;检查缓存中是否存在实例</span><br><span class="line">    Object singletonObject &#x3D; this.singletonObjects.get(beanName);</span><br><span class="line">    if (singletonObject &#x3D;&#x3D; null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        &#x2F;&#x2F;如果为空，则锁定全局变量并进行处理。</span><br><span class="line">        synchronized (this.singletonObjects) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果此bean正在加载，则不处理</span><br><span class="line">            singletonObject &#x3D; this.earlySingletonObjects.get(beanName);</span><br><span class="line">            if (singletonObject &#x3D;&#x3D; null &amp;&amp; allowEarlyReference) &#123;  </span><br><span class="line">                &#x2F;&#x2F;当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory &#x3D; this.singletonFactories.get(beanName);</span><br><span class="line">                if (singletonFactory !&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F;调用预先设定的getObject方法</span><br><span class="line">                    singletonObject &#x3D; singletonFactory.getObject();</span><br><span class="line">                    &#x2F;&#x2F;记录在缓存中，earlysingletonObjects和singletonFactories互斥</span><br><span class="line">                    this.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    this.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>getSingleton()过程图<br>ps：spring依赖注入时，使用了 双重判断加锁 的单例模式<br><img src="https://img-blog.csdnimg.cn/20200316145710790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>总结<ul><li>单例模式定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li><li>spring对单例的实现：spring中的单例模式完成了后半句话，即提供了全局的访问点 BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</li></ul></li></ul><h5 id="4-适配器模式"><a href="#4-适配器模式" class="headerlink" title="4.适配器模式"></a>4.适配器模式</h5><ul><li>实现方式：<ul><li>SpringMVC中的适配器HandlerAdatper。</li></ul></li><li>实现原理：<ul><li>HandlerAdatper根据Handler规则执行不同的Handler。</li></ul></li><li>实现过程：<ul><li>DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。</li><li>HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。</li></ul></li><li>实现意义：<ul><li>HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</li></ul></li></ul><h5 id="5-装饰器模式"><a href="#5-装饰器模式" class="headerlink" title="5.装饰器模式"></a>5.装饰器模式</h5><ul><li>实现方式：<ul><li>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</li></ul></li><li>实质：<ul><li>动态地给一个对象添加一些额外的职责。</li><li>就增加功能来说，Decorator模式相比生成子类更为灵活。</li></ul></li></ul><h5 id="6-代理模式"><a href="#6-代理模式" class="headerlink" title="6.代理模式"></a>6.代理模式</h5><ul><li><p>实现方式：</p><ul><li>AOP底层，就是动态代理模式的实现。</li></ul></li><li><p>动态代理：</p><ul><li>在内存中构建的，不需要手动编写代理类</li></ul></li><li><p>静态代理：</p><ul><li>需要手工编写代理类，代理类引用被代理对象。</li></ul></li><li><p>实现原理：</p><ul><li><p>切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。</p><p>  <code>织入：把切面应用到目标对象并创建新的代理对象的过程。</code></p></li></ul></li></ul><h5 id="7-观察者模式"><a href="#7-观察者模式" class="headerlink" title="7.观察者模式"></a>7.观察者模式</h5><ul><li><p>实现方式：</p><ul><li>Spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</li></ul></li><li><p>具体实现：<code>事件机制的实现需要三个部分,事件源,事件,事件监听器</code></p><ul><li><p>ApplicationEvent抽象类[事件]</p><ul><li><p>继承自jdk的EventObject,所有的事件都需要继承ApplicationEvent,并且通过构造器参数source得到事件源.</p></li><li><p>该类的实现类ApplicationContextEvent表示ApplicaitonContext的容器事件.</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ApplicationEvent extends EventObject &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 7099057708183571937L;</span><br><span class="line">    private final long timestamp;</span><br><span class="line">    public ApplicationEvent(Object source) &#123;</span><br><span class="line">    super(source);</span><br><span class="line">    this.timestamp &#x3D; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    public final long getTimestamp() &#123;</span><br><span class="line">        return this.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ApplicationListener接口[事件监听器]</p><ul><li><p>继承自jdk的EventListener,所有的监听器都要实现这个接口。</p></li><li><p>这个接口只有一个onApplicationEvent()方法,该方法接受一个ApplicationEvent或其子类对象作为参数,在方法体中,可以通过不同对Event类的判断来进行相应的处理。</p></li><li><p>当事件触发时所有的监听器都会收到消息。</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;</span><br><span class="line">     void onApplicationEvent(E event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ApplicationContext接口[事件源]</p><ul><li><p>ApplicationContext是spring中的全局容器，翻译过来是”应用上下文”。</p></li><li><p>实现了ApplicationEventPublisher接口。</p></li><li><p>职责：</p><ul><li><p>负责读取bean的配置文档,管理bean的加载,维护bean之间的依赖关系,可以说是负责bean的整个生命周期,再通俗一点就是我们平时所说的IOC容器。</p></li><li><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ApplicationEventPublisher &#123;</span><br><span class="line">        void publishEvent(ApplicationEvent event);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">public void publishEvent(ApplicationEvent event) &#123;</span><br><span class="line">    Assert.notNull(event, &quot;Event must not be null&quot;);</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(&quot;Publishing event in &quot; + getDisplayName() + &quot;: &quot; + event);</span><br><span class="line">    &#125;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(event);</span><br><span class="line">    if (this.parent !&#x3D; null) &#123;</span><br><span class="line">    this.parent.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>ApplicationEventMulticaster抽象类[事件源中publishEvent方法需要调用其方法getApplicationEventMulticaster]</p><ul><li>属于事件广播器,它的作用是把Applicationcontext发布的Event广播给所有的监听器.</li><li>代码：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractApplicationContext extends DefaultResourceLoader</span><br><span class="line">    implements ConfigurableApplicationContext, DisposableBean &#123;  </span><br><span class="line">    private ApplicationEventMulticaster applicationEventMulticaster;  </span><br><span class="line">    protected void registerListeners() &#123;  </span><br><span class="line">    &#x2F;&#x2F; Register statically specified listeners first.  </span><br><span class="line">    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;  </span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#x2F;&#x2F; Do not initialize FactoryBeans here: We need to leave all regular beans  </span><br><span class="line">    &#x2F;&#x2F; uninitialized to let post-processors apply to them!  </span><br><span class="line">    String[] listenerBeanNames &#x3D; getBeanNamesForType(ApplicationListener.class, true, false);  </span><br><span class="line">    for (String lisName : listenerBeanNames) &#123;  </span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(lisName);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h5 id="8-策略模式"><a href="#8-策略模式" class="headerlink" title="8.策略模式"></a>8.策略模式</h5><ul><li><p>实现方式：</p><ul><li>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</li></ul></li><li><p>Resource 接口介绍</p><ul><li><p>source 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。</p></li><li><p>Resource 接口主要提供了如下几个方法:</p><ul><li><p>getInputStream()：定位并打开资源，返回资源对应的输入流。每次调用都返回新的输入流。调用者必须负责关闭输入流。</p></li><li><p>exists()：返回 Resource 所指向的资源是否存在。</p></li><li><p>isOpen()：返回资源文件是否打开，如果资源文件不能多次读取，每次读取结束应该显式关闭，以防止资源泄漏。</p></li><li><p>getDescription()：返回资源的描述信息，通常用于资源处理出错时输出该信息，通常是全限定文件名或实际 URL。</p></li><li><p>getFile：返回资源对应的 File 对象。</p></li><li><p>getURL：返回资源对应的 URL 对象。<br><code>最后两个方法通常无须使用，仅在通过简单方式访问无法实现时，Resource 提供传统的资源访问的功能。</code></p></li><li><p>Resource 接口本身没有提供访问任何底层资源的实现逻辑，针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑。</p></li><li><p>Spring 为 Resource 接口提供了如下实现类：</p></li><li><p>UrlResource：访问网络资源的实现类。</p></li><li><p>ClassPathResource：访问类加载路径里资源的实现类。</p></li><li><p>FileSystemResource：访问文件系统里资源的实现类。</p></li><li><p>ServletContextResource：访问相对于 ServletContext 路径里的资源的实现类.</p></li><li><p>InputStreamResource：访问输入流资源的实现类。</p></li><li><p>ByteArrayResource：访问字节数组资源的实现类。<br><code>这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</code></p></li></ul></li></ul></li></ul><h5 id="9-模版方法模式"><a href="#9-模版方法模式" class="headerlink" title="9.模版方法模式"></a>9.模版方法模式</h5><ul><li><p>经典模板方法定义：</p><ul><li>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。</li><li>最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。</li><li>所以父类模板方法中有两类方法：<ul><li>共同的方法：所有子类都会用到的代码</li><li>不同的方法：子类要覆盖的方法，分为两种：<ul><li>抽象方法：父类中的是抽象方法，子类必须覆盖</li><li>钩子方法：父类中是一个空方法，子类继承了默认也是空的<br><code>注：为什么叫钩子，子类可以通过这个钩子（方法），控制父类，因为这个钩子实际是父类的方法（空方法）！</code></li></ul></li></ul></li></ul></li><li><p>Spring模板方法模式实质：<br><code>是模板方法模式和回调模式的结合</code>，是Template Method不需要继承的另一种实现方式。Spring几乎所有的外接扩展都采用这种模式。</p></li><li><p>具体实现：</p><ul><li><p>JDBC的抽象和对Hibernate的集成，都采用了一种理念或者处理方式，那就是模板方法模式与相应的Callback接口相结合。</p></li><li><p>采用模板方法模式是为了以一种统一而集中的方式来处理资源的获取和释放，以JdbcTempalte为例:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class JdbcTemplate &#123;  </span><br><span class="line">     public final Object execute（String sql）&#123;  </span><br><span class="line">        Connection con&#x3D;null;  </span><br><span class="line">        Statement stmt&#x3D;null;  </span><br><span class="line">        try&#123;  </span><br><span class="line">            con&#x3D;getConnection（）;  </span><br><span class="line">            stmt&#x3D;con.createStatement（）;  </span><br><span class="line">            Object retValue&#x3D;executeWithStatement（stmt,sql）;  </span><br><span class="line">            return retValue;  </span><br><span class="line">        &#125;catch（SQLException e）&#123;  </span><br><span class="line">             ...  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    protected abstract Object executeWithStatement（Statement   stmt, String sql）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>引入回调原因：</p><ul><li><p>JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。</p></li><li><p>回调代码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface StatementCallback&#123;  </span><br><span class="line">    Object doWithStatement（Statement stmt）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用回调方法重写JdbcTemplate方法</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcTemplate &#123;  </span><br><span class="line">    public final Object execute（StatementCallback callback）&#123;  </span><br><span class="line">        Connection con&#x3D;null;  </span><br><span class="line">        Statement stmt&#x3D;null;  </span><br><span class="line">        try&#123;  </span><br><span class="line">            con&#x3D;getConnection（）;  </span><br><span class="line">            stmt&#x3D;con.createStatement（）;  </span><br><span class="line">            Object retValue&#x3D;callback.doWithStatement（stmt）;  </span><br><span class="line">            return retValue;  </span><br><span class="line">        &#125;catch（SQLException e）&#123;  </span><br><span class="line">            ...  </span><br><span class="line">        &#125;finally&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ...&#x2F;&#x2F;其它方法定义  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- Jdbc使用方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate&#x3D;...;  </span><br><span class="line">    final String sql&#x3D;...;  </span><br><span class="line">    StatementCallback callback&#x3D;new StatementCallback()&#123;  </span><br><span class="line">    public Object&#x3D;doWithStatement(Statement stmt)&#123;  </span><br><span class="line">        return ...;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">jdbcTemplate.execute(callback);</span><br></pre></td></tr></table></figure></code></pre><ul><li>为什么JdbcTemplate没有使用继承？</li></ul><p>因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？<br>那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结</title>
      <link href="/2020/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>从18年10月份开始学习设计模式，到19年1月底才看完，这篇博文主要总结这个过程中我的收获和一些思考。</p><a id="more"></a><p>从18年10月份开始学习设计模式，到19年1月底才看完，这篇博文主要总结这个过程中我的收获和一些思考。</p><p><strong>我的收获</strong></p><ul><li>从刚开始接触Java就听说过设计模式，但是由于自己的能力有限，又觉得设计模式是一个很高大上的东西，所以一直都没有碰，这次有幸系统的学习了一遍设计模式。</li><li>在开发之前开始思考如何设计更合理了。可能在这之前并没有想过太多的设计相关的东西，只是想着快速实现并且不出现bug，并没有想着怎样设计才是更合理一点。</li><li>开始考虑系统的可扩展性了，毕竟总会改变。</li><li>在遇到问题后开始想有那个设计模式会适用这个场景。</li><li>对面向对象有了更深一步的了解。</li></ul><p><strong>面向对象的三大特性</strong></p><ul><li><code>封装（Encapsulation）</code><br>隐藏对象的具体实现细节，通过共有方法暴露对象的功能。内部结构可以自由修改，同时可对成员进行更加精确的控制 (比如在setter方法中加值合法判断)</li><li><code>继承（Inheritance）</code><br>使用已经存在的类作为基础类（父类），在此基础上建立新类（子类），子类既可复用父类的功能，也能进行扩展，从而实现代码复用。 另外Java是单继承的，可以通过接口和内部类实现多继承。但是有几点需要注意一下：<ul><li>子类拥有父类非private的属性与方法</li><li>构造方法只能调用，不能实现，子类默认调用父类的无参构造方法，<br>如果父类没有无参的构造方法，需要使用super显式调用！</li><li>慎用继承，要考虑是否需要从子类向父类进行向上转型！(转型要instanceof)</li></ul></li><li><code>多态（Polymorphism）</code><br>一个类实例的相同方法在不同的情形下有不同的表现形式。多态分为两种：方法重载和重写（主要描述父类和子类之前的多态）。</li></ul><p><strong>类与类间的关系</strong></p><ul><li>继承，实现，依赖，关联，聚合，组合</li><li>类的相关程度：继承 &lt; 实现 &lt; 依赖 &lt; 关联 &lt; 聚合 &lt; 组合</li><li>依次的UML类图标记<ul><li>继承<br><img src="https://img-blog.csdnimg.cn/20190128142710200.png" alt="在这里插入图片描述"></li><li>实现<br><img src="https://img-blog.csdnimg.cn/20190128142718189.png" alt="在这里插入图片描述"></li><li>依赖<br><img src="https://img-blog.csdnimg.cn/2019012814272875.png" alt="在这里插入图片描述"></li><li>关联<br><img src="https://img-blog.csdnimg.cn/20190128142741299.png" alt="在这里插入图片描述"></li><li>聚合<br><img src="https://img-blog.csdnimg.cn/20190128142755925.png" alt="在这里插入图片描述"></li><li>组合<br><img src="https://img-blog.csdnimg.cn/20190128142803824.png" alt="在这里插入图片描述"></li></ul></li></ul><p><strong><a href="https://blog.csdn.net/wangchengming1/article/details/83090643" target="_blank" rel="noopener">设计模式的六大原则</a></strong></p><ul><li>单一职责原则<br>每一个类应该专注于做一件事情。 即：高内聚，低耦合。</li><li>里氏替换原则<br>在任何父类出现的地方都可以用它的子类来替代。</li><li>依赖倒置原则<br>要依赖于抽象，不要依赖于具体实现。</li><li>接口隔离原则<br>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</li><li>迪米特法则<br>一个对象应当尽量少地与其他对象之间发生相互作用，使得系统功能模块相对独立。</li><li>开闭原则<br>一个对象对扩展开放，对修改关闭。即：对类的改动是通过增加代码进行的，而不是修改现有代码。</li></ul><p><strong>设计模式逐一攻破</strong></p><ul><li><a href="https://blog.csdn.net/wangchengming1/column/info/28877" target="_blank" rel="noopener">设计模式专栏</a></li><li><a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">github</a></li></ul><p>永远不要对学习失去兴趣。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式(Decorator Pattern)</title>
      <link href="/2020/04/17/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-Decorator-Pattern/"/>
      <url>/2020/04/17/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-Decorator-Pattern/</url>
      
        <content type="html"><![CDATA[<p>装饰模式定义官方定义：Attach additional responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative to subclassing for extending functionally. 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。</p><a id="more"></a><ul><li><p>装饰模式定义</p><ul><li>官方定义：Attach additional responsibilities to an object dynamically keeping the same interface. Decorators provide a flexible alternative to subclassing for extending functionally. 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。</li><li>自己的理解：1️⃣在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。2️⃣通常可以使用继承来实现功能的拓展，如果这些需要拓展的功能的种类很繁多，那么势必生成很多子类，增加系统的复杂性，这也是装饰器模式设计的初衷。3️⃣符合开闭原则：类应该对拓展开放，对修改关闭。</li></ul></li><li><p>装饰模式通用类图</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20190125115330605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>装饰模式主要有四个角色：</p><ul><li>Component是基类。通常是一个抽象类或者一个接口，定义了属性或者方法，方法的实现可以由子类实现或者自己实现。通常不会直接使用该类，而是通过继承该类来实现特定的功能，它约束了整个继承树的行为。比如说，如果Component代表人，即使通过装饰也不会使人变成别的动物。 </li><li>ConcreteComponent是Component的子类，实现了相应的方法，它充当了“被装饰者”的角色。 </li><li>Decorator也是Component的子类，它是装饰者共同实现的抽象类（也可以是接口）。比如说，Decorator代表衣服这一类装饰者，那么它的子类应该是T恤、裙子这样的具体的装饰者。 </li><li>ConcreteDecorator是Decorator的子类，是具体的装饰者，由于它同时也是Component的子类，因此它能方便地拓展Component的状态（比如添加新的方法）。每个装饰者都应该有一个实例变量用以保存某个Component的引用，这也是利用了组合的特性。在持有Component的引用后，由于其自身也是Component的子类，那么，相当于ConcreteDecorator包裹了Component，不但有Component的特性，同时自身也可以有别的特性，也就是所谓的装饰。</li></ul></li><li><p>装饰模式通用代码</p></li></ul><p>抽象构件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line"></span><br><span class="line">public abstract void operate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体构件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreateComponent extends Component&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operate() &#123;</span><br><span class="line">System.out.println(&quot;do something...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象装饰者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Decorator extends Component &#123;</span><br><span class="line"></span><br><span class="line">private Component component &#x3D; null;</span><br><span class="line"></span><br><span class="line">public Decorator(Component _component) &#123;</span><br><span class="line">this.component &#x3D; _component;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void operate() &#123;</span><br><span class="line">this.component.operate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体装饰类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteDecorator1 extends Decorator&#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecorator1(Component _component) &#123;</span><br><span class="line">super(_component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void method1() &#123;</span><br><span class="line">System.out.println(&quot;method1 装饰&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void operate() &#123;</span><br><span class="line">this.method1();</span><br><span class="line">super.operate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecorator2 extends Decorator&#123;</span><br><span class="line"></span><br><span class="line">public ConcreteDecorator2(Component _component) &#123;</span><br><span class="line">super(_component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void method2() &#123;</span><br><span class="line">System.out.println(&quot;method2 装饰&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void operate() &#123;</span><br><span class="line">this.method2();</span><br><span class="line">super.operate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] agrs) &#123;</span><br><span class="line"></span><br><span class="line">Component component &#x3D; new ConcreateComponent();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; first </span><br><span class="line">component &#x3D; new ConcreteDecorator1(component);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; second</span><br><span class="line">component &#x3D; new ConcreteDecorator2(component);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; run</span><br><span class="line">component.operate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>装饰模式实例类图</li></ul><p>装饰模式在Java中经常出现的地方就是JavaIO。提到JavaIO，脑海中就冒出了大量的类：InputStream、FileInputStream、BufferedInputStream……等。</p><p><img src="https://img-blog.csdnimg.cn/20190125130909837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>装饰模式实例代码<br>完成一个将读取到的英文字符全切换成大写的转换流。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public class ToUpperCaseInputStream extends FilterInputStream &#123;</span><br><span class="line"></span><br><span class="line">InputStream inputStream;</span><br><span class="line"></span><br><span class="line">protected ToUpperCaseInputStream(InputStream in) &#123;</span><br><span class="line">super(in);</span><br><span class="line">this.inputStream &#x3D; in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 读取单个字节</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> * @throws IOException</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public int read() throws IOException &#123;</span><br><span class="line">&#x2F;&#x2F; 获取父类读取的结果</span><br><span class="line">int result &#x3D; super.read();</span><br><span class="line">&#x2F;&#x2F; 如果读取到字符a,就抛出异常</span><br><span class="line">if (result &#x3D;&#x3D; &#39;a&#39;) &#123;</span><br><span class="line">throw new ToUpperException();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果等于-1,说明无内容</span><br><span class="line">&#x2F;&#x2F; 否则,将字节转成char,再将char转换成大写的后返回</span><br><span class="line">&#x2F;&#x2F; 返回值类型是int类型,这里返回一个字符会被自动转型</span><br><span class="line">return (result &#x3D;&#x3D; -1 ? result : Character.toUpperCase(Character.toChars(result)[0]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int read(byte[] b, int off, int len) throws IOException &#123;</span><br><span class="line">int result &#x3D; super.read(b, off, len);</span><br><span class="line">for (int i &#x3D; off; i &lt; off + result; i++) &#123;</span><br><span class="line">&#x2F;&#x2F; 将字节转成大写字符后再转成字节</span><br><span class="line">b[i] &#x3D; (byte) Character.toUpperCase((char) b[i]);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;***</span><br><span class="line"> * 这里是一个内部类,自定义异常</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ToUpperException extends IOException &#123;</span><br><span class="line">@Override</span><br><span class="line">public void printStackTrace() &#123;</span><br><span class="line">System.out.println(&quot;不好意思我遇到异常了,向上转型失败啦&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int result &#x3D; 0;</span><br><span class="line">InputStream inputStream &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">inputStream &#x3D; new ToUpperCaseInputStream(new BufferedInputStream(new FileInputStream(&quot;file path&quot;)));</span><br><span class="line"></span><br><span class="line">while ((result &#x3D; inputStream.read()) &gt;&#x3D; 0) &#123;</span><br><span class="line">System.out.print((char) result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">try &#123;</span><br><span class="line">inputStream.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>装饰模式总结<ul><li>装饰者模式可以非常的贴合六大原则之一的开闭原则。</li><li>继承虽然也可以实现扩展，但是继承的扩展需要已经扩展需求，在编译期扩展，而装饰者模式可以实现在运行期扩展。</li><li>使用装饰者模式,类的数量会增长很多，不能过度使用。</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式(Observer Pattern)</title>
      <link href="/2020/04/17/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-Observer-Pattern/"/>
      <url>/2020/04/17/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-Observer-Pattern/</url>
      
        <content type="html"><![CDATA[<p>观察者模式定义：Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 定义对象之间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><a id="more"></a><ul><li>观察者模式定义</li></ul><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 定义对象之间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><ul><li>观察者模式通用类图</li></ul><p><img src="https://img-blog.csdnimg.cn/20190124103852408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>通过上面的类图，我们可以看到观察模式主要有四个角色：</p><ul><li>Subject被观察者：定义被观察者必须实现的职责，它必须能够动态的增加、取消观察者。将attach、detach、notify是三个方法放在一个容器里，一般用Vector(之所以使用Vector而不使用List，是因为多线程操作时，Vector在是安全的，而List则是不安全的)，attach方法是向这个容器中添加观察者对象；detach方法是从容器中移除观察者对象；notify方法是依次调用观察者对象的对应方法。</li><li>Observer观察者：观察者角色一般是一个接口，它只有一个update方法，在被观察者状态发生变化时，这个方法就会被触发调用。</li><li>ConcreteSubject具体的被观察者：定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。</li><li>ConcreteObserver具体的观察者：每个观察者在接收到消息后的处理反应是不同的，每个观察者都有自己的处理逻辑。</li></ul></li><li><p>观察者模式通用代码</p></li></ul><p>被观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subject &#123;</span><br><span class="line"></span><br><span class="line">private Vector&lt;Observer&gt; obsVector &#x3D; new Vector&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">public void addObserver(Observer o) &#123;</span><br><span class="line">this.obsVector.add(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void delObserver(Observer o) &#123;</span><br><span class="line">this.obsVector.remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void notifyObserver() &#123;</span><br><span class="line">obsVector.forEach(i -&gt; &#123;</span><br><span class="line">i.update();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的被观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteSubject extends Subject &#123;</span><br><span class="line"></span><br><span class="line">public void doSth() &#123;</span><br><span class="line">super.notifyObserver();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line"></span><br><span class="line">void update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteObserver implements Observer&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void update() &#123;</span><br><span class="line">System.out.println(&quot;接收消息并处理&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">ConcreteSubject subject &#x3D; new ConcreteSubject();</span><br><span class="line"></span><br><span class="line">Observer obs &#x3D; new ConcreteObserver();</span><br><span class="line"></span><br><span class="line">subject.addObserver(obs);</span><br><span class="line"></span><br><span class="line">subject.doSth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>观察者模式实例类图</li></ul><p>施耐庵写的《水浒传》相信很多人都看过，其中吴用等人 <code>智取生辰纲</code> 这个故事让人印象深刻。故事情节是这样的：在路经黄泥岗时路遇一批贩枣客人，又有一人贩酒而来，而这群贩枣客就是晁盖、吴用等人假扮的，吴用等人假装卖枣稳住杨志等人，白胜扮卖酒汉引诱对方，吴用在杨志放松警惕时下药在瓢里，白胜夺来倒在桶里麻倒对方，智取生辰纲。那么在这个故事中<code>生辰纲就可以看作是被观察者，杨志等人就可以看作是观察者，晁盖、吴用也可以看作是观察者</code>。</p><p><img src="https://img-blog.csdnimg.cn/20190124115449714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>观察者模式实例代码<br>抽象被观察者</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 被观察者</span><br><span class="line"> * </span><br><span class="line"> * @author cm_wang</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class Subject &#123;</span><br><span class="line"></span><br><span class="line">private Vector&lt;Observer&gt; obsVector &#x3D; new Vector&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">public void addObserver(Observer o) &#123;</span><br><span class="line">this.obsVector.add(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void delObserver(Observer o) &#123;</span><br><span class="line">this.obsVector.remove(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void notifyObserver() &#123;</span><br><span class="line">obsVector.forEach(i -&gt; &#123;</span><br><span class="line">i.update();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 观察者</span><br><span class="line"> * </span><br><span class="line"> * @author cm_wang</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface Observer &#123;</span><br><span class="line"></span><br><span class="line">void update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的被观察者，也就是生辰纲</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class shengchengang extends Subject &#123;</span><br><span class="line"></span><br><span class="line">public void doSth() &#123;</span><br><span class="line">super.notifyObserver();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的观察者，也就是杨志等人，还有晁盖、吴用等人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class wuyong implements Observer&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void update() &#123;</span><br><span class="line">System.out.println(&quot;吴用等人假装卖枣稳住杨志等人&quot;);</span><br><span class="line">System.out.println(&quot;吴用在杨志放松警惕时下药在瓢里&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class baisheng implements Observer&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void update() &#123;</span><br><span class="line">System.out.println(&quot;白胜夺来倒在桶里麻倒对方&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class yangzhi implements Observer&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void update() &#123;</span><br><span class="line">System.out.println(&quot;杨志等人喝了带蒙汗药的酒，就只能眼睁睁的看晁盖、吴用等人拿走生辰纲&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体场景类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">shengchengang subject &#x3D; new shengchengang();</span><br><span class="line"></span><br><span class="line">Observer obs &#x3D; new yangzhi();</span><br><span class="line"></span><br><span class="line">Observer thief &#x3D; new wuyong();</span><br><span class="line"></span><br><span class="line">Observer thief1 &#x3D; new baisheng();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 吴用等人假装卖枣稳住杨志等人</span><br><span class="line">subject.addObserver(thief);</span><br><span class="line">&#x2F;&#x2F; 白胜夺来放有蒙汗药的瓢倒在桶里麻倒对方</span><br><span class="line">subject.addObserver(thief1);</span><br><span class="line">&#x2F;&#x2F; 杨志等人喝了带蒙汗药的酒</span><br><span class="line">subject.addObserver(obs);</span><br><span class="line"></span><br><span class="line">subject.doSth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">吴用等人假装卖枣稳住杨志等人</span><br><span class="line">吴用在杨志放松警惕时下药在瓢里</span><br><span class="line">白胜夺来倒在桶里麻倒对方</span><br><span class="line">杨志等人喝了带蒙汗药的酒，就只能眼睁睁的看晁盖、吴用等人拿走生辰纲</span><br></pre></td></tr></table></figure><ul><li>观察者模式的优点<ul><li>观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的。</li><li>观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。</li></ul></li><li>观察者模式的缺点<ul><li>由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式(Iterator Pattern)</title>
      <link href="/2020/04/17/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-Iterator-Pattern/"/>
      <url>/2020/04/17/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F-Iterator-Pattern/</url>
      
        <content type="html"><![CDATA[<p>迭代器模式定义<br>相比大家对迭代器并不陌生，我们常用的List，Map都有这个概念。迭代器模式的定义为：Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 提供一种方法访问一个容器对象中各个元素，而不是需要暴露该对象的内部细节。</p><a id="more"></a><ul><li><p>迭代器模式定义<br>相比大家对迭代器并不陌生，我们常用的List，Map都有这个概念。迭代器模式的定义为：Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 提供一种方法访问一个容器对象中各个元素，而不是需要暴露该对象的内部细节。</p></li><li><p>迭代器模式通用类图</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20181225151657987.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>根据上面的类图可以看到迭代器模式的四个角色：<ul><li>抽象容器：一般是一个接口，提供一个iterator()方法，例如java中的Collection接口，List接口，Set接口等。</li><li>具体容器：就是抽象容器的具体实现类，比如List接口的有序列表实现ArrayList，List接口的链表实现LinkList，Set接口的哈希列表的实现HashSet等。</li><li>抽象迭代器：定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法first()，取得下一个元素的方法next()，判断是否遍历结束的方法isDone()（或者叫hasNext()），移出当前对象的方法remove(),</li><li>迭代器实现：实现迭代器接口中定义的方法，完成集合的迭代。</li></ul></li><li>迭代器模式通用代码</li></ul><p>抽象迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line"></span><br><span class="line">public Object next();</span><br><span class="line"></span><br><span class="line">public boolean hasNext();</span><br><span class="line"></span><br><span class="line">public boolean remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体迭代器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteIterator implements Iterator &#123;</span><br><span class="line"></span><br><span class="line">private List list &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当前游标</span><br><span class="line">public int cursor &#x3D; 0;</span><br><span class="line"></span><br><span class="line">public ConcreteIterator(List list) &#123;</span><br><span class="line">this.list &#x3D; list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object next() &#123;</span><br><span class="line">Object obj &#x3D; null;</span><br><span class="line">if (this.hasNext()) &#123;</span><br><span class="line">obj &#x3D; this.list.get(cursor++);</span><br><span class="line">&#125;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean hasNext() &#123;</span><br><span class="line">if (cursor &#x3D;&#x3D; list.size()) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean remove() &#123;</span><br><span class="line">this.list.remove(this.cursor);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Aggregate &#123;</span><br><span class="line"></span><br><span class="line">public void add(Object obj);</span><br><span class="line"></span><br><span class="line">public void remove(Object obj);</span><br><span class="line"></span><br><span class="line">public Iterator iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteAggregate implements Aggregate &#123;</span><br><span class="line"></span><br><span class="line">private List list &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void add(Object obj) &#123;</span><br><span class="line">list.add(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Iterator iterator() &#123;</span><br><span class="line">return new ConcreteIterator(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void remove(Object obj) &#123;</span><br><span class="line">list.remove(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Aggregate ag &#x3D; new ConcreteAggregate();</span><br><span class="line">ag.add(&quot;小明&quot;);</span><br><span class="line">ag.add(&quot;小红&quot;);</span><br><span class="line">ag.add(&quot;小刚&quot;);</span><br><span class="line">Iterator it &#x3D; ag.iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">String str &#x3D; (String) it.next();</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>迭代器模式优缺点</p><ul><li>其实迭代器的核心思想是<code>将数据结构和操作数据结构的算法分离开</code>。</li><li>封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</li><li>可以提供多种遍历方式。</li></ul></li><li><p>迭代器模式适用场景</p></li></ul><p>其实在java中已经提供了一套完善的迭代器（Iterator），Collection、List、Set、Map等，这些集合都有自己的迭代器。我们不必要去手写迭代器，java自带的Iterator就已经满足需求了。说白了，正是因为集合和迭代器结合的太密切了，在实际开发中，我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。</p><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式(Strategy Pattern)</title>
      <link href="/2020/04/17/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern/"/>
      <url>/2020/04/17/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-Strategy-Pattern/</url>
      
        <content type="html"><![CDATA[<p>策略模式是一种比较简单的设计模式，也叫做政策模式，策略模式的核心就是面向对象的继承和多态机制。Define a family of algorithms, encapsulate each one, and make them interchangeable. 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p><a id="more"></a><ul><li><p>策略模式定义<br>策略模式是一种比较简单的设计模式，也叫做政策模式，策略模式的核心就是面向对象的继承和多态机制。Define a family of algorithms, encapsulate each one, and make them interchangeable. 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p></li><li><p>策略模式通用类图</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20181218152326385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>策略模式的三个角色：</p><ul><li>Context封装角色：起到承上启下的作用。屏蔽了高层模块对策略、算法的直接访问。</li><li>Strategy抽象策略角色：策略、算法的抽象，通常为借口，定义每个策略、算法必须有的方法和属性。</li><li>ConcreteStrategy具体策略角色：实现 Strategy抽象策略角色，包含具体的算法。</li></ul></li><li><p>策略模式通用代码<br>抽象策略借口</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">void sth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line"></span><br><span class="line">private Strategy strategy &#x3D; null;</span><br><span class="line"></span><br><span class="line">public Context(Strategy _strategy) &#123;</span><br><span class="line">this.strategy &#x3D; _strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 封装后的策略方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void doAnything() &#123;</span><br><span class="line">this.strategy.sth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体策略实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteStrategy1 implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sth() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;策略算法实现1。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategy2 implements Strategy&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void sth() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;策略算法实现2。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Strategy strategy &#x3D; new ConcreteStrategy1();</span><br><span class="line"></span><br><span class="line">Context context &#x3D; new Context(strategy);</span><br><span class="line"></span><br><span class="line">context.doAnything();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">策略算法实现1。。。</span><br></pre></td></tr></table></figure><p>实例我暂时没有想到太好的，所以套用一下书中的例子。</p><ul><li>策略模式实例代码</li></ul><p>抽象策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line"></span><br><span class="line">void operate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锦囊</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line"></span><br><span class="line">private Strategy strategy;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造函数，要你使用哪个妙计</span><br><span class="line">public Context(Strategy strategy) &#123;</span><br><span class="line">this.strategy &#x3D; strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setStrategy(Strategy strategy) &#123;</span><br><span class="line">this.strategy &#x3D; strategy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void operate() &#123;</span><br><span class="line">this.strategy.operate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体策略类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GivenGreenLight implements Strategy &#123;</span><br><span class="line">@Override</span><br><span class="line">public void operate() &#123;</span><br><span class="line">System.out.println(&quot;求吴国太开个绿灯，放行&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BlackEnemy implements Strategy &#123;</span><br><span class="line">@Override</span><br><span class="line">public void operate() &#123;</span><br><span class="line">System.out.println(&quot;孙夫人断后，挡住追兵&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BackDoor implements Strategy &#123;</span><br><span class="line">@Override</span><br><span class="line">public void operate() &#123;</span><br><span class="line">System.out.println(&quot;找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用类（周瑜）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Zhaoyun &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Context context;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------刚到吴国使用第一个锦囊---------------&quot;);</span><br><span class="line">context &#x3D; new Context(new BackDoor());</span><br><span class="line">context.operate();</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------刘备乐不思蜀使用第二个锦囊---------------&quot;);</span><br><span class="line">context.setStrategy(new GivenGreenLight());</span><br><span class="line">context.operate();</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;----------孙权的追兵来了，使用第三个锦囊---------------&quot;);</span><br><span class="line">context.setStrategy(new BlackEnemy());</span><br><span class="line">context.operate();</span><br><span class="line">System.out.println(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">----------刚到吴国使用第一个锦囊---------------</span><br><span class="line">找乔国老帮忙，让吴国太给孙权施加压力，使孙权不能杀刘备</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------刘备乐不思蜀使用第二个锦囊---------------</span><br><span class="line">求吴国太开个绿灯，放行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------孙权的追兵来了，使用第三个锦囊---------------</span><br><span class="line">孙夫人断后，挡住追兵</span><br></pre></td></tr></table></figure><ul><li>策略模式的优缺点<ul><li>策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换。</li><li>可扩展性强，增加一个新的策略对策略模式来说非常容易。</li><li>策略类过多的时候不易维护。</li></ul></li><li>策略模式使用场景<ul><li>当几个类的具体逻辑（算法）相同的时候，只在小部分地方有区别可以考虑策略模式。</li><li>有几种相似的行为（算法），客户端需要动态地决定使用哪一种，那么可以使用策略模式。</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式(Adapter Pattern)</title>
      <link href="/2020/04/17/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern/"/>
      <url>/2020/04/17/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern/</url>
      
        <content type="html"><![CDATA[<p>适配器模式定义：Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces. 将一个类的接口变换成客户端所期待的另一种接口，从而是原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><a id="more"></a><ul><li><p>适配器模式定义<br>Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces. 将一个类的接口变换成客户端所期待的另一种接口，从而是原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p></li><li><p>适配器模式通用类图</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20181219100653275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>适配器模式主要有三个角色：<ul><li>Target目标角色：该角色定义把其他类型转换为何种接口，也就是我们期望的接口。</li><li>Adapter适配器角色：通过包装一个需要适配的对象，把原接口转换成目标接口，主要通过继承或者类关联的方法实现。</li><li>Adaptee源角色：你想把某个对象转换成目标角色，这个对象就是源角色。源角色是已经存在的、运行良好的类或者对象，经过适配器角色的包装，就会成为一个新的对象。一句话来说就是需要适配的类或适配者类。</li></ul></li><li>适配器模式通用代码</li></ul><p>目标角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Target &#123;</span><br><span class="line"></span><br><span class="line">void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标角色的实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteTarget implements Target&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">System.out.println(&quot;this is ConcreteTarget&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Adaptee &#123;</span><br><span class="line"></span><br><span class="line">public void doSth() &#123;</span><br><span class="line">System.out.println(&quot;this is Adaptee&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器角色</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Adapter extends Adaptee implements Target&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line"></span><br><span class="line">super.doSth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Target target &#x3D; new ConcreteTarget();</span><br><span class="line">target.request();</span><br><span class="line">Target target1 &#x3D; new Adapter();</span><br><span class="line">target1.request();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>适配器模式实例<br>暂时想不到什么比较生动的例子，看过别人的文章都在用生活中充电器的例子。<a href="https://blog.csdn.net/zxt0601/article/details/52848004" target="_blank" rel="noopener">实例参考</a>，在此感谢分享。</li><li>适配器模式优点<ul><li>复用了现存的类，解决了现存类和复用环境要求不一致的问题。</li><li>将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式(Command Pattern)</title>
      <link href="/2020/04/17/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-Command-Pattern/"/>
      <url>/2020/04/17/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-Command-Pattern/</url>
      
        <content type="html"><![CDATA[<p>命令模式定义：命令模式是一个高内聚的模式。Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p><a id="more"></a><ul><li>命令模式定义</li></ul><p>命令模式是一个高内聚的模式。Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. 将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p><ul><li><p>命令模式通用类图<br><img src="https://img-blog.csdnimg.cn/20181209131005770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>命令模式五个主要角色</p><ul><li>Command类：是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个execute方法用来执行命令。</li><li>ConcreteCommand类：Command类的实现类，对抽象类中声明的方法进行实现。</li><li>Invoker类：调用者，负责调用命令。</li><li>Receiver类：接收者，负责接收命令并且执行命令。</li><li>Client类：最终的客户端调用类。</li></ul></li><li><p>命令模式通用代码</p></li></ul><p>通用Receiver</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Receiver &#123;</span><br><span class="line"></span><br><span class="line">public abstract void dth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的接受者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteReceiver1 extends Receiver&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void dth() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteReceiver2 extends Receiver&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void dth() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象Command类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Command &#123;</span><br><span class="line"></span><br><span class="line">public abstract void execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体Command类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteCommand1 extends Command &#123;</span><br><span class="line"></span><br><span class="line">private Receiver receiver;</span><br><span class="line"></span><br><span class="line">public ConcreteCommand1(Receiver _receiver) &#123;</span><br><span class="line">this.receiver &#x3D; _receiver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void execute() &#123;</span><br><span class="line">this.receiver.dth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteCommand2 extends Command &#123;</span><br><span class="line"></span><br><span class="line">private Receiver receiver;</span><br><span class="line"></span><br><span class="line">public ConcreteCommand2(Receiver _receiver) &#123;</span><br><span class="line">this.receiver &#x3D; _receiver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void execute() &#123;</span><br><span class="line">this.receiver.dth();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Invoker类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Invoker &#123;</span><br><span class="line"></span><br><span class="line">private Command command;</span><br><span class="line"></span><br><span class="line">public void setCommand(Command _command) &#123;</span><br><span class="line">this.command &#x3D; _command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void action() &#123;</span><br><span class="line">this.command.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用场景类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Receiver receiver &#x3D; new ConcreteReceiver1();</span><br><span class="line"></span><br><span class="line">Command command &#x3D; new ConcreteCommand1(receiver);</span><br><span class="line"></span><br><span class="line">Invoker invoker &#x3D; new Invoker();</span><br><span class="line"></span><br><span class="line">invoker.setCommand(command);</span><br><span class="line"></span><br><span class="line">invoker.action();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上代码可以这样子理解：命令模式本质就是对命令的封装，把一系列的操作写到一个方法中，然后供客户端调用就行了。命令模式的执行步骤应该是这样的：首先是调用者类，然后是命令类，最后是接收者类。命令模式的精髓就是：<strong><code>把命令的调用者与执行者分开，使双方不必关心对方是如何操作的</code></strong>。</p><ul><li>命令模式实例类图</li></ul><p>其实在实际生活中有很多例子可以体现命令模式，笔者今天以小王去饭店吃饭这个例子，用命令模式实现以下。</p><p><img src="https://img-blog.csdnimg.cn/20181209141937235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>首先小王来到饭店，看完菜单进行点单，厨师收到菜单，然后开始烹饪。</p><ul><li>命令模式实例代码</li></ul><p>首先定义抽象接收者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 相当于接收者</span><br><span class="line"> * </span><br><span class="line"> * @author cm_wang</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract class Cook &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 厨师烹饪</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract void cooking();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 收到菜单</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实接收者CookA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CookA extends Cook &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void cooking() &#123;</span><br><span class="line">System.out.println(&quot;厨师A开始做饭。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void say() &#123;</span><br><span class="line">System.out.println(&quot;厨师A收到菜单。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象命令类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Command &#123;</span><br><span class="line"></span><br><span class="line">public abstract void orderList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体命令类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class CookCommand extends Command &#123;</span><br><span class="line"></span><br><span class="line">private Cook cook;</span><br><span class="line"></span><br><span class="line">public CookCommand(Cook _cook) &#123;</span><br><span class="line">this.cook &#x3D; _cook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void orderList() &#123;</span><br><span class="line">cook.cooking();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Invoker类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 相当于Invoker</span><br><span class="line"> * </span><br><span class="line"> * @author cm_wang</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">static void order() &#123;</span><br><span class="line">System.out.println(&quot;小王点菜。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Command command;</span><br><span class="line"></span><br><span class="line">public void setCommand(Command _command) &#123;</span><br><span class="line">this.command &#x3D; _command;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void action() &#123;</span><br><span class="line">this.command.orderList();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Cook cook &#x3D; new CookA();</span><br><span class="line"></span><br><span class="line">Command command &#x3D; new CookCommand(cook);</span><br><span class="line"></span><br><span class="line">Consumer cosumer&#x3D;new Consumer();</span><br><span class="line"></span><br><span class="line">Consumer.order();</span><br><span class="line"></span><br><span class="line">cook.say();</span><br><span class="line"></span><br><span class="line">cosumer.setCommand(command);</span><br><span class="line"></span><br><span class="line">cosumer.action();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">小王点菜。。。</span><br><span class="line">厨师A收到菜单。。。</span><br><span class="line">厨师A开始做饭。。。</span><br></pre></td></tr></table></figure><p>这样子就用命令模式实现了以上的例子。</p><ul><li>命令模式的优缺点<ul><li>命令模式封装性良好，是一种高内聚的模式。</li><li>命令模式可扩展性良好。</li><li>不好的地方就是当命令较多的时候很繁琐，所以还是看场景使用。</li></ul></li><li>命令模式总结<ul><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式(Chain of Responsibility Pattern)</title>
      <link href="/2020/04/17/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-Chain-of-Responsibility-Pattern/"/>
      <url>/2020/04/17/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F-Chain-of-Responsibility-Pattern/</url>
      
        <content type="html"><![CDATA[<p>责任链模式定义：责任链的重点是在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果。其定义为：Avoid coupling the sender of a request to its receiver by giving more than one project a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递改请求，直到有对象处理它为止。</p><a id="more"></a><ul><li>责任链模式定义</li></ul><p>责任链的重点是在“链”上，由一条链去处理相似的请求在链中决定谁来处理这个请求，并返回相应的结果。其定义为：Avoid coupling the sender of a request to its receiver by giving more than one project a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递改请求，直到有对象处理它为止。</p><ul><li>责任链模式通用类图</li></ul><p><img src="https://img-blog.csdnimg.cn/20181217104312369.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>责任链模式通用代码<br>首先是抽象处理者，①定义一个请求的处理方法handlerMessage。②定义一个链的编排方法。③定义具体的请求者必须实现的方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line"></span><br><span class="line">private Handler nextHandler;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unlikely-arg-type&quot;)</span><br><span class="line">public final Response hanleMessage(Request request) &#123;</span><br><span class="line"></span><br><span class="line">Response response &#x3D; null;</span><br><span class="line"></span><br><span class="line">if (this.getHandlerLevel().equals(request.getRequestLevel())) &#123;</span><br><span class="line">response &#x3D; this.echo(request);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(this.nextHandler !&#x3D; null) &#123;</span><br><span class="line">response &#x3D; this.nextHandler.hanleMessage(request);</span><br><span class="line">&#125;else &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setNext(Handler _handler) &#123;</span><br><span class="line">this.nextHandler &#x3D; _handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected abstract Level getHandlerLevel();</span><br><span class="line"></span><br><span class="line">protected abstract Response echo(Request request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Level &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Request &#123;</span><br><span class="line"></span><br><span class="line">public Level getRequestLevel() &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Response &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的处理者1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteHandler1 extends Handler &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Level getHandlerLevel() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Response echo(Request request) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的处理者2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteHandler2 extends Handler&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Level getHandlerLevel() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Response echo(Request request) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的处理者3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteHandler3 extends Handler&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Level getHandlerLevel() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected Response echo(Request request) &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明处理节点</span><br><span class="line">Handler h1 &#x3D; new ConcreteHandler1();</span><br><span class="line">Handler h2 &#x3D; new ConcreteHandler2();</span><br><span class="line">Handler h3 &#x3D; new ConcreteHandler3();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理顺序</span><br><span class="line">h1.setNext(h2);</span><br><span class="line">h1.setNext(h3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回结果</span><br><span class="line">Response response &#x3D; h1.hanleMessage(new Request());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>责任链模式实例类图<br>其实责任链模式在我们工作中还是比较常见的，比如提交请假申请的流程就可以看做一个责任链模式，首先老大给批准，接下来经理批准，最后总监批准，这个过程就是一个链。</li></ul><p><img src="https://img-blog.csdnimg.cn/20181217112940337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>责任链模式实例代码</li></ul><p>首先是抽象处理者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Handler &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 持有下一个处理请求的对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected Handler successor &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 取值方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Handler getSuccessor() &#123;</span><br><span class="line">return successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 设置下一个处理请求的对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void setSuccessor(Handler successor) &#123;</span><br><span class="line">this.successor &#x3D; successor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @return 成功或失败的具体通知</span><br><span class="line"> *&#x2F;</span><br><span class="line">public abstract String handleRequest(String user, int dayNum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分别是TeamLeader，Manager和GeneralManager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class TeamLeader extends Handler &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String handleRequest(String user, int dayNum) &#123;</span><br><span class="line"></span><br><span class="line">String str &#x3D; &quot;&quot;;</span><br><span class="line">&#x2F;&#x2F; TL权限比较小</span><br><span class="line">if (dayNum &lt; 3) &#123;</span><br><span class="line">if (&quot;张三&quot;.equals(user)) &#123;</span><br><span class="line">str &#x3D; &quot;成功：TL同意【&quot; + user + &quot;】请假&quot; + dayNum + &quot;天&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 其他人一律不同意</span><br><span class="line">str &#x3D; &quot;其他人一律不同意&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 请假超过三天的</span><br><span class="line">if (getSuccessor() !&#x3D; null) &#123;</span><br><span class="line">return getSuccessor().handleRequest(user, dayNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Manager extends Handler&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String handleRequest(String user, int dayNum) &#123;</span><br><span class="line"></span><br><span class="line">String str &#x3D; &quot;&quot;;</span><br><span class="line">&#x2F;&#x2F; 经理权限相对较大</span><br><span class="line">if (dayNum &lt; 5) &#123;</span><br><span class="line">if (&quot;张三&quot;.equals(user)) &#123;</span><br><span class="line">str &#x3D; &quot;成功：经理同意【&quot; + user + &quot;】请假&quot; + dayNum + &quot;天&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 其他人一律不同意</span><br><span class="line">str &#x3D; &quot;其他人一律不同意&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 请假超过五天的</span><br><span class="line">if (getSuccessor() !&#x3D; null) &#123;</span><br><span class="line">return getSuccessor().handleRequest(user, dayNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class GeneralManager extends Handler &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String handleRequest(String user, int dayNum) &#123;</span><br><span class="line"></span><br><span class="line">String str &#x3D; &quot;&quot;;</span><br><span class="line">&#x2F;&#x2F; 总监权限最大</span><br><span class="line">if (dayNum &lt; 10) &#123;</span><br><span class="line">if (&quot;张三&quot;.equals(user)) &#123;</span><br><span class="line">str &#x3D; &quot;成功：总监同意【&quot; + user + &quot;】请假&quot; + dayNum + &quot;天&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 其他人一律不同意</span><br><span class="line">str &#x3D; &quot;其他人一律不同意&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; 如果还有后继的处理对象，继续传递</span><br><span class="line">if (getSuccessor() !&#x3D; null) &#123;</span><br><span class="line">return getSuccessor().handleRequest(user, dayNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Handler h1 &#x3D; new TeamLeader();</span><br><span class="line">Handler h2 &#x3D; new Manager();</span><br><span class="line">Handler h3 &#x3D; new GeneralManager();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开始测试</span><br><span class="line">        String test1 &#x3D; h1.handleRequest(&quot;张三&quot;, 2);</span><br><span class="line">        System.out.println(&quot;test1 &#x3D; &quot; + test1);</span><br><span class="line">        String test2 &#x3D; h3.handleRequest(&quot;李四&quot;, 2);</span><br><span class="line">        System.out.println(&quot;test2 &#x3D; &quot; + test2);</span><br><span class="line">        System.out.println(&quot;---------------------------------------&quot;);</span><br><span class="line">        </span><br><span class="line">        String test3 &#x3D; h2.handleRequest(&quot;张三&quot;, 4);</span><br><span class="line">        System.out.println(&quot;test3 &#x3D; &quot; + test3);</span><br><span class="line">        String test4 &#x3D; h3.handleRequest(&quot;李四&quot;, 4);</span><br><span class="line">        System.out.println(&quot;test4 &#x3D; &quot; + test4);</span><br><span class="line">        System.out.println(&quot;---------------------------------------&quot;);</span><br><span class="line">        </span><br><span class="line">        String test5 &#x3D; h3.handleRequest(&quot;张三&quot;, 7);</span><br><span class="line">        System.out.println(&quot;test5 &#x3D; &quot; + test5);</span><br><span class="line">        String test6 &#x3D; h3.handleRequest(&quot;李四&quot;, 7);</span><br><span class="line">        System.out.println(&quot;test6 &#x3D; &quot; + test6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test1 &#x3D; 成功：TL同意【张三】请假2天</span><br><span class="line">test2 &#x3D; 其他人一律不同意</span><br><span class="line">---------------------------------------</span><br><span class="line">test3 &#x3D; 成功：经理同意【张三】请假4天</span><br><span class="line">test4 &#x3D; 其他人一律不同意</span><br><span class="line">---------------------------------------</span><br><span class="line">test5 &#x3D; 成功：总监同意【张三】请假7天</span><br><span class="line">test6 &#x3D; 其他人一律不同意</span><br></pre></td></tr></table></figure><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式(Mediator Pattern)</title>
      <link href="/2020/04/17/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-Mediator-Pattern/"/>
      <url>/2020/04/17/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-Mediator-Pattern/</url>
      
        <content type="html"><![CDATA[<p>中介者模式定义：Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently. 用一个中介对象封装一系列的对象交互，中介者使各个对象不需要显示地相互作用，从而使其耦合松散，而且可以独立的改变他们之间的交互。</p><a id="more"></a><ul><li><p>中介者模式定义<br>Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently. 用一个中介对象封装一系列的对象交互，中介者使各个对象不需要显示地相互作用，从而使其耦合松散，而且可以独立的改变他们之间的交互。</p></li><li><p>中介者模式通用类图<br><img src="https://img-blog.csdnimg.cn/2018120314331876.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>从以上类图可以看到，中介者模式主要有三个角色：</p><ul><li>抽象中介者：抽象中介者角色定义统一的接口，用于各个同事之间的通信。</li><li>中介者实现类：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。</li><li>同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。</li></ul></li><li><p>中介者模式通用代码<br>抽象中介者Mediator</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Mediator &#123;</span><br><span class="line"></span><br><span class="line">protected ConcreteColleague1 c1;</span><br><span class="line">protected ConcreteColleague2 c2;</span><br><span class="line"></span><br><span class="line">public ConcreteColleague1 getC1() &#123;</span><br><span class="line">return c1;</span><br><span class="line">&#125;</span><br><span class="line">public void setC1(ConcreteColleague1 c1) &#123;</span><br><span class="line">this.c1 &#x3D; c1;</span><br><span class="line">&#125;</span><br><span class="line">public ConcreteColleague2 getC2() &#123;</span><br><span class="line">return c2;</span><br><span class="line">&#125;</span><br><span class="line">public void setC2(ConcreteColleague2 c2) &#123;</span><br><span class="line">this.c2 &#x3D; c2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract void doSth1();</span><br><span class="line">public abstract void doSth2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象同事类Colleague</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Colleague &#123;</span><br><span class="line"></span><br><span class="line">protected Mediator mediator;</span><br><span class="line"></span><br><span class="line">public Colleague(Mediator _mediator) &#123;</span><br><span class="line">this.mediator &#x3D; _mediator;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体中介者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteMediator extends Mediator&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSth1() &#123;</span><br><span class="line">super.c1.selfMethod1();</span><br><span class="line">super.c2.selfMethod2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doSth2() &#123;</span><br><span class="line">super.c1.selfMethod1();</span><br><span class="line">super.c2.selfMethod2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体同事类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteColleague1 extends Colleague &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteColleague1(Mediator _mediator) &#123;</span><br><span class="line">super(_mediator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void selfMethod1() &#123;</span><br><span class="line">&#x2F;&#x2F;TODO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void depMethod1() &#123;</span><br><span class="line">super.mediator.doSth1();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteColleague2 extends Colleague &#123;</span><br><span class="line"></span><br><span class="line">public ConcreteColleague2(Mediator _mediator) &#123;</span><br><span class="line">super(_mediator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void selfMethod2() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void depMethod2() &#123;</span><br><span class="line">super.mediator.doSth2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中介者模式实例类图</li></ul><p>相比有很多男生都喜欢金庸的武侠小说吧，笔者也不例外。江湖中门派众多，总会有一些小喽啰偷学少林绝学去做一些见不得人的勾当。前段时间武当派和峨眉派的的弟子被大力金刚指所杀，大力金刚指是少林派的绝学，自古有天下武功出少林的没说，大家自然也不敢轻举妄动。这个时候大家推举出了德高望重的武林盟主，作为江湖的中间人，一旦有什么不和谐的地方，由武林盟主出面进行沟通，其实这个例子就符合中介者模式。</p><p><img src="https://img-blog.csdnimg.cn/20181203153700547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>中介者模式实例代码<br>抽象中介者类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class WulinAlliance &#123;</span><br><span class="line"></span><br><span class="line">abstract void notice(String message, United united);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象同事类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class United &#123;</span><br><span class="line"></span><br><span class="line">protected WulinAlliance wulinAlliance;</span><br><span class="line"></span><br><span class="line">public United(WulinAlliance wulinAlliance) &#123;</span><br><span class="line">this.wulinAlliance &#x3D; wulinAlliance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体同事类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Wudang extends United &#123;</span><br><span class="line">public Wudang(WulinAlliance wulinAlliance) &#123;</span><br><span class="line">super(wulinAlliance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sendAlliance(String message) &#123;</span><br><span class="line">wulinAlliance.notice(message, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getNotice(String message) &#123;</span><br><span class="line">System.out.println(&quot;武当收到消息：&quot; + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Shaolin extends United &#123;</span><br><span class="line">public Shaolin(WulinAlliance wulinAlliance) &#123;</span><br><span class="line">super(wulinAlliance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sendAlliance(String message) &#123;</span><br><span class="line">wulinAlliance.notice(message, Shaolin.this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getNotice(String message) &#123;</span><br><span class="line">System.out.println(&quot;少林收到消息：&quot; + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Emei extends United &#123;</span><br><span class="line">    public Emei(WulinAlliance wulinAlliance) &#123;</span><br><span class="line">        super(wulinAlliance);</span><br><span class="line">    &#125;</span><br><span class="line">    public void sendAlliance(String message) &#123;</span><br><span class="line">        wulinAlliance.notice(message, Emei.this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void getNotice(String message) &#123;</span><br><span class="line">        System.out.println(&quot;峨眉收到消息：&quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体中介者类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Champions extends WulinAlliance &#123;</span><br><span class="line">private Wudang wudang;</span><br><span class="line">private Shaolin shaolin;</span><br><span class="line">private Emei emei;</span><br><span class="line"></span><br><span class="line">public void setWudang(Wudang wudang) &#123;</span><br><span class="line">this.wudang &#x3D; wudang;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setEmei(Emei emei) &#123;</span><br><span class="line">this.emei &#x3D; emei;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setShaolin(Shaolin shaolin) &#123;</span><br><span class="line">this.shaolin &#x3D; shaolin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void notice(String message, United united) &#123;</span><br><span class="line">if (united &#x3D;&#x3D; wudang) &#123;</span><br><span class="line">shaolin.getNotice(message);</span><br><span class="line">&#125; else if (united &#x3D;&#x3D; emei) &#123;</span><br><span class="line">shaolin.getNotice(message);</span><br><span class="line">&#125; else if (united &#x3D;&#x3D; shaolin) &#123;</span><br><span class="line">wudang.getNotice(message);</span><br><span class="line">emei.getNotice(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Champions champions &#x3D; new Champions();</span><br><span class="line">Wudang wudang &#x3D; new Wudang(champions);</span><br><span class="line">Shaolin shaolin &#x3D; new Shaolin(champions);</span><br><span class="line">Emei emei &#x3D; new Emei(champions);</span><br><span class="line">champions.setWudang(wudang);</span><br><span class="line">champions.setShaolin(shaolin);</span><br><span class="line">champions.setEmei(emei);</span><br><span class="line">wudang.sendAlliance(&quot;武当弟子被少林大力金刚指所杀&quot;);</span><br><span class="line">emei.sendAlliance(&quot;峨眉弟子被少林大力金刚指所杀&quot;);</span><br><span class="line">shaolin.sendAlliance(&quot;少林弟子绝不会做出这种事情&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">少林收到消息：武当弟子被少林大力金刚指所杀</span><br><span class="line">少林收到消息：峨眉弟子被少林大力金刚指所杀</span><br><span class="line">武当收到消息：少林弟子绝不会做出这种事情</span><br><span class="line">峨眉收到消息：少林弟子绝不会做出这种事情</span><br></pre></td></tr></table></figure><ul><li>中介者模式的优点<ul><li>符合迪米特原则，将原有的一对多的依赖变成了一对一的依赖，降低类间的耦合。</li><li>使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。</li></ul></li><li>中介者模式的适用场景<ul><li>系统中对象之间存在比较复杂的引用关系，导致他们之间的依赖关系结构混乱而且难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式(Proxy Pattern)</title>
      <link href="/2020/04/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy-Pattern/"/>
      <url>/2020/04/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy-Pattern/</url>
      
        <content type="html"><![CDATA[<p>代理模式也叫做委托模式，在我们平时工作中其实很常用，静态代理、动态代理等。Provide a surrogate of placeholder for another object to control access to it. 为其他对象提供一种代理以控制对这个对象的访问。也可以理解为给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。</p><a id="more"></a><p>代理模式也叫做委托模式，在我们平时工作中其实很常用，静态代理、动态代理等。</p><ul><li><p>代理模式的定义<br>Provide a surrogate of placeholder for another object to control access to it. 为其他对象提供一种代理以控制对这个对象的访问。也可以理解为给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。</p></li><li><p>代理模式通用类图</p><ul><li>Subject：抽象主题角色，是一个接口。该接口是对象和它的代理共用的接口。</li><li>RealSubject：真实主题角色，是实现抽象主题接口的类。</li><li>Proxy：代理角色，内部含有对真实对象RealSubject的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20181108102752670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>代理模式通用代码</li></ul><p>抽象主题接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line"></span><br><span class="line">void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实主题类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy implements Subject&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 要代理哪个实现类</span><br><span class="line">public Subject subject &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 默认被代理者</span><br><span class="line">public Proxy() &#123;</span><br><span class="line">this.subject &#x3D; new Proxy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Proxy(Object...objects) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void request() &#123;</span><br><span class="line">this.subject.request();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>代理模式实例类图<br>这几年房价是涨的越来越快，有条件的小伙伴也都着急买房子。相信有很大一部分人是通过各种中介成交的，伴随的也是付出了一笔不小的费用，其实这个例子就可以理解为代理模式的一种。<br><img src="https://img-blog.csdnimg.cn/20181108110107810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>代理模式实例代码</p></li></ul><p>抽象主题接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line"></span><br><span class="line">void buyHouse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实主题类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class RealSubject implements Subject&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void buyHouse() &#123;</span><br><span class="line">System.out.println(&quot;你好，我要买房子。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链家中介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class LianJia implements Subject&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void buyHouse() &#123;</span><br><span class="line">RealSubject subject &#x3D; new RealSubject();</span><br><span class="line">subject.buyHouse();</span><br><span class="line">lianximaijia();</span><br><span class="line">deal();</span><br><span class="line">shoufei();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void lianximaijia() &#123;</span><br><span class="line">System.out.println(&quot;卖家联系成功。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void deal() &#123;</span><br><span class="line">System.out.println(&quot;成交。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void shoufei() &#123;</span><br><span class="line">System.out.println(&quot;你好，房子成交后我们要收取总房款2%的手续费哦。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] agrs) &#123;</span><br><span class="line">Subject s &#x3D; new LianJia();</span><br><span class="line">s.buyHouse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你好，我要买房子。</span><br><span class="line">卖家联系成功。</span><br><span class="line">成交。</span><br><span class="line">你好，房子成交后我们要收取总房款2%的手续费哦。</span><br></pre></td></tr></table></figure><p>以上的代码我是基于静态代理的方法实现的。<strong><code>静态代理比较简单，是由程序员编写的代理类，并在程序运行前就编译好的，而不是由程序动态产生代理类，这就是所谓的静态。</code></strong></p><ul><li>动态代理版</li></ul><p><strong><code>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK在运行时为我们动态的来创建。</code></strong> 以下是动态代理的基本使用方法。</p><blockquote><pre><code>1.创建一个实现InvocationHandler接口的类，它必须实现invoke()方法2.创建被代理的类及接口3.调用Proxy的静态方法，创建一个代理类4.通过代理调用方法</code></pre></blockquote><p>其余代码保持不变，要加一个 <strong><code>动态代理处理器</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxyHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">private Object object;</span><br><span class="line"></span><br><span class="line">public DynamicProxyHandler(final Object object) &#123;</span><br><span class="line">this.object &#x3D; object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;动态代理开始---------&gt;&quot;);</span><br><span class="line">Object result &#x3D; method.invoke(object, args);</span><br><span class="line">System.out.println(&quot;动态代理结束---------&gt;&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行一下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] agrs) &#123;</span><br><span class="line">&#x2F;&#x2F; 静态代理</span><br><span class="line">&#x2F;&#x2F; Subject s &#x3D; new LianJia();</span><br><span class="line">&#x2F;&#x2F; s.buyHouse();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态代理</span><br><span class="line">Subject subject &#x3D; new LianJia();</span><br><span class="line">Subject dynamicProxy &#x3D; (Subject) Proxy.newProxyInstance(Subject.class.getClassLoader(), new Class[] &#123; Subject.class &#125;,</span><br><span class="line">new DynamicProxyHandler(subject));</span><br><span class="line">dynamicProxy.buyHouse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">动态代理开始---------&gt;</span><br><span class="line">你好，我要买房子。</span><br><span class="line">卖家联系成功。</span><br><span class="line">成交。</span><br><span class="line">你好，房子成交后我们要收取总房款2%的手续费哦。</span><br><span class="line">动态代理结束---------&gt;</span><br></pre></td></tr></table></figure><ul><li>注意Proxy.newProxyInstance()方法接受三个参数：</li></ul><p>ClassLoader loader:指定当前目标对象使用的类加载器,获取加载器的方法是固定的<br>Class&lt;?&gt;[] interfaces:指定目标对象实现的接口的类型,使用泛型方式确认类型<br>InvocationHandler:指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法</p><ul><li>代理模式的优点<ul><li>协调调用者和被调用者，降低了系统的耦合度</li><li>代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用</li><li>符合开闭原则</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式(Prototype Pattern)</title>
      <link href="/2020/04/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-Prototype-Pattern/"/>
      <url>/2020/04/17/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-Prototype-Pattern/</url>
      
        <content type="html"><![CDATA[<p>原型模式在我们平时工作中还是很常用的，而且使用起来非常简单，其核心是一个clone方法。原型模式的定义：Specify the kinds of objects to create using a prototypical instance，and create new objects by copying this prototype. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><a id="more"></a><p>原型模式在我们平时工作中还是很常用的，而且使用起来非常简单，其核心是一个clone方法。</p><ul><li><p>原型模式的定义<br>Specify the kinds of objects to create using a prototypical instance，and create new objects by copying this prototype. 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p></li><li><p>原型模式的要点</p><ul><li>原型模式主要用于对象的复制。</li><li>原型类Prototype必须实现Cloneable接口。在Java中提供了一个Cloneable接口，来标识这个对象是可以拷贝的，在JVM中具有这个标记的对象才有可能被拷贝。</li><li>重写Object类中的clone方法。作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用。所以Prototype类需要将clone方法的作用域修改为public类型。</li></ul></li></ul><ul><li><p>原型模式的通用类图<br><img src="https://img-blog.csdnimg.cn/20181115104326338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>原型模式的通用代码</p></li></ul><p>原型类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Prototype implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;* (non-Javadoc)</span><br><span class="line"> * @see java.lang.Object#clone()</span><br><span class="line"> * </span><br><span class="line"> * 重写Object的clone()方法，必须是public</span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">@Override</span><br><span class="line">public Prototype clone() &#123;</span><br><span class="line"></span><br><span class="line">Protptype prototype &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">prototype &#x3D; (Protptype) super.clone();</span><br><span class="line">&#125; catch (CloneNotSupportedException ex) &#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return prototype;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class ConcretePrototype extends Prototype&#123;  </span><br><span class="line">    public void show()&#123;  </span><br><span class="line">        System.out.println(&quot;原型模式实现类&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ConcretePrototype cp &#x3D; new ConcretePrototype();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">ConcretePrototype clonecp &#x3D; (ConcretePrototype) cp.clone();</span><br><span class="line">clonecp.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br><span class="line">原型模式实现类</span><br></pre></td></tr></table></figure><ul><li>原型模式的实例类图</li></ul><p>在现实生活中有这样一种场景，说起来也很烦。双十一刚过，各种垃圾短信一顿狂轰乱炸，让人很不爽。其实这种大批量的发送短信的场景，原型模式是最适合不过了。</p><p><img src="https://img-blog.csdnimg.cn/20181115144721812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>原型模式的实例代码</li></ul><p>模板如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package example;</span><br><span class="line"></span><br><span class="line">public class Temeplate &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 短信名字</span><br><span class="line">private String subject &#x3D; &quot;【天猫双11活动】&quot;;</span><br><span class="line"></span><br><span class="line">private String content &#x3D; &quot;双11活动通知：满99减66.&quot;;</span><br><span class="line"></span><br><span class="line">public String getSubject() &#123;</span><br><span class="line">return subject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getContent() &#123;</span><br><span class="line">return content;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Message类如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Message implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">private String receiver;</span><br><span class="line"></span><br><span class="line">private String subject;</span><br><span class="line"></span><br><span class="line">private String content;</span><br><span class="line"></span><br><span class="line">public Message(Temeplate temeplate) &#123;</span><br><span class="line">this.subject &#x3D; temeplate.getSubject();</span><br><span class="line">this.content &#x3D; temeplate.getContent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Message clone() &#123;</span><br><span class="line">Message msg &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">msg &#x3D; (Message)super.clone();</span><br><span class="line">&#125;catch(CloneNotSupportedException ex) &#123;</span><br><span class="line">ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getReceiver() &#123;</span><br><span class="line">return receiver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setReceiver(String receiver) &#123;</span><br><span class="line">this.receiver &#x3D; receiver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getSubject() &#123;</span><br><span class="line">return subject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSubject(String subject) &#123;</span><br><span class="line">this.subject &#x3D; subject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getContent() &#123;</span><br><span class="line">return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setContent(String content) &#123;</span><br><span class="line">this.content &#x3D; content;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">private static int count &#x3D; 10;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">int i &#x3D; 0;</span><br><span class="line">Message msg &#x3D; new Message(new Temeplate());</span><br><span class="line">while (i &lt; count) &#123;</span><br><span class="line">Message cloneMsg &#x3D; msg.clone();</span><br><span class="line">Random rand &#x3D; new Random();</span><br><span class="line">cloneMsg.setReceiver(rand.nextInt(1000000000) + 1+&quot;@qq.com&quot;);</span><br><span class="line">send(cloneMsg);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void send(Message msg) &#123;</span><br><span class="line">System.out.println(msg.getReceiver()+&quot;接收成功&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">243217580@qq.com接收成功</span><br><span class="line">670592356@qq.com接收成功</span><br><span class="line">75390656@qq.com接收成功</span><br><span class="line">770711651@qq.com接收成功</span><br><span class="line">728774957@qq.com接收成功</span><br><span class="line">174509800@qq.com接收成功</span><br><span class="line">567463361@qq.com接收成功</span><br><span class="line">49934936@qq.com接收成功</span><br><span class="line">861293893@qq.com接收成功</span><br><span class="line">621002108@qq.com接收成功</span><br></pre></td></tr></table></figure><p>这样子就可以做到群发的效果，也就是商家只需要一份名单，就可以给名单里的人发送一样的短信。</p><ul><li>原型模式的注意事项<ul><li>使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。</li><li>深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（byte、char、short、int、long、float、double、boolean）。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。</li><li>clone和final是有冲突的。</li></ul></li><li>原型模式的优点及适用场景<ul><li>使用原型模式创建对象比直接new一个对象在性能上要好的多。</li><li>简化对象的创建。</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式(Builder Pattern)</title>
      <link href="/2020/04/17/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder-Pattern/"/>
      <url>/2020/04/17/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-Builder-Pattern/</url>
      
        <content type="html"><![CDATA[<p>建造者模式也叫做生成器模式，在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。建造者模式定义：Separate the construction of a complex object from its representation so that same construction process can create different representations. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><a id="more"></a><p>建造者模式也叫做生成器模式，在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</p><ul><li><p>建造者模式定义<br>Separate the construction of a complex object from its representation so that same construction process can create different representations. 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></li><li><p>建造者模式通用类图<br><img src="https://img-blog.csdnimg.cn/20181106150216215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>建造者模式的四个角色</p><ul><li><strong>Director（指导者）</strong>：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li><li><strong>Builder（抽象建造者）</strong>：给出一个抽象结论，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的对象部件的创建。  </li><li><strong>ConcreteBuilder（具体建造者）</strong>：实现Builder接口，针对不同的业务逻辑，具体化复杂对象的各部分的创建。在构造过程完成后，提供产品的实例。</li><li><strong>Product（产品类）</strong>：要创建的复杂对象。</li></ul></li><li><p>建造者模式通用代码</p></li></ul><p>产品类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;</span><br><span class="line"></span><br><span class="line">public void doSth() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Builder &#123;</span><br><span class="line"></span><br><span class="line">public abstract void setPart();</span><br><span class="line"></span><br><span class="line">public abstract Product buildProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体建造者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteProduct extends Builder &#123;</span><br><span class="line"></span><br><span class="line">private Product product &#x3D; new Product();</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void setPart() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Product buildProduct() &#123;</span><br><span class="line">&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">return product;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导演类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Dicector &#123;</span><br><span class="line"></span><br><span class="line">private Builder builder &#x3D; new ConcreteProduct();</span><br><span class="line"></span><br><span class="line">public Product getAProduct() &#123;</span><br><span class="line"></span><br><span class="line">builder.setPart();</span><br><span class="line">&#x2F;&#x2F; 业务逻辑</span><br><span class="line">return builder.buildProduct();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>建造者模式实例<br>小王想去电脑城买一台电脑，他不想买一体机，而是想买组装机，过程大概是以下的样子。</p><ul><li>电脑城老板（Diretor）和小王（Client）进行需求沟通</li><li>了解需求后，电脑城老板将小王需要的主机划分为各个部件（Builder）的建造请求（CPU、主板blabla）</li><li>指挥装机人员（ConcreteBuilder）去构建组件</li><li>将电脑组装起来，变成小成需要的电脑（Product）</li></ul></li><li><p>建造者模式实例类图</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20181106154445626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>建造者模式实例代码</li></ul><p>电脑类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 电脑组件的集合</span><br><span class="line">private List&lt;String&gt; parts &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用于将组件组装到电脑里</span><br><span class="line">public void Add(String part) &#123;</span><br><span class="line">parts.add(part);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Show() &#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; parts.size(); i++) &#123;</span><br><span class="line">System.out.println(&quot;组件&quot; + parts.get(i) + &quot;装好了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;电脑组装完成，请验收&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象建造者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Builder &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一步：装CPU</span><br><span class="line">&#x2F;&#x2F; 声明为抽象方法，具体由子类实现</span><br><span class="line">public abstract void  BuildCPU();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二步：装主板</span><br><span class="line">&#x2F;&#x2F;声明为抽象方法，具体由子类实现 </span><br><span class="line">public abstract void BuildMainboard();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第三步：装硬盘</span><br><span class="line">&#x2F;&#x2F; 声明为抽象方法，具体由子类实现</span><br><span class="line">public abstract void BuildHD();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回产品的方法：获得组装好的电脑</span><br><span class="line">public abstract Computer GetComputer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电脑安装人员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteBuilder extends Builder &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建产品实例</span><br><span class="line">Computer computer &#x3D; new Computer();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 组装产品</span><br><span class="line">@Override</span><br><span class="line">public void BuildCPU() &#123;</span><br><span class="line">computer.Add(&quot;组装CPU&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void BuildMainboard() &#123;</span><br><span class="line">computer.Add(&quot;组装主板&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void BuildHD() &#123;</span><br><span class="line">computer.Add(&quot;组装主板&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回组装成功的电脑</span><br><span class="line">@Override</span><br><span class="line">public Computer GetComputer() &#123;</span><br><span class="line">return computer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老板类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Director &#123;</span><br><span class="line"></span><br><span class="line">public void Construct(Builder builder) &#123;</span><br><span class="line"></span><br><span class="line">builder.BuildCPU();</span><br><span class="line">builder.BuildMainboard();</span><br><span class="line">builder.BuildHD();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] srgs) &#123;</span><br><span class="line"></span><br><span class="line">Director director &#x3D; new Director();</span><br><span class="line">Builder builder &#x3D; new ConcreteBuilder();</span><br><span class="line">director.Construct(builder);</span><br><span class="line">Computer computer &#x3D; builder.GetComputer();</span><br><span class="line">computer.Show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>应用场景</p><ul><li>需要生产的产品对象有复杂的内部结构。</li><li>需要生产的产品对象的属性相互依赖，建造者模式可以强迫生成顺序。</li><li>在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。</li></ul></li><li><p>优点</p><ul><li>使用建造者模式可以使客户端不必知道产品内部的组成细节。（封装性）</li><li>具体的建造者之间是相互独立的，对系统的扩展非常有利。（扩展性）</li><li>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他模块产生任何影响。</li></ul></li><li><p>建造者模式与工厂模式的区别</p><ul><li>我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。</li><li>与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。<strong><code>也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</code></strong></li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式(Abstract Factory Pattern)</title>
      <link href="/2020/04/17/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Abstract-Factory-Pattern/"/>
      <url>/2020/04/17/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-Abstract-Factory-Pattern/</url>
      
        <content type="html"><![CDATA[<p>Provide an interface for creating families of related or dependent objects without specifying their concrete classes. 为创建一组相关或相互依赖的对象提供一个接口，而且无须指定他们的具体类。</p><a id="more"></a><ul><li>抽象工厂模式定义<ul><li>Provide an interface for creating families of related or dependent objects without specifying their concrete classes. 为创建一组相关或相互依赖的对象提供一个接口，而且无须指定他们的具体类。</li></ul></li><li>抽象工厂模式和工厂模式的区别<ul><li>抽象工厂模式是针对的多个产品等级结构。简单来说就是多维度的，因为可以提供多种类型的多种规格的产品。</li><li>工厂模式是针对的是一个产品等级结构。简单来说就是单维度的，只可以提供一种类型的多种规格的产品。</li><li>在抽象工厂模式中，有一个<code>产品族</code>的概念。<code>所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族</code>。</li></ul></li><li>抽象工厂模式实例<br>相信很多男孩子都喜欢枪，其实笔者也很喜欢枪，可以说还是很痴迷呢。我们假设现在存在AK、M4A1两类枪，每一种枪对应一种子弹。我们现在这样考虑生产AK的工厂可以顺便生产AK使用的子弹，生产M4A1的工厂可以顺便生产M4A1使用的子弹。<ul><li>类图<br><img src="https://img-blog.csdnimg.cn/20181030140908899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>实例代码</li></ul></li></ul><p>创建枪接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IGun &#123;</span><br><span class="line"></span><br><span class="line">void shoot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建子弹接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface IBullet &#123;</span><br><span class="line"></span><br><span class="line">void load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建AK类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AK implements IGun&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shoot() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;AK shoot...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建M4A1类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class M4A1 implements IGun&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void shoot() &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;M4A1 shoot...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建AK子弹类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class AKBullet implements IBullet&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void load() &#123;</span><br><span class="line">System.out.println(&quot;load AK bullet...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建M4A1子弹类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class M4A1Bullet implements IBullet&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void load() &#123;</span><br><span class="line">System.out.println(&quot;load M4A1 bullet...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建工厂接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">IGun productGun();</span><br><span class="line">IBullet productBullet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来生产枪支和子弹。<br>生产AK和子弹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AK_Factory implements Factory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IGun productGun() &#123;</span><br><span class="line">return new AK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IBullet productBullet() &#123;</span><br><span class="line">return new AKBullet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产M4A1和子弹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class M4A1_Factory implements Factory&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IGun productGun() &#123;</span><br><span class="line">return new M4A1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public IBullet productBullet() &#123;</span><br><span class="line">return new M4A1Bullet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述的步骤（假设这就是生产枪支和弹药的流程）我们的枪支和子弹就生产好了，接下来就可以开枪射击了，想想还挺爽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryTest &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line">Factory factory &#x3D; new AK_Factory();</span><br><span class="line">IBullet bullet &#x3D; factory.productBullet();</span><br><span class="line">IGun gun &#x3D; factory.productGun();</span><br><span class="line">bullet.load();</span><br><span class="line">gun.shoot();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">load AK bullet...</span><br><span class="line">AK shoot...</span><br></pre></td></tr></table></figure><ul><li>抽象工厂的优点<br>抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。</li><li>抽象工厂的缺点<br>产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。</li><li>总结<br>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。</li></ul><p>最终目的都是为了解耦！解耦！！解耦！！！</p><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式(Template Method Pattern)</title>
      <link href="/2020/04/17/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Template-Method-Pattern/"/>
      <url>/2020/04/17/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Template-Method-Pattern/</url>
      
        <content type="html"><![CDATA[<p>其实模板方法在我们平时工作使用的非常频繁，但是没有学习过设计模式的小伙伴可能不是很清楚模板方法的定义是什么，即使是自己一直在用。模板方法模式定义：Define the skeleton of an operation，deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure. 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定的步骤。</p><a id="more"></a><p>其实模板方法在我们平时工作使用的非常频繁，但是没有学习过设计模式的小伙伴可能不是很清楚模板方法的定义是什么，即使是自己一直在用。</p><ul><li>模板方法模式定义<br>Define the skeleton of an operation，deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure. 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定的步骤。</li><li>模板方法模式通用类图<br><img src="https://img-blog.csdnimg.cn/20181101115806929.png" alt="在这里插入图片描述"></li><li>模板方法模式通用代码</li></ul><p>抽象模板类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClass &#123;</span><br><span class="line"></span><br><span class="line">protected abstract void otherMethod();</span><br><span class="line"></span><br><span class="line">public void templateMethod() &#123;</span><br><span class="line">this.otherMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ConcreteClass extends AbstractClass&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void otherMethod() &#123;</span><br><span class="line">System.out.println(&quot;otherMethod...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Clinet &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ConcreteClass c &#x3D; new ConcreteClass();</span><br><span class="line">c.templateMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模板方法模式实例<br>相信很多小伙伴都喜欢玩游戏吧，我比较喜欢玩DNF，所以就用DNF来举个例子吧。假设有A和B两个小伙伴都喜欢玩DNF，但是每次都需要打开电脑，打开游戏客户端，登录游戏。其实这部分的流程是重复的，只有游戏登录之后才是不同的，想怎么玩怎么玩。</li></ul><p>实例类图<br><img src="https://img-blog.csdnimg.cn/20181101145223147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>实例代码，首先抽象一个DNFHelper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class DNFHelper &#123;</span><br><span class="line"></span><br><span class="line">void openPC() &#123;</span><br><span class="line">System.out.println(&quot;打开电脑...&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void openDNFClient() &#123;</span><br><span class="line">System.out.println(&quot;打开DNF客户端...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loginDNF() &#123;</span><br><span class="line">System.out.println(&quot;登录DNF账号...&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract void play();</span><br><span class="line"></span><br><span class="line">void process() &#123;</span><br><span class="line">this.openPC();</span><br><span class="line">this.openDNFClient();</span><br><span class="line">this.loginDNF();</span><br><span class="line">this.play();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实例化两个玩家</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PlayerA extends DNFHelper&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">void play() &#123;</span><br><span class="line">System.out.println(&quot;玩家A开始玩DNF...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PlayerB extends DNFHelper&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">void play() &#123;</span><br><span class="line">System.out.println(&quot;玩家B开始玩DNF...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后开始玩游戏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">PlayerA playA &#x3D; new PlayerA();</span><br><span class="line">playA.process();</span><br><span class="line">System.out.println(&quot;-------------&quot;);</span><br><span class="line">PlayerB playB &#x3D; new PlayerB();</span><br><span class="line">playB.process();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">打开电脑...</span><br><span class="line">打开DNF客户端...</span><br><span class="line">登录DNF账号...</span><br><span class="line">玩家A开始玩DNF...</span><br><span class="line">-------------</span><br><span class="line">打开电脑...</span><br><span class="line">打开DNF客户端...</span><br><span class="line">登录DNF账号...</span><br><span class="line">玩家B开始玩DNF...</span><br></pre></td></tr></table></figure><p>自从有了这个DNFHelper之后，玩家终于做到可以直接开始玩游戏了，是不是很爽。</p><ul><li>模版方法模式的结构<ul><li>抽象方法：父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。</li><li>模版方法：由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。</li><li>钩子方法：由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。</li></ul></li><li>模板方法模式的优点<ul><li>行文是由父类控制的，子类负责实现。</li><li>比较灵活，因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。</li><li>便于维护，符合开闭原则。</li><li>一般多个子类有公有的方法，并且逻辑基本相同的时候，模板方法模式很好用。</li></ul></li></ul><p>参考书籍：<code>设计模式之禅</code><br>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA设计模式之六大设计原则</title>
      <link href="/2020/04/17/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2020/04/17/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>在程序设计中，我们通常要遵循以下六大原则：单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和开闭原则。</p><a id="more"></a><p>在程序设计中，我们通常要遵循以下六大原则：<br><img src="https://img-blog.csdn.net/20181016095505330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul><li>官方定义：<ul><li>就一个类(接口、结构体、方法等等)而言，有且仅有一个引起它变化的原因。</li></ul></li><li>个人理解：<ul><li>通俗的来讲做一件事就是专注做一件事，不可以三心二意。任务对象只是专注于一项职责，不去承担太多的责任。当任务对象的职责发生变化时，不会对其他的对象产生影响。</li></ul></li><li>遵循单一职责原的优点：<ul><li>可以大大降低耦合度。</li><li>降低类的复杂度。</li><li>提高类的可读性。</li><li>降低因变更而引起的风险。</li><li>提高类的复用性和可维护性。</li></ul></li><li>单一职责应用：<ul><li>背景：有一个类A，他需要负责T1和T2。但是当职责T1因为需求而改变类A的时候，就会对职责T2造成影响，导致T2不能正常工作。</li><li>解决办法：针对职责T1创建类A，针对职责T2创建类B。这样就可以达到当修改类A时不会对职责T2造成影响，当修改类B时不会对职责T1造成影响。</li></ul></li></ul><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><ul><li>官方定义：<ul><li>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</li></ul></li><li>个人理解：<ul><li>继承必须确保父类所拥有的性质在子类中仍然成立。</li><li>或者说子类可以扩展父类的功能，但不能改变父类原有的功能。</li><li>子类中可以增加自己特有的方法。</li><li>子类的方法实现父类的抽象方法时，方法的返回值要比父类的返回值更加严谨。</li></ul></li><li>继承是面向对象的三大特性之一，在程序设计方面带来了很大的便利性，但是同时也存在一些不好的地方：<code>增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</code></li><li>经典案例之正方形不是长方形：<ul><li>在大众的认知范围内长方形的长和宽是不相等的，正方形的长和宽是相等的，正方形属于特殊的长方形。</li><li>先定义一个长方形类</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">private int width;</span><br><span class="line">private int height;</span><br><span class="line"></span><br><span class="line">public int getWidth() &#123;</span><br><span class="line">return width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setWidth(int width) &#123;</span><br><span class="line">this.width &#x3D; width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getHeight() &#123;</span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setHeight(int height) &#123;</span><br><span class="line">this.height &#x3D; height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Rectangle(int width, int height) &#123;</span><br><span class="line">this.width &#x3D; width;</span><br><span class="line">this.height &#x3D; height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int area() &#123;</span><br><span class="line">return width * height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再定义一个正方形类，继承自长方形类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Square extends Rectangle &#123;</span><br><span class="line"></span><br><span class="line">private int width;</span><br><span class="line"></span><br><span class="line">public int getWidth() &#123;</span><br><span class="line">return width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setWidth(int width) &#123;</span><br><span class="line">this.width &#x3D; width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Square(int width, int height) &#123;</span><br><span class="line">super(width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 重写 area()</span><br><span class="line"> * </span><br><span class="line"> * @see design.Rectangle#area()</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int area() &#123;</span><br><span class="line">return width * width;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Rectangle rectangle &#x3D; new Rectangle(10, 20);</span><br><span class="line">System.out.println(&quot;面积：&quot; + rectangle.area());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出结果为面积：200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Square rectangle &#x3D; new Square(10, 20);</span><br><span class="line">System.out.println(&quot;面积：&quot; + rectangle.area());</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 输出结果为面积：0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：为什么当<code>Rectangle</code>替换为<code>Square</code>之后，面积的结果出错了呢？因为在<code>Square</code>类里重写了<code>area()</code>方法，很明显违背了里氏替换原则，改变了父类的原有功能，所以导致输出结果不对。</li></ul><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒置原则就是面向对象设计的主要手段。</p><ul><li>官方定义：<ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</li></ul></li><li>个人理解：<ul><li>依赖倒置原则的核心思想就是让我们<code>面向接口编程</code>。</li><li>抽象是面向对象的三大特性之一，相对于细节的多变性，抽象的东西要稳定的多。在Java中抽象指的就是接口和抽象类，接口和抽象类只是定义好规范和规则，而不去关注任何实现，具体的实现都交给实现类去关注。</li></ul></li><li>应用场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了（copy自网上）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Book&#123;</span><br><span class="line">public String getContent()&#123;</span><br><span class="line">return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Mother&#123;</span><br><span class="line">public void narrate(Book book)&#123;</span><br><span class="line">System.out.println(&quot;妈妈开始讲故事&quot;);</span><br><span class="line">System.out.println(book.getContent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Mother mother &#x3D; new Mother();</span><br><span class="line">mother.narrate(new Book());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">妈妈开始讲故事</span><br><span class="line">很久很久以前有一个阿拉伯的故事……</span><br></pre></td></tr></table></figure><p>但是现在问题来了，当我修改了Book类，由原先的读书变成读报纸，这个时候Mother类就不会了，那么这个问题怎么解决呢？</p><p>两种方法解决：    </p><pre><code>①第一种：直接去修改Mother类，将Book类直接替换成Newspaper类。这样是可以解决一时的问题，但是将来我不仅仅是读书，而且还要读邮件等等呢，Mother和Book之间的耦合性太高了，所以不是一个好的办法。②第二种：我们引入一个抽象的接口IReader。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IReader&#123;</span><br><span class="line">public String getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper implements IReader &#123;</span><br><span class="line">public String getContent()&#123;</span><br><span class="line">return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book implements IReader&#123;</span><br><span class="line">public String getContent()&#123;</span><br><span class="line">return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Mother&#123;</span><br><span class="line">public void narrate(IReader reader)&#123;</span><br><span class="line">System.out.println(&quot;妈妈开始讲故事&quot;);</span><br><span class="line">System.out.println(reader.getContent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">Mother mother &#x3D; new Mother();</span><br><span class="line">mother.narrate(new Book());</span><br><span class="line">mother.narrate(new Newspaper());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">妈妈开始讲故事</span><br><span class="line">很久很久以前有一个阿拉伯的故事……</span><br><span class="line">妈妈开始讲故事</span><br><span class="line">林书豪17+9助尼克斯击败老鹰……</span><br></pre></td></tr></table></figure><p>这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。</p><ul><li>最佳实践<ul><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。</li><li>变量的显示类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>尽量不要覆写基类的方法。</li><li>结合里氏替换原则使用。</li></ul></li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul><li>官方定义：<ul><li>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li></ul></li><li>个人理解：<ul><li>单从字面上理解：使用多个隔离的接口，而不是使用单一的接口。</li><li>接口隔离原则的本意是降低类之间的耦合性。在大型的软件设计中，为了方便维护和扩展，降低类之间的依赖和耦合是很必要的。</li><li>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li></ul></li><li>举一反三<ul><li>一开始我自己觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。</li><li>其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。</li><li>其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</li></ul></li><li>最佳实践：<ul><li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li><li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul></li></ul><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><ul><li>官方定义：<ul><li>一个对象应该对其他对象保持最少的了解。</li></ul></li><li>个人理解：<ul><li>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</li><li>也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。</li><li>当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，就是说可扩展性很好。</li></ul></li><li>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;总公司员工</span><br><span class="line">class Employee&#123;</span><br><span class="line">private String id;</span><br><span class="line">public void setId(String id)&#123;</span><br><span class="line">this.id &#x3D; id;</span><br><span class="line">&#125;</span><br><span class="line">public String getId()&#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;分公司员工</span><br><span class="line">class SubEmployee&#123;</span><br><span class="line">private String id;</span><br><span class="line">public void setId(String id)&#123;</span><br><span class="line">this.id &#x3D; id;</span><br><span class="line">&#125;</span><br><span class="line">public String getId()&#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class SubCompanyManager&#123;</span><br><span class="line">public List&lt;SubEmployee&gt; getAllEmployee()&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list &#x3D; new ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">for(int i&#x3D;0; i&lt;100; i++)&#123;</span><br><span class="line">SubEmployee emp &#x3D; new SubEmployee();</span><br><span class="line">&#x2F;&#x2F;为分公司人员按顺序分配一个ID</span><br><span class="line">emp.setId(&quot;分公司&quot;+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class CompanyManager&#123;</span><br><span class="line"> </span><br><span class="line">public List&lt;Employee&gt; getAllEmployee()&#123;</span><br><span class="line">List&lt;Employee&gt; list &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">for(int i&#x3D;0; i&lt;30; i++)&#123;</span><br><span class="line">Employee emp &#x3D; new Employee();</span><br><span class="line">&#x2F;&#x2F;为总公司人员按顺序分配一个ID</span><br><span class="line">emp.setId(&quot;总公司&quot;+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printAllEmployee(SubCompanyManager sub)&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list1 &#x3D; sub.getAllEmployee();</span><br><span class="line">for(SubEmployee e:list1)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">List&lt;Employee&gt; list2 &#x3D; this.getAllEmployee();</span><br><span class="line">for(Employee e:list2)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">CompanyManager e &#x3D; new CompanyManager();</span><br><span class="line">e.printAllEmployee(new SubCompanyManager());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class SubCompanyManager&#123;</span><br><span class="line">public List&lt;SubEmployee&gt; getAllEmployee()&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list &#x3D; new ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">for(int i&#x3D;0; i&lt;100; i++)&#123;</span><br><span class="line">SubEmployee emp &#x3D; new SubEmployee();</span><br><span class="line">&#x2F;&#x2F;为分公司人员按顺序分配一个ID</span><br><span class="line">emp.setId(&quot;分公司&quot;+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">public void printEmployee()&#123;</span><br><span class="line">List&lt;SubEmployee&gt; list &#x3D; this.getAllEmployee();</span><br><span class="line">for(SubEmployee e:list)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class CompanyManager&#123;</span><br><span class="line">public List&lt;Employee&gt; getAllEmployee()&#123;</span><br><span class="line">List&lt;Employee&gt; list &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">for(int i&#x3D;0; i&lt;30; i++)&#123;</span><br><span class="line">Employee emp &#x3D; new Employee();</span><br><span class="line">&#x2F;&#x2F;为总公司人员按顺序分配一个ID</span><br><span class="line">emp.setId(&quot;总公司&quot;+i);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printAllEmployee(SubCompanyManager sub)&#123;</span><br><span class="line">sub.printEmployee();</span><br><span class="line">List&lt;Employee&gt; list2 &#x3D; this.getAllEmployee();</span><br><span class="line">for(Employee e:list2)&#123;</span><br><span class="line">System.out.println(e.getId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul><li>官方定义：<ul><li>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</li></ul></li><li>个人理解：<ul><li>如果修改或者添加一个功能，应该是通过扩展原来的代码，而不是通过修改原来的代码。 </li></ul></li><li>应用场景：略。</li></ul><p>总的来说，程序设计尽量的贴近软件编程的总的原则：高内聚，低耦合。</p><p>参考资料：<a href="https://blog.csdn.net/column/details/pattern.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/pattern.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式(Singleton Pattern)</title>
      <link href="/2020/04/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern/"/>
      <url>/2020/04/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern/</url>
      
        <content type="html"><![CDATA[<p>单例模式的定义：Ensure a class has only one instance, and provide a global point of access to it。确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个唯一实例。</p><a id="more"></a><ul><li><p>单例模式的定义<br>Ensure a class has only one instance, and provide a global point of access to it。确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个唯一实例。</p></li><li><p>单例模式的通用类图<br><img src="https://img-blog.csdn.net/20181023171228800?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p></li><li><p>单例模式通用代码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单例模式通用代码</span><br><span class="line"> * </span><br><span class="line"> * @author cm_wang</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonPattern &#123;</span><br><span class="line"></span><br><span class="line">private static final SingletonPattern singletonPattern &#x3D; new SingletonPattern();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 私有的构造方法，为了限制产生多个对象</span><br><span class="line">private SingletonPattern() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 通过这个方法获得对象唯一实例</span><br><span class="line"> * </span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static SingletonPattern getSingleton() &#123;</span><br><span class="line">return singletonPattern;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>正如上面的代码所述一样，单例模式有两个要素要记得</p><ul><li>私有的构造方法。为了防止系统中出现多个实例，保证该实例的唯一性。</li><li>以自己实例为返回值的静态的公有的方法。外部会通过这个方法来获取该对象的唯一实例。</li></ul></li><li><p>单例模式会根据实例化对象时机的不同分为两种：一种是<code>饿汉式单例</code>，一种是懒<code>汉式单例</code>。饿汉式单例和懒汉式单例的区别是：<code>饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；而懒汉式单例在调用取得实例方法的时候才会实例化对象</code>。</p></li><li><p>饿汉式单例代码，正如<code>单例模式通用代码</code>一样，这里略。</p></li><li><p>懒汉式单例代码</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 懒汉式单例</span><br><span class="line"> * </span><br><span class="line"> * @author cm_wang</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonPattern &#123;</span><br><span class="line"></span><br><span class="line">private static SingletonPattern singletonPattern;</span><br><span class="line"></span><br><span class="line">private SingletonPattern()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public static synchronized SingletonPattern getInstance()&#123;</span><br><span class="line">if(singletonPattern&#x3D;&#x3D;null)&#123;</span><br><span class="line">singletonPattern &#x3D; new SingletonPattern();</span><br><span class="line">&#125;</span><br><span class="line">return singletonPattern;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的小伙伴已经发现<code>getInstance()</code>加了<code>synchronized</code>关键字。是因为在多线程的环境下，单例模式会出现<code>线程不安全</code>的问题，这个时候就需要考虑线程同步。假设线程A执行到<code>singletonPattern = new SingletonPattern();</code>，但是此时没有获取到对象（毕竟对象的实例化是需要实现的），这个时候线程B也在执行，执行到<code>if(singletonPattern==null)</code>，线程B就会判断为<code>true</code>，继续运行下去，这样子就会导致线程A和线程B一下自创建了两个对象，就违背了单例模式的思想，内存中就会存在两个实例。</p><ul><li>双重校验版单例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 双重校验版单例代码</span><br><span class="line"> * </span><br><span class="line"> * @author cm_wang</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonPattern &#123;</span><br><span class="line">private static SingletonPattern singletonPattern;</span><br><span class="line"></span><br><span class="line">private SingletonPattern() &#123;&#125;</span><br><span class="line"></span><br><span class="line">public static SingletonPattern getInstance() &#123;</span><br><span class="line">if(singletonPattern &#x3D;&#x3D; null) &#123;</span><br><span class="line">synchronized(SingletonPattern.class) &#123;</span><br><span class="line">if(singletonPattern &#x3D;&#x3D; null) &#123;</span><br><span class="line">singletonPattern &#x3D; new SingletonPattern();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return singletonPattern;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>单例模式的好处</p><ul><li>因为单例模式会保证内存中只有一个对象，减少内存的开销。</li><li>单例模式无论是饿汉式还是懒汉式，都可以避免频繁的创建和销毁对象，可以提高程序的性能。</li><li>单例模式是支持全局访问的。</li><li>避免对程序的公共资源的占用和浪费。</li></ul></li><li><p><a href="https://segmentfault.com/q/1010000003732558" target="_blank" rel="noopener">枚举实现单例模式</a></p></li><li><p><a href="https://blog.csdn.net/dmk877/article/details/50311791?utm_source=blogxgwz0" target="_blank" rel="noopener">拓展</a></p></li></ul><p>参考书籍：</p><ul><li><code>设计模式之禅</code>，<code>Head First设计模式</code></li><li>实例代码放在<a href="https://github.com/BazookaW/DesignPattern" target="_blank" rel="noopener">这里</a>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程，设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Jenkins的超超超超简单的方法</title>
      <link href="/2020/04/17/%E5%AE%89%E8%A3%85Jenkins%E7%9A%84%E8%B6%85%E8%B6%85%E8%B6%85%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/17/%E5%AE%89%E8%A3%85Jenkins%E7%9A%84%E8%B6%85%E8%B6%85%E8%B6%85%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Jenkins 是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。由于本人不是很喜欢使用官网的安装包，也不是很推荐使用安装包，因为在安装过程中会遇到很多想不到的坑，所以本文以命令安装Jenkins为例。</p><a id="more"></a><p>由于本人不是很喜欢使用官网的安装包，也不是很推荐使用安装包，因为在安装过程中会遇到很多想不到的坑，所以本文以命令安装Jenkins为例。</p><h5 id="关于Jenkins"><a href="#关于Jenkins" class="headerlink" title="关于Jenkins"></a>关于Jenkins</h5><ul><li>Jenkins 是一款流行的开源持续集成（Continuous Integration）工具，广泛用于项目开发，具有自动化构建、测试和部署等功能。</li><li>官网：<a href="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/</a><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5>mac OS Mojave 10.14.5 (18F132)<h5 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h5></li><li>安装brew<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure></li><li>安装Java8及以上版本<br><img src="https://img-blog.csdnimg.cn/20190717102636310.png" alt="在这里插入图片描述"><h5 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h5></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install jenkins</span><br></pre></td></tr></table></figure><p>这个过程可能需要一点时间，耐心等待就好。<br>在安装过程中，<strong>生成安全令牌并将其打印在控制台日志中，这个非常重要</strong>。类似这样子的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">************************************************** ***********</span><br><span class="line"></span><br><span class="line">41d2b60b0e4cb5bf2025d33b21cb</span><br><span class="line"></span><br><span class="line">************************************************** ***********</span><br></pre></td></tr></table></figure><h5 id="链接-launchd-配置文件"><a href="#链接-launchd-配置文件" class="headerlink" title="链接 launchd 配置文件"></a>链接 launchd 配置文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sfv &#x2F;usr&#x2F;local&#x2F;opt&#x2F;jenkins&#x2F;*.plist ~&#x2F;Library&#x2F;LaunchAgents</span><br></pre></td></tr></table></figure><h5 id="修改完成，执行命令行"><a href="#修改完成，执行命令行" class="headerlink" title="修改完成，执行命令行"></a>修改完成，执行命令行</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.jenkins.plist</span><br></pre></td></tr></table></figure><h5 id="启动Jenkins"><a href="#启动Jenkins" class="headerlink" title="启动Jenkins"></a>启动Jenkins</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenkins</span><br></pre></td></tr></table></figure><h5 id="查看Jenkins的web界面"><a href="#查看Jenkins的web界面" class="headerlink" title="查看Jenkins的web界面"></a>查看Jenkins的web界面</h5><p>在浏览器输入<code>localhost:8080</code>，因为是第一次启动，所以可以看到类似如下页面</p><p><strong>这个时候输入控制台日志的令牌</strong><br><img src="https://img-blog.csdnimg.cn/20190717123153547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来就是一些基本配置，安装插件，建议选择“推荐安装的插件”，然后设置用户和密码，完毕。<br><img src="https://img-blog.csdnimg.cn/20190717123225430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190717123235108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>就可以看到如下界面，证明已经安装成功。<br><img src="https://img-blog.csdnimg.cn/20190717111307806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="Jenkins的一些操作"><a href="#Jenkins的一些操作" class="headerlink" title="Jenkins的一些操作"></a>Jenkins的一些操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;exit          &#x2F;&#x2F;退出Jenkins</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;restart      &#x2F;&#x2F;重启</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;reload      &#x2F;&#x2F;重新加载</span><br></pre></td></tr></table></figure><h5 id="Jenkins启动脚本"><a href="#Jenkins启动脚本" class="headerlink" title="Jenkins启动脚本"></a>Jenkins启动脚本</h5><p>为了方便启动Jenkins，不用每次都去敲命令启动，所以写一个脚本，命名为<code>JenkinsBoot.sh</code> 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;jenkins&#x2F;2.183  </span><br><span class="line">jenkins</span><br></pre></td></tr></table></figure><p>双击执行这个脚本之后，在浏览器输入<code>localhost:8080</code>就可以正常看到Jenkins的web页面。</p>]]></content>
      
      
      <categories>
          
          <category> CI/CD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2020/04/16/ThreadLocal/"/>
      <url>/2020/04/16/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<p>ThreadLocal提供了线程内部的局部变量，每个线程都可以通过get()和set()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，保证了多线程环境下数据的独立性，实现了线程的数据隔离。</p><a id="more"></a><h6 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h6><p>ThreadLocal提供了线程内部的局部变量，每个线程都可以通过get()和set()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，保证了多线程环境下数据的独立性，实现了线程的数据隔离。</p><p>以下是ThreadLocal常用的API</p><ul><li>threadLocal.get()方法，取当前线程存放在ThreadLocal里的数据 </li><li>threadLocal.set(T value)方法，设置当前线程在ThreadLocal里的数据</li><li>threadLocal.remove()方法，移除当前线程在ThreadLocal里的数据</li><li>threadLocal.initialValue()，返回当前线程在ThreadLocal里的初始值 </li></ul><h5 id="ThreadLocal的原理"><a href="#ThreadLocal的原理" class="headerlink" title="ThreadLocal的原理"></a>ThreadLocal的原理</h5><p>每个<code>Thread</code>维护一个<code>ThreadLocalMap</code>哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table &#x3D; new Entry[INITIAL_CAPACITY];</span><br><span class="line">    int i &#x3D; firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">    table[i] &#x3D; new Entry(firstKey, firstValue);</span><br><span class="line">    size &#x3D; 1;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ThreadLocal的get()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程维护的ThreadLocalMap</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    &#x2F;&#x2F; 如果map不为空</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 则以当前的ThreadLocal为key，调用ThreadLocalMap中的getEntry方法获取对应的存储实体e。</span><br><span class="line">        &#x2F;&#x2F; 找到对应的存储实体e，获取存储实体e对应的value值，即为我们想要的当前线程对应此ThreadLocal的值，返回结果值。</span><br><span class="line">        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result &#x3D; (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果ThreadLocalMap为空，则返回一个新的ThreadLocalMap</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>setInitiaValue方法如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    T value &#x3D; initialValue();</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>createMap方法如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ThreadLocal的set()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程维护的ThreadLocalMap</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    &#x2F;&#x2F; 如果map不为空</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; 赋值</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        &#x2F;&#x2F; 初始化ThreadLocalMap，并将此实体entry作为第一个值存放至ThreadLocalMap中</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ThreadLocal的remove()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程维护的ThreadLocalMap</span><br><span class="line">    ThreadLocalMap m &#x3D; getMap(Thread.currentThread());</span><br><span class="line">    if (m !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; 如果m不为空，以当前ThreadLocal为key移除</span><br><span class="line">        m.remove(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ThreadLocal中的内存泄漏问题"><a href="#ThreadLocal中的内存泄漏问题" class="headerlink" title="ThreadLocal中的内存泄漏问题"></a>ThreadLocal中的内存泄漏问题</h5><p>内存泄漏的定义： 对象不再被程序使用，但是因为它们仍在被引用导致垃圾收集器无法删除它们。<br>通过源码可以发现，<code>ThreadLocalMap</code>中的存储实体<code>Entry</code>使用<code>ThreadLocal</code>作为<code>key</code>，但这个<code>Entry</code>是继承弱引用<code>WeakReference</code>的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        super(k);</span><br><span class="line">        value &#x3D; v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它，那么系统 GC 的时候，这个<code>ThreadLocal</code>势必会被回收，从而造成内存泄漏。<br>那么我们既然知道了这个问题，每次使用完ThreadLocal，都调用它的<code>remove()</code>方法，清除数据，就不会造成内存泄漏的问题啦。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8中的并行计算</title>
      <link href="/2020/04/16/Java8%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"/>
      <url>/2020/04/16/Java8%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>从Java 8 开始，我们可以使用Stream接口以及lambda表达式进行“流式计算”。它可以让我们对集合的操作更加简洁、更加可读、更加高效。Stream接口有非常多用于集合计算的方法，比如判空操作empty、过滤操作filter、求最max值、查找操作findFirst和findAny等等。</p><a id="more"></a><p>从Java 8 开始，我们可以使用Stream接口以及lambda表达式进行“流式计算”。它可以让我们对集合的操作更加简洁、更加可读、更加高效。</p><p>Stream接口有非常多用于集合计算的方法，比如判空操作empty、过滤操作filter、求最max值、查找操作findFirst和findAny等等。</p><h5 id="什么是并行计算"><a href="#什么是并行计算" class="headerlink" title="什么是并行计算"></a>什么是并行计算</h5><p>假如我的计算机是一个多核计算机，我们在理论上能否利用多核来进行并行计算，提高计算效率呢？答案是可以的。</p><p><strong>比如我们在计算前两个元素1 + 2 = 3的时候，其实我们也可以同时在另一个核计算 3 + 4 = 7。然后等它们都计算完成之后，再计算 3 + 7 = 10的操作。</strong> 这就是并行计算，是和串行完全相反的概念。</p><h5 id="Stream如何实现并行计算"><a href="#Stream如何实现并行计算" class="headerlink" title="Stream如何实现并行计算"></a>Stream如何实现并行计算</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StreamParallelDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="line">                .parallel()</span><br><span class="line">                .reduce((a, b) -&gt; &#123;</span><br><span class="line">                    System.out.println(String.format(&quot;%s: %d + %d &#x3D; %d&quot;,</span><br><span class="line">                            Thread.currentThread().getName(), a, b, a + b));</span><br><span class="line">                    return a + b;</span><br><span class="line">                &#125;)</span><br><span class="line">                .ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-2: 8 + 9 &#x3D; 17</span><br><span class="line">ForkJoinPool.commonPool-worker-1: 3 + 4 &#x3D; 7</span><br><span class="line">ForkJoinPool.commonPool-worker-5: 1 + 2 &#x3D; 3</span><br><span class="line">ForkJoinPool.commonPool-worker-6: 5 + 6 &#x3D; 11</span><br><span class="line">ForkJoinPool.commonPool-worker-2: 7 + 17 &#x3D; 24</span><br><span class="line">ForkJoinPool.commonPool-worker-5: 3 + 7 &#x3D; 10</span><br><span class="line">ForkJoinPool.commonPool-worker-2: 11 + 24 &#x3D; 35</span><br><span class="line">ForkJoinPool.commonPool-worker-2: 10 + 35 &#x3D; 45</span><br><span class="line">45</span><br></pre></td></tr></table></figure><p>可以很明显地看到，它使用的线程是ForkJoinPool里面的commonPool里面的worker线程。并且它们是并行计算的，并不是串行计算的。但由于Fork/Join框架的作用，它最终能很好的协调计算结果，使得计算结果完全正确。</p><p>如果我们用Fork/Join代码去实现这样一个功能，那无疑是非常复杂的。但Java8提供了并行式的流式计算，大大简化了我们的代码量，使得我们只需要写很少很简单的代码就可以利用计算机底层的多核资源。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch</title>
      <link href="/2020/04/16/CountDownLatch/"/>
      <url>/2020/04/16/CountDownLatch/</url>
      
        <content type="html"><![CDATA[<p>先来解读一下CountDownLatch这个类名字的意义。CountDown代表计数递减，Latch是“门闩”的意思。也有人把它称为“屏障”。而CountDownLatch这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p><a id="more"></a><h5 id="CountDownLatch介绍"><a href="#CountDownLatch介绍" class="headerlink" title="CountDownLatch介绍"></a>CountDownLatch介绍</h5><p>先来解读一下CountDownLatch这个类名字的意义。CountDown代表计数递减，Latch是“门闩”的意思。也有人把它称为“屏障”。而CountDownLatch这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p><p>CountDownLatch的方法也很简单，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造方法：</span><br><span class="line">public CountDownLatch(int count)</span><br><span class="line"></span><br><span class="line">public void await() &#x2F;&#x2F; 等待</span><br><span class="line">public boolean await(long timeout, TimeUnit unit) &#x2F;&#x2F; 超时等待</span><br><span class="line">public void countDown() &#x2F;&#x2F; count - 1</span><br><span class="line">public long getCount() &#x2F;&#x2F; 获取当前还有多少count</span><br></pre></td></tr></table></figure><h5 id="CountDownLatch案例"><a href="#CountDownLatch案例" class="headerlink" title="CountDownLatch案例"></a>CountDownLatch案例</h5><p>我们知道，玩游戏的时候，在游戏真正开始之前，一般会等待一些前置任务完成，比如“加载地图数据”，“加载人物模型”，“加载背景音乐”等等。只有当所有的东西都加载完成后，玩家才能真正进入游戏。下面我们就来模拟一下这个demo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class PhaserDemo &#123;</span><br><span class="line">    static class PreTaskThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String task;</span><br><span class="line">        private Phaser phaser;</span><br><span class="line"></span><br><span class="line">        public PreTaskThread(String task, Phaser phaser) &#123;</span><br><span class="line">            this.task &#x3D; task;</span><br><span class="line">            this.phaser &#x3D; phaser;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt; 4; i++) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 第二次关卡起不加载NPC，跳过</span><br><span class="line">                    if (i &gt;&#x3D; 2 &amp;&amp; &quot;加载新手教程&quot;.equals(task)) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Random random &#x3D; new Random();</span><br><span class="line">                    Thread.sleep(random.nextInt(1000));</span><br><span class="line">                    System.out.println(String.format(&quot;关卡%d，需要加载%d个模块，当前模块【%s】&quot;,</span><br><span class="line">                            i, phaser.getRegisteredParties(), task));</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 从第二个关卡起，不加载NPC</span><br><span class="line">                    if (i &#x3D;&#x3D; 1 &amp;&amp; &quot;加载新手教程&quot;.equals(task)) &#123;</span><br><span class="line">                        System.out.println(&quot;下次关卡移除加载【新手教程】模块&quot;);</span><br><span class="line">                        phaser.arriveAndDeregister(); &#x2F;&#x2F; 移除一个模块</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        phaser.arriveAndAwaitAdvance();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Phaser phaser &#x3D; new Phaser(4) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected boolean onAdvance(int phase, int registeredParties) &#123;</span><br><span class="line">                System.out.println(String.format(&quot;第%d次关卡准备完成&quot;, phase + 1));</span><br><span class="line">                return phase &#x3D;&#x3D; 3 || registeredParties &#x3D;&#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载地图数据&quot;, phaser)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载人物模型&quot;, phaser)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载背景音乐&quot;, phaser)).start();</span><br><span class="line">        new Thread(new PreTaskThread(&quot;加载新手教程&quot;, phaser)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">关卡1，需要加载4个模块，当前模块【加载背景音乐】</span><br><span class="line">关卡1，需要加载4个模块，当前模块【加载新手教程】</span><br><span class="line">下次关卡移除加载【新手教程】模块</span><br><span class="line">关卡1，需要加载3个模块，当前模块【加载地图数据】</span><br><span class="line">关卡1，需要加载3个模块，当前模块【加载人物模型】</span><br><span class="line">第1次关卡准备完成</span><br><span class="line">关卡2，需要加载3个模块，当前模块【加载地图数据】</span><br><span class="line">关卡2，需要加载3个模块，当前模块【加载背景音乐】</span><br><span class="line">关卡2，需要加载3个模块，当前模块【加载人物模型】</span><br><span class="line">第2次关卡准备完成</span><br><span class="line">关卡3，需要加载3个模块，当前模块【加载人物模型】</span><br><span class="line">关卡3，需要加载3个模块，当前模块【加载地图数据】</span><br><span class="line">关卡3，需要加载3个模块，当前模块【加载背景音乐】</span><br><span class="line">第3次关卡准备完成</span><br></pre></td></tr></table></figure><h5 id="Phaser原理"><a href="#Phaser原理" class="headerlink" title="Phaser原理"></a>Phaser原理</h5><p>请各位看官移步<a href="https://www.jianshu.com/p/a9a713cba61a" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池的使用</title>
      <link href="/2020/04/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/04/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>为什么要使用线程池：创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）。可以对线程做统一管理。</p><a id="more"></a><h5 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h5><ul><li>创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。</li><li>控制并发的数量。并发数量过多，可能会导致资源消耗过多，从而造成服务器崩溃。（主要原因）。</li><li>可以对线程做统一管理。</li></ul><h5 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h5><p>Java中的线程池顶层接口是<code>Executor</code>接口，<code>ThreadPoolExecutor</code>是这个接口的实现类。</p><ul><li>我们先看一下<code>Executor</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Executor &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Executes the given command at some time in the future.  The command</span><br><span class="line">     * may execute in a new thread, in a pooled thread, or in the calling</span><br><span class="line">     * thread, at the discretion of the &#123;@code Executor&#125; implementation.</span><br><span class="line">     *</span><br><span class="line">     * @param command the runnable task</span><br><span class="line">     * @throws RejectedExecutionException if this task cannot be</span><br><span class="line">     * accepted for execution</span><br><span class="line">     * @throws NullPointerException if command is null</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void execute(Runnable command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们再看看<code>ThreadPoolExecutor</code>类。构造函数如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 五个参数的构造函数</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 六个参数的构造函数-1</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 六个参数的构造函数-2</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 七个参数的构造函数</span><br><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure><ul><li>关于构造函数的参数的含义</li></ul><p>1.int corePoolSize：该线程池中核心线程数最大值</p><blockquote><p>核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。</p></blockquote><p>2.int maximumPoolSize：该线程池中线程总数最大值 。</p><blockquote><p>该值等于核心线程数量 + 非核心线程数量。</p></blockquote><p>3.long keepAliveTime：非核心线程闲置超时时长。</p><blockquote><p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut(true)，则会也作用于核心线程。</p></blockquote><p>4.TimeUnit unit：keepAliveTime的单位。</p><p>5.BlockingQueue workQueue：阻塞队列，维护着等待执行的Runnable任务对象。</p><blockquote><p>常用的几个阻塞队列：</p><p>1.LinkedBlockingQueue</p><p>链式阻塞队列，底层数据结构是链表，默认大小是Integer.MAX_VALUE，也可以指定大小。</p><p>2.ArrayBlockingQueue</p><p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p><p>3.SynchronousQueue</p><p>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</p><p>4.DelayQueue</p><p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</p></blockquote><ul><li>线程池主要的任务处理流程</li></ul><p>处理任务的核心方法是execute，我们看看 JDK 1.8 源码中ThreadPoolExecutor是如何处理线程任务的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();   </span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    &#x2F;&#x2F; 1.当前线程数小于corePoolSize,则调用addWorker创建核心线程执行任务</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       if (addWorker(command, true))</span><br><span class="line">           return;</span><br><span class="line">       c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2.如果不小于corePoolSize，则将任务添加到workQueue队列。</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            &#x2F;&#x2F; 2.2 线程池处于running状态，但是没有线程，则创建线程</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3.如果放入workQueue失败，则创建非核心线程执行任务，</span><br><span class="line">    &#x2F;&#x2F; 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">         reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下处理流程</p><ol><li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。注意，这一步需要获得全局锁。</li><li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。</li><li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得全局锁。</li><li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li></ol><ul><li>线程池如何实现复用</li></ul><p>线程重用的核心是，我们知道，<strong>Thread.start()只能调用一次，一旦这个调用结束，则该线程就到了stop状态，不能再次调用start。</strong></p><p>则要达到复用的目的，则必须从Runnable接口的run()方法上入手，可以这样设计这个Runnable.run()方法（就叫外面的run()方法）：它本质上是个无限循环，跑的过程中不断检查我们是否有新加入的子Runnable对象（就叫内部的runnable:run()吧，它就是用来实现我们自己的任务），有就调一下我们的run()，其实就一个大run()把其它小run()#1,run()#2,…给串联起来了，基本原理就这么简单。</p><p>简单的说，线程池就是一组工人，任务是放在队列Queue里，一共就这么几个工人，当有空闲的工人，就会去队列里领取下一个任务，所以通过这种手段限制的总工人（线程）数量，即为复用。</p><h5 id="常见的线程池"><a href="#常见的线程池" class="headerlink" title="常见的线程池"></a>常见的线程池</h5><ul><li>newSingleThreadExecutor</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有且仅有一个核心线程（ corePoolSize == maximumPoolSize=1），使用了LinkedBlockingQueue（容量很大），所以，不会创建非核心线程。所有任务按照先来先执行的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p><ul><li>newFixedThreadPool</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">        return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心线程数量和总线程数量相等，都是传入的参数nThreads，所以只能创建核心线程，不能创建非核心线程。因为LinkedBlockingQueue的默认大小是Integer.MAX_VALUE，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p><ul><li>newCachedThreadPool</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行流程如下：</p><ol><li>提交任务进线程池。</li><li>因为corePoolSize为0的关系，不创建核心线程，线程池最大为Integer.MAX_VALUE。</li><li>尝试将任务添加到SynchronousQueue队列。</li><li>如果SynchronousQueue入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从SynchronousQueue拉取任务并在当前线程执行。</li><li>如果SynchronousQueue已有任务在等待，入列操作将会阻塞。</li></ol><p>当需要执行很多短时间的任务时，CacheThreadPool的线程复用率比较高， 会显著的提高性能。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool并不会占用很多资源。</p><ul><li>newScheduledThreadPool</li></ul><p>创建一个定长线程池，支持定时及周期性任务执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ScheduledThreadPoolExecutor():</span><br><span class="line">public ScheduledThreadPoolExecutor(int corePoolSize) &#123;</span><br><span class="line">    super(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          new DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyOnWrite容器</title>
      <link href="/2020/04/16/CopyOnWrite%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/04/16/CopyOnWrite%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>什么是CopyOnWrite容器，在说到CopyOnWrite容器之前我们先来谈谈什么是CopyOnWrite机制，CopyOnWrite是计算机设计领域中的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制思想。</p><a id="more"></a><h5 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h5><p>在说到CopyOnWrite容器之前我们先来谈谈什么是CopyOnWrite机制，CopyOnWrite是计算机设计领域中的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制思想。</p><p>那什么是写入时复制思想呢？就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，这个时候系统将会复制一个当前数据源的副本给调用者修改。</p><p>CopyOnWrite容器即<strong>写时复制的容器</strong>,当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p><p>这样做的好处在于，我们可以在并发的场景下对容器进行”读操作”而不需要”加锁”，从而达到读写分离的目的。从JDK 1.5 开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器 ，分别是CopyOnWriteArrayList和CopyOnWriteArraySet 。我们着重给大家介绍一下CopyOnWriteArrayList。</p><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5><p>优点： CopyOnWriteArrayList经常被用于“读多写少”的并发场景，是因为CopyOnWriteArrayList无需任何同步措施，大大增强了读的性能。在Java中遍历线程非安全的List(如：ArrayList和 LinkedList)的时候，若中途有别的线程对List容器进行修改，那么会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其”读写分离”，遍历和修改操作分别作用在不同的List容器，所以在使用迭代器遍历的时候，则不会抛出异常。</p><p>缺点： 第一个缺点是CopyOnWriteArrayList每次执行写操作都会将原容器进行拷贝了一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁Full GC（ZGC因为没有使用Full GC）。比如这些对象占用的内存比较大200M左右，那么再写入100M数据进去，内存就会多占用300M。</p><p>第二个缺点是CopyOnWriteArrayList由于实现的原因，写和读分别作用在不同新老容器上，在写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据。</p><p>现在我们来看一下CopyOnWriteArrayList的add操作源码，它的逻辑很清晰，就是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，在此过程中是加了锁的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ReentrantLock加锁，保证线程安全</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements &#x3D; getArray();</span><br><span class="line">        int len &#x3D; elements.length;</span><br><span class="line">        &#x2F;&#x2F; 拷贝原容器，长度为原容器长度加一</span><br><span class="line">        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);</span><br><span class="line">        &#x2F;&#x2F; 在新副本上执行添加操作</span><br><span class="line">        newElements[len] &#x3D; e;</span><br><span class="line">        &#x2F;&#x2F; 将原容器引用指向新副本</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 解锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看一下remove操作的源码，remove的逻辑是将要remove元素之外的其他元素拷贝到新的副本中，然后切换引用，再将原容器的引用指向新的副本中，因为remove操作也是“写操作”所以也是要加锁的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 加锁</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements &#x3D; getArray();</span><br><span class="line">        int len &#x3D; elements.length;</span><br><span class="line">        E oldValue &#x3D; get(elements, index);</span><br><span class="line">        int numMoved &#x3D; len - index - 1;</span><br><span class="line">        if (numMoved &#x3D;&#x3D; 0)</span><br><span class="line">            &#x2F;&#x2F; 如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用</span><br><span class="line">            Object[] newElements &#x3D; new Object[len - 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 解锁</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看看CopyOnWriteArrayList效率最高的读操作的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    return get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private E get(Object[] a, int index) &#123;</span><br><span class="line">    return (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上可见“读操作”是没有加锁，直接读取。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>CopyOnWrite容器有数据一致性的问题，它只能保证最终数据一致性。</p><p>所以如果我们希望写入的数据马上能准确地读取，请不要使用CopyOnWrite容器。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从ConcurrentHashMap中学到的并发编程技巧</title>
      <link href="/2020/04/16/%E4%BB%8EConcurrentHashMap%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
      <url>/2020/04/16/%E4%BB%8EConcurrentHashMap%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>ConcurrentHashMap是Doug Lea所写。它在JDK 1.7中用的是“分段锁”的思想，但在JDK 1.8中几乎重写了一遍，把数据结构简化成与HashMap类似，减小了锁的粒度，大道至简，进一步提升了它在多线程下的性能。这篇文章主要总结一下在ConcurrentHashMap源码学习过程中学到的一些并发编程的思想和技巧。</p><a id="more"></a><p>ConcurrentHashMap是Doug Lea所写。它在JDK 1.7中用的是“分段锁”的思想，但在JDK 1.8中几乎重写了一遍，把数据结构简化成与HashMap类似，减小了锁的粒度，大道至简，进一步提升了它在多线程下的性能。</p><p>这篇文章主要总结一下在ConcurrentHashMap源码学习过程中学到的一些并发编程的思想和技巧。</p><h5 id="使用volatile进行通信"><a href="#使用volatile进行通信" class="headerlink" title="使用volatile进行通信"></a>使用volatile进行通信</h5><p>在ConcurrentHashMap中有一个很重要的属性是<code>sizeCtl</code>它被用于初始化和扩容的过程中。且不同阶段它的值有不同的含义。比如在扩容阶段，它是一个负数，绝对值就代表了参与扩容的线程的数量。它是一个<code>volatile</code>变量，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private transient volatile int sizeCtl;</span><br></pre></td></tr></table></figure><p>在初始化或扩容等过程中，多个线程都会用到这个变量，它本身是volatile的，所以可以保证线程间的可见性。除此之外，多线程之间没有使用其它复杂的通信方式。</p><h5 id="使用CAS避免锁"><a href="#使用CAS避免锁" class="headerlink" title="使用CAS避免锁"></a>使用CAS避免锁</h5><p>在之前的那篇put源码解析的文章我们可以看到，put过程中，如果判断数组的某个位置没有结点的话，就会使用casTabAt方法来存放新的结点。这个方法底层是使用的Unsafe类的<code>compareAndSetObject</code>方法，是一个native的CAS方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; put过程</span><br><span class="line">else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">        break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; casTabAt方法，底层使用CAS</span><br><span class="line">static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">    return U.compareAndSetObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CAS也是一种“无锁编程”的思想。在可预测的较小的粒度下，可以使用CAS代替锁来提升性能。</p><h5 id="尽量减小锁的粒度"><a href="#尽量减小锁的粒度" class="headerlink" title="尽量减小锁的粒度"></a>尽量减小锁的粒度</h5><p>在面试中，可能经常会问到这个问题：HashMap, HashTable, ConcurrentHashMap有什么区别？稍微有点经验的人都能回答：“HashMap是线程不安全的，另外两个都是线程安全的，其中HashTable是在每个方法上使用了synchronized关键字，而ConcurrentHashMap使用了更小粒度的锁，ConcurrentHashMap在并发场景下性能更好。”</p><p>是的，ConcurrentHashMap为了提升性能，在JDK 1.7中使用了“分段锁”的概念，其核心思想是只锁住某一段，这样就不会影响其他段的数据，其它线程就可以并行地操作其它段的数据。“段”虽然相较于HashTable的整个实体来说，锁粒度有所降低，但仍然是一个较粗的粒度。</p><p>JDK 1.8对此作了进一步的改进，取消的“分段锁”的概念，直接以某个桶的头结点（如果是链表，就是首结点；如果是红黑树，就是根节点）来作为锁，使锁的粒度更低，能够更大程度地支持并发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (f) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="让空闲线程参与工作"><a href="#让空闲线程参与工作" class="headerlink" title="让空闲线程参与工作"></a>让空闲线程参与工作</h5><p>这是我觉得ConcurrentHashMap里面非常棒的一个思想。在Map进行扩容的时候，会锁住所有put、remove等操作。这个时候如果有其它线程进行put、remove操作，它不会阻塞在那里傻傻的等待。而是会先检查是否正在进行扩容，如果是，就参与进去帮助扩容。</p><p>与其让你闲着，不如来帮我先把扩容做完吧！</p><p>那这多个线程是怎么配合工作的呢？——仍然是上面提到的以头结点为锁，再配合自旋+CAS进行轻量级通信。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantReadWriteLock</title>
      <link href="/2020/04/16/ReentrantReadWriteLock/"/>
      <url>/2020/04/16/ReentrantReadWriteLock/</url>
      
        <content type="html"><![CDATA[<p>前面提到ReentrantLock，是一种“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。而读写锁可以再同一时刻允许多个读线程访问。Java提供了<code>ReentrantReadWriteLock</code>类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。</p><a id="more"></a><p>前面提到ReentrantLock，是一种“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。而读写锁可以再同一时刻允许多个读线程访问。Java提供了<code>ReentrantReadWriteLock</code>类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。</p><h5 id="ReadWriteLock接口"><a href="#ReadWriteLock接口" class="headerlink" title="ReadWriteLock接口"></a>ReadWriteLock接口</h5><p>这里面有两把锁，一把读锁，用来处理读相关的操作；一把写锁，用来处理写相关的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface ReadWriteLock &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the lock used for reading.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for reading</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Lock readLock();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the lock used for writing.</span><br><span class="line">     *</span><br><span class="line">     * @return the lock used for writing</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Lock writeLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ReentrantReadWriteLock类"><a href="#ReentrantReadWriteLock类" class="headerlink" title="ReentrantReadWriteLock类"></a>ReentrantReadWriteLock类</h5><p>这个类也是一个非抽象类，它是<code>ReadWriteLock</code>接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 内部结构</span><br><span class="line">private final ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line">private final ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line">final Sync sync;</span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">    &#x2F;&#x2F; 具体实现</span><br><span class="line">&#125;</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    &#x2F;&#x2F; 具体实现</span><br><span class="line">&#125;</span><br><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">    &#x2F;&#x2F; 具体实现</span><br><span class="line">&#125;</span><br><span class="line">public static class ReadLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    protected ReadLock(ReentrantReadWriteLock lock) &#123;</span><br><span class="line">            sync &#x3D; lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 具体实现</span><br><span class="line">&#125;</span><br><span class="line">public static class WriteLock implements Lock, java.io.Serializable &#123;</span><br><span class="line">    private final Sync sync;</span><br><span class="line">    protected WriteLock(ReentrantReadWriteLock lock) &#123;</span><br><span class="line">            sync &#x3D; lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 具体实现</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 构造方法，初始化两个锁</span><br><span class="line">public ReentrantReadWriteLock(boolean fair) &#123;</span><br><span class="line">    sync &#x3D; fair ? new FairSync() : new NonfairSync();</span><br><span class="line">    readerLock &#x3D; new ReadLock(this);</span><br><span class="line">    writerLock &#x3D; new WriteLock(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取读锁和写锁的方法</span><br><span class="line">public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125;</span><br><span class="line">public ReentrantReadWriteLock.ReadLock  readLock()  &#123; return readerLock; &#125;</span><br></pre></td></tr></table></figure><h5 id="读读共享"><a href="#读读共享" class="headerlink" title="读读共享"></a>读读共享</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class MyTask &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock lock &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    </span><br><span class="line">    public void read() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; start&quot;);</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; end&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReadReadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final MyTask myTask &#x3D; new MyTask();</span><br><span class="line">        </span><br><span class="line">        Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myTask.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        </span><br><span class="line">        Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myTask.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t2 start</span><br><span class="line">t1 start</span><br><span class="line">t1 end</span><br><span class="line">t2 end</span><br></pre></td></tr></table></figure><h5 id="写写互斥"><a href="#写写互斥" class="headerlink" title="写写互斥"></a>写写互斥</h5><p>在同一时间只允许一个线程执行lock()方法后面的代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class MyTask &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock lock &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    </span><br><span class="line">    public void write() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; start&quot;);</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; end&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReadReadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final MyTask myTask &#x3D; new MyTask();</span><br><span class="line">        </span><br><span class="line">        Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myTask.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        </span><br><span class="line">        Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myTask.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 start</span><br><span class="line">t1 end</span><br><span class="line">t2 start</span><br><span class="line">t2 end</span><br></pre></td></tr></table></figure><h5 id="读写互斥"><a href="#读写互斥" class="headerlink" title="读写互斥"></a>读写互斥</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class MyTask &#123;</span><br><span class="line"></span><br><span class="line">    private ReentrantReadWriteLock lock &#x3D; new ReentrantReadWriteLock();</span><br><span class="line">    </span><br><span class="line">    public void read() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.readLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; start&quot;);</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; end&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void write() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.writeLock().lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; start&quot;);</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot; end&quot;);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ReadReadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final MyTask myTask &#x3D; new MyTask();</span><br><span class="line">        </span><br><span class="line">        Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myTask.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        </span><br><span class="line">        Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myTask.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 start</span><br><span class="line">t1 end</span><br><span class="line">t2 start</span><br><span class="line">t2 end</span><br></pre></td></tr></table></figure><h5 id="写读互斥"><a href="#写读互斥" class="headerlink" title="写读互斥"></a>写读互斥</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ReadReadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final MyTask myTask &#x3D; new MyTask();</span><br><span class="line">        </span><br><span class="line">        Thread t1 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myTask.write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t1&quot;);</span><br><span class="line">        </span><br><span class="line">        Thread t2 &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                myTask.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;t2&quot;);</span><br><span class="line">        </span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 start</span><br><span class="line">t1 end</span><br><span class="line">t2 start</span><br><span class="line">t2 end</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>读操作的锁叫共享锁，写操作的锁叫排他锁。就是遇见写锁就需互斥。那么以此可得出读读共享，写写互斥，读写互斥，写读互斥。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock和Condition</title>
      <link href="/2020/04/16/ReentrantLock%E5%92%8CCondition/"/>
      <url>/2020/04/16/ReentrantLock%E5%92%8CCondition/</url>
      
        <content type="html"><![CDATA[<p>Java在<code>java.util.concurrent.locks</code>包下，还为我们提供了几个关于锁的类和接口，相对于<code>synchronized</code>它们有更强大的功能或更高的性能。</p><a id="more"></a><p>Java在<code>java.util.concurrent.locks</code>包下，还为我们提供了几个关于锁的类和接口，相对于<code>synchronized</code>它们有更强大的功能或更高的性能。</p><p><img src="https://img-blog.csdnimg.cn/20200319152940625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h5><ul><li>可重入锁和非可重入锁</li></ul><p>所谓重入锁，顾名思义。就是支持重新进入的锁，也就是说这个锁支持一个线程对资源重复加锁。</p><p><code>synchronized</code>关键字就是使用的重入锁。比如说，你在一个synchronized实例方法里面调用另一个本实例的synchronized实例方法，它可以重新进入这个锁，不会出现任何异常。</p><p>如果我们自己在继承AQS实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。</p><p><code>ReentrantLock</code>的中文意思就是可重入锁。也说本文后续要介绍的重点类。</p><ul><li>公平锁与非公平锁</li></ul><p>公平锁指的就是严格按照时间线的先后来工作。也就是说严格按照“先来后到”的理论工作，对于先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。</p><p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。所以要根据实际的需求来选择非公平锁和公平锁。</p><p><code>ReentrantLock</code>支持非公平锁和公平锁两种。</p><ul><li>读写锁和排它锁</li></ul><p>我们前面知道的<code>synchronized</code>用的锁和<code>ReentrantLock</code>，其实都是“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。</p><p>而读写锁可以再同一时刻允许多个读线程访问。Java提供了<code>ReentrantReadWriteLock</code>类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p><h5 id="ReentrantLock解读"><a href="#ReentrantLock解读" class="headerlink" title="ReentrantLock解读"></a>ReentrantLock解读</h5><p>ReentrantLock是一个非抽象类，它是Lock接口的JDK默认实现，实现了锁的基本功能。从名字上看，它是一个“可重入”锁，从源码上看，它内部有一个抽象类<code>Sync</code>，是继承了<code>AQS</code>，自己实现的一个同步器。同时，ReentrantLock内部有两个非抽象类NonfairSync和FairSync，它们都继承了Sync。从名字上看得出，分别是”非公平同步器“和”公平同步器“的意思。这意味着ReentrantLock可以支持”公平锁“和”非公平锁“。</p><p>通过看着两个同步器的源码可以发现，它们的实现都是”独占“的。都调用了AOS的setExclusiveOwnerThread方法，所以ReentrantLock的锁的”独占“的，也就是说，它的锁都是”排他锁“，不能共享。</p><p>在ReentrantLock的构造方法里，可以传入一个boolean类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过isFair()方法来查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取锁，获取不到lock就不罢休，不可被打断,即使当前线程被中断，线程也一直阻塞，直到拿到锁， 比较无赖的做法。</span><br><span class="line">void lock();</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">*获取锁，可中断，如果获取锁之前当前线程被interrupt了，</span><br><span class="line">*获取锁之后会抛出InterruptedException，并且停止当前线程；</span><br><span class="line">*优先响应中断</span><br><span class="line">*&#x2F;</span><br><span class="line">void lockInterruptibly() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;立即返回结果；尝试获得锁,如果获得锁立即返回ture,失败立即返回false</span><br><span class="line">boolean tryLock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;尝试拿锁，可设置超时时间，超时返回false，即过时不候</span><br><span class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放锁</span><br><span class="line">void unlock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回当前线程的Condition ，可多次调用</span><br><span class="line">Condition newCondition();</span><br></pre></td></tr></table></figure><p>通常的使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void test() &#123;</span><br><span class="line">    ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">    Thread thread1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            &#x2F;&#x2F; todo...</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        </span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h5><ul><li><p>提供了类似Object监视器的方法，通过与Lock配合来实现等待/通知模式。（可以代替<code>Object</code>的<code>wait</code>/<code>notify</code>），Condition和Object的wait/notify基本相似。</p></li><li><p>Condition的signal/signalAll方法则对应Object的notify/notifyAll()。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public interface Condition &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，</span><br><span class="line">*允许中断如果在阻塞时锁持有线程中断，会抛出异常；</span><br><span class="line">*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，</span><br><span class="line">*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁</span><br><span class="line">*&#x2F;</span><br><span class="line">    void await() throws InterruptedException;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒</span><br><span class="line">    void awaitUninterruptibly();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时</span><br><span class="line">    long awaitNanos(long nanosTimeout) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false</span><br><span class="line">    boolean await(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;类似await(long time, TimeUnit unit) </span><br><span class="line">    boolean awaitUntil(Date deadline) throws InterruptedException;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;唤醒指定线程</span><br><span class="line">    void signal();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;唤醒全部线程</span><br><span class="line">    void signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>生产者-消费者模型的交替打印英文字母和数字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static void alternateTask() &#123;</span><br><span class="line">        ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">        Condition condition1 &#x3D; lock.newCondition();</span><br><span class="line">        Condition condition2 &#x3D; lock.newCondition();</span><br><span class="line">        Thread thread1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                for (int i &#x3D; 65; i &lt; 91; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;----------thread1------- &quot; + (char) i);</span><br><span class="line">                    condition2.signal();</span><br><span class="line">                    condition1.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition2.signal();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                for (int i &#x3D; 0; i &lt; 26; i++) &#123;</span><br><span class="line">                    System.out.println(&quot;----------thread2------- &quot; + i);</span><br><span class="line">                    condition1.signal();</span><br><span class="line">                    condition2.await();</span><br><span class="line">                &#125;</span><br><span class="line">                condition1.signal();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">----------thread1------- A</span><br><span class="line">----------thread2------- 0</span><br><span class="line">----------thread1------- B</span><br><span class="line">----------thread2------- 1</span><br><span class="line">----------thread1------- C</span><br><span class="line">----------thread2------- 2</span><br><span class="line">----------thread1------- D</span><br><span class="line">----------thread2------- 3</span><br><span class="line">----------thread1------- E</span><br><span class="line">----------thread2------- 4</span><br><span class="line">----------thread1------- F</span><br><span class="line">----------thread2------- 5</span><br><span class="line">----------thread1------- G</span><br><span class="line">----------thread2------- 6</span><br><span class="line">----------thread1------- H</span><br><span class="line">----------thread2------- 7</span><br><span class="line">----------thread1------- I</span><br><span class="line">----------thread2------- 8</span><br><span class="line">----------thread1------- J</span><br><span class="line">----------thread2------- 9</span><br><span class="line">----------thread1------- K</span><br><span class="line">----------thread2------- 10</span><br><span class="line">----------thread1------- L</span><br><span class="line">----------thread2------- 11</span><br><span class="line">----------thread1------- M</span><br><span class="line">----------thread2------- 12</span><br><span class="line">----------thread1------- N</span><br><span class="line">----------thread2------- 13</span><br><span class="line">----------thread1------- O</span><br><span class="line">----------thread2------- 14</span><br><span class="line">----------thread1------- P</span><br><span class="line">----------thread2------- 15</span><br><span class="line">----------thread1------- Q</span><br><span class="line">----------thread2------- 16</span><br><span class="line">----------thread1------- R</span><br><span class="line">----------thread2------- 17</span><br><span class="line">----------thread1------- S</span><br><span class="line">----------thread2------- 18</span><br><span class="line">----------thread1------- T</span><br><span class="line">----------thread2------- 19</span><br><span class="line">----------thread1------- U</span><br><span class="line">----------thread2------- 20</span><br><span class="line">----------thread1------- V</span><br><span class="line">----------thread2------- 21</span><br><span class="line">----------thread1------- W</span><br><span class="line">----------thread2------- 22</span><br><span class="line">----------thread1------- X</span><br><span class="line">----------thread2------- 23</span><br><span class="line">----------thread1------- Y</span><br><span class="line">----------thread2------- 24</span><br><span class="line">----------thread1------- Z</span><br><span class="line">----------thread2------- 25</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发容器之ConcurrentHashMap</title>
      <link href="/2020/04/16/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap/"/>
      <url>/2020/04/16/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p>我们知道在java.util包下提供了一些容器类，而Vector和HashTable是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。</p><a id="more"></a><p>我们知道在java.util包下提供了一些容器类，而Vector和HashTable是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。</p><h5 id="ConcurrentMap接口"><a href="#ConcurrentMap接口" class="headerlink" title="ConcurrentMap接口"></a>ConcurrentMap接口</h5><p>ConcurrentMap接口继承了Map接口，在Map接口的基础上又定义了四个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;插入元素，与原有put方法不同的是，putIfAbsent方法中如果插入的key相同，则不替换原有的value值；</span><br><span class="line">    V putIfAbsent(K key, V value);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;移除元素，与原有remove方法不同的是，新remove方法中增加了对value的判断，如果要删除的key-value不能与Map中原有的key-value对应上，则不会删除该元素;</span><br><span class="line">    boolean remove(Object key, Object value);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;替换元素，增加了对value值的判断，如果key-oldValue能与Map中原有的key-value对应上，才进行替换操作；</span><br><span class="line">    boolean replace(K key, V oldValue, V newValue);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;替换元素，与上面的replace不同的是，此replace不会对Map中原有的key-value进行比较，如果key存在则直接替换；</span><br><span class="line">    V replace(K key, V value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ConcurrentHashMap类"><a href="#ConcurrentHashMap类" class="headerlink" title="ConcurrentHashMap类"></a>ConcurrentHashMap类</h5><p>ConcurrentHashMap同HashMap一样也是基于散列表的map，但是它提供了一种与HashTable完全不同的加锁策略提供更高效的并发性和伸缩性。</p><p>ConcurrentHashMap提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫分段锁(Lock Striping)。</p><p>提供的优点是：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。</p><p>可以这样理解分段锁，就是将数据分段，对每一段数据分配一把锁。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>有些方法需要跨段，比如size()、isEmpty()、containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。如下图：</p><p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，HashEntry则用于存储键值对数据。</p><p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构（同HashMap一样，它也会在长度达到8的时候转化为红黑树）的元素， 每个Segment守护者一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p><h5 id="ConcurrentHashMap的put过程-基于1-8"><a href="#ConcurrentHashMap的put过程-基于1-8" class="headerlink" title="ConcurrentHashMap的put过程(基于1.8)"></a>ConcurrentHashMap的put过程(基于1.8)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(key, value, false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Implementation for put and putIfAbsent *&#x2F;</span><br><span class="line">    final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    &#x2F;&#x2F; key 和 value都不能为空</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        &#x2F;&#x2F; 再哈希，防止用户自己写的哈希算法导致分布不均匀</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        &#x2F;&#x2F; 这个位置元素的个数</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 死循环</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            &#x2F;&#x2F; 如果没有初始化，就先进行初始化</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">                &#x2F;&#x2F; 根据hash，取table上相应位置的第一个结点f，判断它是否为空</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果为空，用cas添加进去</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果当前节点是一个forwarding节点，表示在resize过程中</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">            &#x2F;&#x2F; 如果在resize过程中，帮助转换</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">                &#x2F;&#x2F; 检查第一个没有申请锁的结点</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 以第一个结点为锁</span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果f是第一个结点</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            &#x2F;&#x2F; 死循环，每次binCount加1</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                &#x2F;&#x2F; 如果当前节点的hash等于key的hashCode，</span><br><span class="line">                    &#x2F;&#x2F; 且当前节点的key equals key</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                     &#x2F;&#x2F; 说明key已经存在，获取原来的值</span><br><span class="line">                                    oldVal &#x3D; e.val;</span><br><span class="line">                                    if (!onlyIfAbsent)</span><br><span class="line">                                    &#x2F;&#x2F; 替换这个节点的值</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                &#x2F;&#x2F; 如果弄到最后还是为空，说明key不存在</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                &#x2F;&#x2F; 在链表尾部插入一个新的节点</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 如果是红黑树结点</span><br><span class="line">                        else if (f instanceof TreeBin) &#123;</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            &#x2F;&#x2F; 调用红黑树的put方法，其内部也是使用的CAS，并判断key是否已存在</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123;</span><br><span class="line">                                &#x2F;&#x2F; key存在，得到原来值</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                &#x2F;&#x2F; 设置新值</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 如果binCount不为0，插入成功了，否则会进入再一次的循环</span><br><span class="line">                if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果大于转换红黑树的阈值</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                    &#x2F;&#x2F; 转换成红黑树，内部以根结点为锁</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                        &#x2F; 如果key已存在，有原值，返回原值</span><br><span class="line">                    if (oldVal !&#x3D; null)</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 元素计数加1，根据binCount来检验是否需要检查和扩容</span><br><span class="line">   &#x2F;&#x2F; 如果&lt;0，不会检查。这里不会小于0</span><br><span class="line">    &#x2F;&#x2F; 如果&lt;&#x3D;1，会检查uncontended。</span><br><span class="line">    &#x2F;&#x2F; 如果&gt;1，会检查并尝试扩容</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结一下put的过程：</p><ol><li>先检查key和value都不能为空，如果为空，就抛出空指针异常； </li><li>对key再哈希，防止用户自己写的哈希算法导致分布不均匀；</li><li>检查是否已经进行了初始化，如果没有，要先初始化；</li><li>根据再hash的值，计算在table上的位置的第一个结点f，如果f为空，用CAS直接插入；否则，进行第5步；</li><li>检查f是否是一个forwarding结点，如果是表示正在扩容，当前线程就去帮助扩容；如果不是，进行第6步；</li><li>检查f的key是不是等于要插入的key，如果是，获取原来的值并替换成新的值，如果不是，进行第7步；</li><li>以第一个结点为锁；</li><li>如果f不是红黑树结点，进行第9步，如果是红黑树结点，进行第11步；</li><li>根据链表向下找，如果找到key相等的位置，获取原来的值并替换成新的值；</li><li>如果一直到链表末尾也没有找到相等的key，就在链表尾部插入一个新节点；</li><li>调用红黑树的putTreeVal方法，其内部是使用CAS，也会判断key是否已经存在并返回旧值；</li><li>如果是保留的Node类型ReservationNode，直接抛出异常；</li><li>根据binCount判断是否达到链表转红黑树的阈值，如果达到了，转成红黑树，这个过程会以根节点为锁；</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁和悲观锁</title>
      <link href="/2020/04/16/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>/2020/04/16/%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p><a id="more"></a><p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>乐观锁又称为“无锁”，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为CAS的技术来保证线程执行的安全性。</p><p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说乐观锁天生免疫死锁。</p><h5 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h5><p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p><h5 id="悲观锁常见的实现方式"><a href="#悲观锁常见的实现方式" class="headerlink" title="悲观锁常见的实现方式"></a>悲观锁常见的实现方式</h5><ul><li>使用<code>synchronized</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void testMethod() &#123;</span><br><span class="line">      &#x2F;&#x2F;操作同步资源 </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>Lock</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Private ReentrantLock lock &#x3D; new ReentrantLock(); </span><br><span class="line"></span><br><span class="line">Public void modifyPublicResource() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    &#x2F;&#x2F;操作同步资源</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="乐观锁常见的实现方式"><a href="#乐观锁常见的实现方式" class="headerlink" title="乐观锁常见的实现方式"></a>乐观锁常见的实现方式</h5><ul><li>版本号机制</li></ul><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p><ul><li>CAS算法</li></ul><p>Java.util.concurrent包中的原子类就是通过CAS实现了乐观锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private AtomicInteger atomicInteger &#x3D; new AtomicInteger();  </span><br><span class="line"></span><br><span class="line">AtomicInteger.incrementAndGet();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程安全和死锁</title>
      <link href="/2020/04/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%AD%BB%E9%94%81/"/>
      <url>/2020/04/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>什么叫线程安全？线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p><a id="more"></a><h5 id="什么叫线程安全？"><a href="#什么叫线程安全？" class="headerlink" title="什么叫线程安全？"></a>什么叫线程安全？</h5><p>线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。</p><h5 id="如果线程不安全会出现什么情况？"><a href="#如果线程不安全会出现什么情况？" class="headerlink" title="如果线程不安全会出现什么情况？"></a>如果线程不安全会出现什么情况？</h5><p>举个例子，正常情况下，一张火车票只能卖给一个人，但是在售票的核心代码块的地方你并没有加锁，就可能会出现线程不安全的情况，从而导致一张火车票可能会卖给多个人的情况发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static class SellTickets implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (tickets &gt; 0) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;---&gt;售出第：  &quot; + tickets + &quot; 票&quot;);</span><br><span class="line">                tickets--;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (tickets &lt;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;---&gt;售票结束！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        SellTickets sell &#x3D; new SellTickets();</span><br><span class="line"></span><br><span class="line">        Thread thread1 &#x3D; new Thread(sell, &quot;1号窗口&quot;);</span><br><span class="line">        Thread thread2 &#x3D; new Thread(sell, &quot;2号窗口&quot;);</span><br><span class="line">        Thread thread3 &#x3D; new Thread(sell, &quot;3号窗口&quot;);</span><br><span class="line">        Thread thread4 &#x3D; new Thread(sell, &quot;4号窗口&quot;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1号窗口---&gt;售出第：  10 票</span><br><span class="line">4号窗口---&gt;售出第：  10 票</span><br><span class="line">3号窗口---&gt;售出第：  10 票</span><br><span class="line">2号窗口---&gt;售出第：  10 票</span><br><span class="line">3号窗口---&gt;售出第：  6 票</span><br><span class="line">2号窗口---&gt;售出第：  6 票</span><br><span class="line">4号窗口---&gt;售出第：  6 票</span><br><span class="line">1号窗口---&gt;售出第：  6 票</span><br><span class="line">3号窗口---&gt;售出第：  2 票</span><br><span class="line">4号窗口---&gt;售出第：  2 票</span><br><span class="line">2号窗口---&gt;售出第：  2 票</span><br><span class="line">1号窗口---&gt;售出第：  2 票</span><br><span class="line">3号窗口---&gt;售票结束！</span><br><span class="line">1号窗口---&gt;售票结束！</span><br><span class="line">4号窗口---&gt;售票结束！</span><br><span class="line">2号窗口---&gt;售票结束！</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h5 id="如何实现线程安全"><a href="#如何实现线程安全" class="headerlink" title="如何实现线程安全"></a>如何实现线程安全</h5><ul><li>使用自动锁synchronized，但是在大数据量的场景下，效率比较低。</li><li>使用安全类，比如 java.util.concurrent 下的类，使用原子类AtomicInteger，推荐。</li><li>使用手动锁 Lock，推荐。</li></ul><p>那么修改一下上面的代码，采用lock()加锁，unlock()解锁，来保护指定的代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static class SellTickets implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">       Lock lock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           &#x2F;&#x2F; Lock锁机制</span><br><span class="line">           while (tickets &gt; 0) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   lock.lock();</span><br><span class="line">                   if (tickets &lt;&#x3D; 0) &#123;</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">                   System.out.println(Thread.currentThread().getName() + &quot;---&gt;售出第：  &quot; + tickets + &quot; 票&quot;);</span><br><span class="line">                   tickets--;</span><br><span class="line">               &#125; catch (Exception e1) &#123;</span><br><span class="line">                   &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">                   e1.printStackTrace();</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   lock.unlock();</span><br><span class="line">                   try &#123;</span><br><span class="line">                       Thread.sleep(100);</span><br><span class="line">                   &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (tickets &lt;&#x3D; 0) &#123;</span><br><span class="line"></span><br><span class="line">               System.out.println(Thread.currentThread().getName() + &quot;---&gt;售票结束！&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1号窗口---&gt;售出第：  10 票</span><br><span class="line">2号窗口---&gt;售出第：  9 票</span><br><span class="line">3号窗口---&gt;售出第：  8 票</span><br><span class="line">4号窗口---&gt;售出第：  7 票</span><br><span class="line">3号窗口---&gt;售出第：  6 票</span><br><span class="line">2号窗口---&gt;售出第：  5 票</span><br><span class="line">1号窗口---&gt;售出第：  4 票</span><br><span class="line">4号窗口---&gt;售出第：  3 票</span><br><span class="line">3号窗口---&gt;售出第：  2 票</span><br><span class="line">1号窗口---&gt;售出第：  1 票</span><br><span class="line">4号窗口---&gt;售票结束！</span><br><span class="line">2号窗口---&gt;售票结束！</span><br><span class="line">3号窗口---&gt;售票结束！</span><br><span class="line">1号窗口---&gt;售票结束！</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h5 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h5><p>死锁指的是当线程t1占有资源A，线程t2占有资源B，这个时候t1同时去请求资源B，t2同时去请求资源A，这是两个线程就会互相等待而进入死锁状态。</p><h5 id="形成死锁的四个必要条件是什么"><a href="#形成死锁的四个必要条件是什么" class="headerlink" title="形成死锁的四个必要条件是什么"></a>形成死锁的四个必要条件是什么</h5><ul><li>互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放</li><li>请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞</li></ul><h5 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h5><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><ul><li>破坏互斥条件</li></ul><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><ul><li>破坏请求与保持条件</li></ul><p>一次性申请所有的资源。</p><ul><li>破坏不剥夺条件</li></ul><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><ul><li>破坏循环等待条件</li></ul><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/2020/04/16/CAS/"/>
      <url>/2020/04/16/CAS/</url>
      
        <content type="html"><![CDATA[<p>CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：V：要更新的变量(var)；E：预期值(expected)；N：新值(new)。</p><a id="more"></a><h5 id="CAS的概念"><a href="#CAS的概念" class="headerlink" title="CAS的概念"></a>CAS的概念</h5><p>CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：</p><ul><li>V：要更新的变量(var)</li><li>E：预期值(expected)</li><li>N：新值(new)</li></ul><p>比较并交换的过程如下：</p><p>判断V是否等于E，如果等于，将V的值设置为N；如果不等，说明已经有其它线程更新了V，则当前线程放弃更新，什么都不做。</p><h5 id="CAS的过程"><a href="#CAS的过程" class="headerlink" title="CAS的过程"></a>CAS的过程</h5><p>我们以一个简单的例子来解释这个过程：</p><ul><li>如果有一个多个线程共享的变量i原本等于5，我现在在线程A中，想把它设置为新的值6;<br>我们使用CAS来做这个事情；</li><li>首先我们用i去与5对比，发现它等于5，说明没有被其它线程改过，那我就把它设置为新的值6，此次CAS成功，i的值被设置成了6；</li><li>如果不等于5，说明i被其它线程改过了（比如现在i的值为2），那么我就什么也不做，此次CAS失败，i的值仍然为2。</li><li>在这个例子中，i就是V，5就是E，6就是N。</li></ul><p>那有没有可能我在判断了i为5之后，正准备更新它的新值的时候，被其它线程更改了i的值呢？</p><p>不会的。因为<code>CAS是一种原子操作</code>，它是一种系统原语，是一条CPU的原子指令，从CPU层面保证它的原子性</p><p><strong>当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p><h5 id="通过AtomicInteger看CAS实现原理"><a href="#通过AtomicInteger看CAS实现原理" class="headerlink" title="通过AtomicInteger看CAS实现原理"></a>通过AtomicInteger看CAS实现原理</h5><p>首先我们看一下<code>java.util.concurrent.atomic</code>这个包，这个包里有很多类。</p><p><img src="https://img-blog.csdnimg.cn/20200319103630885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里我们以<code>AtomicInteger</code>类的<code>getAndSet(int newValue)</code>方法为例，来看看Java是如何实现原子操作的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Atomically sets to the given value and returns the old value.</span><br><span class="line"> *</span><br><span class="line"> * @param newValue the new value</span><br><span class="line"> * @return the previous value</span><br><span class="line"> *&#x2F;</span><br><span class="line">public final int getAndSet(int newValue) &#123;</span><br><span class="line">    return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>unsafe</code>是<code>sun.misc</code>包里面的一个类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package sun.misc;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.security.ProtectionDomain;</span><br><span class="line">import sun.reflect.CallerSensitive;</span><br><span class="line">import sun.reflect.Reflection;</span><br><span class="line"></span><br><span class="line">public final class Unsafe &#123; &#125;</span><br></pre></td></tr></table></figure><p>所以说<code>getAndSet()</code>方法是调用的<code>unsafe</code>的<code>getAndSetInt()</code>方法。在<code>Unsafe</code>类中有很多native方法，众所周知，native方法Java就不负责具体实现它，而是交给底层的JVM使用c或者c++去实现。<code>Unsafe</code>中对CAS的实现是C++写的，它的具体实现和操作系统、CPU都有关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final int getAndSetInt(Object var1, long var2, int var4) &#123;</span><br><span class="line">    int var5;</span><br><span class="line">    do &#123;</span><br><span class="line">        var5 &#x3D; this.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来一步步解析这段源码。首先，对象var1是一个AtomicInteger对象。然后var2是一个常量VALUE，这个常量是在AtomicInteger类中声明的，var4是新值。</p><p>继续看源码。前面我们讲到，CAS是“无锁”的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。</p><p>这里声明了一个var5，也就是要返回的值。从getAndAddInt来看，它返回的应该是原来的值，而新的值的等于var5 + var4。</p><p>这里使用的是do-while循环。这种循环不多见，它的目的是保证循环体内的语句至少会被执行一遍。这样才能保证return的var5值是我们期望的值。</p><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>所谓ABA问题，就是一个值原来是A，变成了B，又变回了A。这个时候使用CAS是检查不出变化的，但实际上却被更新了两次。</p><p>ABA问题的解决思路是在变量前面追加上<code>版本号</code>或者<code>时间戳</code>。从JDK 1.5开始，JDK的atomic包里提供了一个类<code>AtomicStampedReference</code>类来解决ABA问题。</p><p>这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用CAS设置为新的值和标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * Atomically sets the value of both the reference and stamp</span><br><span class="line">    * to the given update values if the</span><br><span class="line">    * current reference is &#123;@code &#x3D;&#x3D;&#125; to the expected reference</span><br><span class="line">    * and the current stamp is equal to the expected stamp.</span><br><span class="line">    *</span><br><span class="line">    * @param expectedReference the expected value of the reference</span><br><span class="line">    * @param newReference the new value for the reference</span><br><span class="line">    * @param expectedStamp the expected value of the stamp</span><br><span class="line">    * @param newStamp the new value for the stamp</span><br><span class="line">    * @return &#123;@code true&#125; if successful</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public boolean compareAndSet(V   expectedReference,</span><br><span class="line">                                V   newReference,</span><br><span class="line">                                int expectedStamp,</span><br><span class="line">                                int newStamp) &#123;</span><br><span class="line">       Pair&lt;V&gt; current &#x3D; pair;</span><br><span class="line">       return</span><br><span class="line">           expectedReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">           expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp;</span><br><span class="line">           ((newReference &#x3D;&#x3D; current.reference &amp;&amp;</span><br><span class="line">             newStamp &#x3D;&#x3D; current.stamp) ||</span><br><span class="line">            casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="循环时间长开销大问题"><a href="#循环时间长开销大问题" class="headerlink" title="循环时间长开销大问题"></a>循环时间长开销大问题</h5><p>CAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。</p><p>解决思路是让JVM支持处理器提供的pause指令。</p><p>pause指令能让自旋失败时cpu睡眠一小段时间再继续自旋，从而使得读操作的频率低很多,为解决内存顺序冲突而导致的CPU流水线重排的代价也会小很多。</p><h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p>这个问题你可能已经知道怎么解决了。有两种解决方案：</p><ul><li>使用JDK 1.5开始就提供的<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行CAS操作；</li><li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li></ul><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul><li>《Java并发编程的艺术》</li><li>《JAVA并发编程实战》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS</title>
      <link href="/2020/04/16/AQS/"/>
      <url>/2020/04/16/AQS/</url>
      
        <content type="html"><![CDATA[<p><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即抽象队列同步器。抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；队列：使用先进先出（FIFO）队列存储数据；同步：实现了同步的功能。</p><a id="more"></a><h5 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h5><p><strong>AQS</strong>是<code>AbstractQueuedSynchronizer</code>的简称，即抽象队列同步器，从字面意思上理解:</p><ul><li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li><li>队列：使用先进先出（FIFO）队列存储数据；</li><li>同步：实现了同步的功能。</li></ul><p>那AQS有什么用呢？AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的同步器，比如我们提到的ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p><p>AQS的数据结构</p><p>AQS内部使用了一个volatile的变量state来作为资源的标识。同时定义了几个获取和改版state的protected方法，子类可以覆盖这些方法来实现自己的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState()</span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure><p>这三种叫做均是原子操作，其中compareAndSetState的实现依赖于Unsafe的compareAndSwapInt()方法。</p><p>而AQS类本身实现的是一些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针head和tail用于标识队列的头部和尾部。其数据结构如图：</p><p><img src="https://img-blog.csdnimg.cn/20200417094244214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>但它并不是直接储存线程，而是储存拥有线程的Node节点</p><h5 id="资源共享模式"><a href="#资源共享模式" class="headerlink" title="资源共享模式"></a>资源共享模式</h5><p>资源有两种共享模式，或者说两种同步方式：</p><ul><li>独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如ReentrantLock。</li><li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如Semaphore/CountDownLatch。</li></ul><p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。</p><p>AQS中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看Node的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">static final class Node &#123;</span><br><span class="line">    &#x2F;&#x2F; 标记一个结点（对应的线程）在共享模式下等待</span><br><span class="line">    static final Node SHARED &#x3D; new Node();</span><br><span class="line">    &#x2F;&#x2F; 标记一个结点（对应的线程）在独占模式下等待</span><br><span class="line">    static final Node EXCLUSIVE &#x3D; null; </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示该结点（对应的线程）已被取消</span><br><span class="line">    static final int CANCELLED &#x3D; 1; </span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span><br><span class="line">    static final int SIGNAL &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F; waitStatus的值，表示该结点（对应的线程）在等待某一条件</span><br><span class="line">    static final int CONDITION &#x3D; -2;</span><br><span class="line">    &#x2F;*waitStatus的值，表示有资源可用，新head结点需要继续唤醒后继结点（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；设置新的head结点时，会继续唤醒其后继结点）*&#x2F;</span><br><span class="line">    static final int PROPAGATE &#x3D; -3;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 等待状态，取值范围，-3，-2，-1，0，1</span><br><span class="line">    volatile int waitStatus;</span><br><span class="line">    volatile Node prev; &#x2F;&#x2F; 前驱结点</span><br><span class="line">    volatile Node next; &#x2F;&#x2F; 后继结点</span><br><span class="line">    volatile Thread thread; &#x2F;&#x2F; 结点对应的线程</span><br><span class="line">    Node nextWaiter; &#x2F;&#x2F; 等待队列里下一个等待条件的结点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断共享模式的方法</span><br><span class="line">    final boolean isShared() &#123;</span><br><span class="line">        return nextWaiter &#x3D;&#x3D; SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     &#x2F;&#x2F; Used by addWaiter</span><br><span class="line">        this.nextWaiter &#x3D; mode;</span><br><span class="line">        this.thread &#x3D; thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其它方法忽略，可以参考具体的源码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AQS里面的addWaiter私有方法</span><br><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用了Node的这个构造函数</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; 其它代码省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：通过Node我们可以实现两个队列，一是通过prev和next实现CLH队列(线程同步队列,双向队列)，二是nextWaiter实现Condition条件上的等待线程队列(单向队列)，这个Condition主要用在ReentrantLock类中。</p></blockquote><h5 id="AQS的主要方法源码解析"><a href="#AQS的主要方法源码解析" class="headerlink" title="AQS的主要方法源码解析"></a>AQS的主要方法源码解析</h5><p>AQS的设计是基于模板方法模式的，它有一些方法必须要子类去实现的，它们主要有：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>这些方法虽然都是<code>protected</code>方法，但是它们并没有在AQS具体实现，而是直接抛出异常（虽然不知道这里为什么不使用抽象方法的实现方式）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而AQS实现了一系列主要的逻辑。下面我们从源码来分析一下获取和释放资源的主要逻辑：</p><p><strong>获取资源</strong></p><p>获取资源的入口是acquire(int arg)方法。arg是要获取的资源的个数，在独占模式下始终为1。我们先来看看这个方法的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用tryAcquire(arg)尝试去获取资源。前面提到了这个方法是在子类具体实现的。</p><p>如果获取资源失败，就通过addWaiter(Node.EXCLUSIVE)方法把这个线程插入到等待队列中。其中传入的参数代表要插入的Node是独占式的。这个方法的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 生成该线程对应的Node节点</span><br><span class="line">    Node node &#x3D; new Node(Thread.currentThread(), mode);</span><br><span class="line">    &#x2F;&#x2F; 将Node插入队列中</span><br><span class="line">    Node pred &#x3D; tail;</span><br><span class="line">    if (pred !&#x3D; null) &#123;</span><br><span class="line">        node.prev &#x3D; pred;</span><br><span class="line">        &#x2F;&#x2F; 使用CAS尝试，如果成功就返回</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next &#x3D; node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 自旋CAS插入等待队列</span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t &#x3D; tail;</span><br><span class="line">        if (t &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail &#x3D; head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.prev &#x3D; t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next &#x3D; node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的两个函数比较好理解，就是在队列的尾部插入新的Node节点，但是需要注意的是由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过CAS自旋的方式保证了操作的线程安全性。</p></blockquote><p>OK，现在回到最开始的aquire(int arg)方法。现在通过addWaiter方法，已经把一个Node放到等待队列尾部了。而处于等待队列的结点是从头结点一个一个去获取资源的。具体的实现我们来看看acquireQueued方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed &#x3D; true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F; 自旋</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p &#x3D; node.predecessor();</span><br><span class="line">            &#x2F;&#x2F; 如果node的前驱结点p是head，表示node是第二个结点，就可以尝试去获取资源了</span><br><span class="line">            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 拿到资源后，将head指向该结点。</span><br><span class="line">                &#x2F;&#x2F; 所以head所指的结点，就是当前获取到资源的那个结点或null。</span><br><span class="line">                setHead(node); </span><br><span class="line">                p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                failed &#x3D; false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果自己可以休息了，就进入waiting状态，直到被unpark()</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里parkAndCheckInterrupt方法内部使用到了LockSupport.park(this)，顺便简单介绍一下park。</p><p>LockSupport类是Java 6 引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：</p></blockquote><ul><li>park(boolean isAbsolute, long time)：阻塞当前线程</li><li>unpark(Thread jthread)：使给定的线程停止阻塞</li></ul><p>所以<strong>结点进入等待队列后，是调用park使它进入阻塞状态的。只有头结点的线程是处于活跃状态的。</strong></p><p>当然，获取资源的方法除了acquire外，还有以下三个：</p><ul><li>acquireInterruptibly：申请可中断的资源（独占模式）</li><li>acquireShared：申请共享模式的资源</li><li>acquireSharedInterruptibly：申请可中断的资源（共享模式）</li></ul><blockquote><p>可中断的意思是，在线程中断时可能会抛出InterruptedException</p></blockquote><p>总结起来的一个流程图：</p><p><img src="https://img-blog.csdnimg.cn/20200417095103996.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>释放资源</strong></p><p>释放资源相比于获取资源来说，会简单许多。在AQS中只有一小段实现。源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h &#x3D; head;</span><br><span class="line">        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果状态是负数，尝试把它设置为0</span><br><span class="line">    int ws &#x3D; node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line">    &#x2F;&#x2F; 得到头结点的后继结点head.next</span><br><span class="line">    Node s &#x3D; node.next;</span><br><span class="line">    &#x2F;&#x2F; 如果这个后继结点为空或者状态大于0</span><br><span class="line">    &#x2F;&#x2F; 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消</span><br><span class="line">    if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 等待队列中所有还有用的结点，都向前移动</span><br><span class="line">        for (Node t &#x3D; tail; t !&#x3D; null &amp;&amp; t !&#x3D; node; t &#x3D; t.prev)</span><br><span class="line">            if (t.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                s &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果后继结点不为空，</span><br><span class="line">    if (s !&#x3D; null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参考资料</strong></p><p><a href="https://www.jianshu.com/p/da9d051dcc3d" target="_blank" rel="noopener">Java技术之AQS详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile</title>
      <link href="/2020/04/16/Volatile/"/>
      <url>/2020/04/16/Volatile/</url>
      
        <content type="html"><![CDATA[<p>在多线程并发编程中 <code>synchronized</code> 和 <code>volatile</code> 都扮演着重要的角色，<code>volatile</code> 是轻量级的 <code>synchronized</code>，它在多处理器开发中保证了共享变量的“可见性”。</p><a id="more"></a><p>在多线程并发编程中 <code>synchronized</code> 和 <code>volatile</code> 都扮演着重要的角色，<code>volatile</code> 是轻量级的 <code>synchronized</code>，它在多处理器开发中保证了共享变量的“可见性”。</p><h5 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h5><ul><li>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值。</li><li>所谓内存可见性，指的是当一个线程对<code>volatile</code>修饰的变量进行写操作（比如step 2）时，会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对<code>volatile</code>修饰的变量进行读操作（比如step 3）时，会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class VolatileDemo &#123;</span><br><span class="line">    int a &#x3D; 0;</span><br><span class="line">    volatile boolean flag &#x3D; false;</span><br><span class="line"></span><br><span class="line">    public void writer() &#123;</span><br><span class="line">        a &#x3D; 1; &#x2F;&#x2F; step 1</span><br><span class="line">        flag &#x3D; true; &#x2F;&#x2F; step 2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reader() &#123;</span><br><span class="line">        if (flag) &#123; &#x2F;&#x2F; step 3</span><br><span class="line">            System.out.println(a); &#x2F;&#x2F; step 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    VolatileDemo volatileDemo &#x3D; new VolatileDemo();</span><br><span class="line">    Thread a &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            volatileDemo.writer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread b &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            volatileDemo.reader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    a.start();</span><br><span class="line">    b.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候的输出结果为：<code>1</code></p><p>而如果flag变量没有用volatile修饰，在step 2，线程A的本地内存里面的变量就不会立即更新到主内存，那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量的值a = 0，flag = false。</p><h5 id="禁止重排序"><a href="#禁止重排序" class="headerlink" title="禁止重排序"></a>禁止重排序</h5><p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。</p><p>在JSR-133之前的旧的Java内存模型中，是允许volatile变量与普通变量重排序的。那上面的案例中，可能就会被重排序成下列时序来执行：</p><ul><li>线程A写volatile变量，step 2，设置flag为true；</li><li>线程B读同一个volatile，step 3，读取到flag为true；</li><li>线程B读普通变量，step 4，读取到 a = 0；</li><li>线程A修改普通变量，step 1，设置 a = 1；</li></ul><p>可见，如果volatile变量与普通变量发生了重排序，虽然volatile变量能保证内存可见性，也可能导致普通变量读取错误。</p><p>所以在旧的内存模型中，volatile的写-读就不能与锁的释放-获取具有相同的内存语义了。为了提供一种比锁更轻量级的线程间的通信机制，JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序。</p><h5 id="volatile的非原子性"><a href="#volatile的非原子性" class="headerlink" title="volatile的非原子性"></a>volatile的非原子性</h5><ul><li><code>volatile</code>虽然增加了实例变量在多个线程之间的可见性，但是却不具备通同步性，也就是不具备原子性。</li><li>使用<code>volatile</code>关键字之后，可以强制从公共内存中读取变量的值。</li><li><code>Volatile</code>只能保证对单个<code>volatile</code>变量的读/写具有原子性。<h5 id="volatile的用途"><a href="#volatile的用途" class="headerlink" title="volatile的用途"></a>volatile的用途</h5>volatile的主要使用场合是在多个线程中可以感知到实例变量被更改了，也就是多线程读取共享变量的时可以获得最新的值来使用。</li></ul><p>在保证内存可见性这一点上，<code>volatile</code>有着与锁相同的内存语义，所以可以作为一个“轻量级”的锁来使用。但由于<code>volatile</code>仅仅保证对单个<code>volatile</code>变量的读/写具有原子性，而锁可以保证整个临界区代码的执行具有原子性。所以在功能上，锁比<code>volatile</code>更强大；在性能上，volatile更有优势。</p><p>比如我们熟悉的单例模式，其中有一种实现方式是“双重锁检查”，比如这样的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Singleton instance; &#x2F;&#x2F; 不使用volatile关键字</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 双重锁检验</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 第7行</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    instance &#x3D; new Singleton(); &#x2F;&#x2F; 第10行</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="synchronized和volatile对比"><a href="#synchronized和volatile对比" class="headerlink" title="synchronized和volatile对比"></a>synchronized和volatile对比</h5><ul><li>volatile是线程同步的轻量级的实现，所以volatile性能比synchronized要好，并且volatile只能修饰变量，而synchronized可以修饰方法以及代码块。</li><li>多线程访问volatile不会发生阻塞，而synchronized会发生阻塞。</li><li>volatile能保证数据的可见性，但不能保证原子性。而synchronized可以保证原子性，也可以间接保证可见性，因为synchronized会将私有内存和公共内存中的数据做同步，所以更加推荐使用synchronized。</li><li>volatile的关注点在于解决变量在多个线程之间的可见性，而synchronized的关注点在于解决多个线程之间访问资源的同步性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共享内存并发模型</title>
      <link href="/2020/04/16/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/04/16/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>JMM（Java内存模型）通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。</p><a id="more"></a><p><strong>首先先了解一下Java运行时内存的划分：</strong><br><img src="https://img-blog.csdnimg.cn/20200417093342499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>对于每一个线程来说，栈都是私有的，而堆是共有的。而在堆中的变量是共享的，称为<strong>共享变量</strong>。所以，内存可见性是针对的共享变量。</p><p><strong>JMM（Java内存模型）通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200417093430882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在这里可以看到所有的共享变量都是在主内存中的。如果线程B想去获取线程A的变量，线程A需要刷新变量到主内存中，然后线程B再去主内存中读取线程A刚刚刷新的共享变量，所以说线程A和线程B之间的通信，必须要经过主内存才可以实现。</p><p>根据JMM的规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取。</strong>所以线程B并不是直接去主内存中读取共享变量的值，而是先在本地内存B中找到这个共享变量，发现这个共享变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B再读取本地内存B中的新值。</p>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程的状态</title>
      <link href="/2020/04/16/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/"/>
      <url>/2020/04/16/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>线程主要有NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED这六种状态。</p><a id="more"></a><p>首先从一张图片来直观的了解一下线程的状态，图片来源于网络。<br><img src="https://img-blog.csdnimg.cn/20200318105953491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后再看一下<code>Thread.State</code>这个枚举类，定义了线程的六种状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public enum State &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 处于NEW状态的线程此时尚未启动。</span><br><span class="line">     * 指的是线程建好了，但是并没有调用Thread实例的start()方法。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 表示当前线程正在运行中。处于RUNNABLE状态的线程在Java虚拟机中运行，也有可能在等待其他系统资源（比如I&#x2F;O）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 阻塞状态。处于BLOCKED状态的线程正等待锁的释放以进入同步区。</span><br><span class="line">     * 举个例子：比如你在小卖部窗口买东西（假设小卖部只有一个窗口），你前面有一个正在买东西，这个时候你必须要等待前面的人走了之后才可以买东西。</span><br><span class="line">     * 假设你是线程t2，你前面的那个人是线程t1。此时t1占有了锁（小卖部唯一的窗口），t2正在等待锁的释放，所以此时t2就处于BLOCKED状态。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 等待状态。处于等待状态的线程变成RUNNABLE状态需要其他线程唤醒。</span><br><span class="line">     * 举个例子：这个时候经过你几分钟的等待，前面的人（t1）买好东西走了，这个时候你（t2）获得了锁（就是来到了窗口前），</span><br><span class="line">     * 但是有个人非常不友好的把你叫走了（假设他是t3），这个时候你就不得不释放掉刚刚得到的锁，此时你的状态就是WAITING状态。</span><br><span class="line">     * 要是t3不主动唤醒你t2（notify、notifyAll..），可以说你t2只能一直等待了。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 超时等待状态。线程等待一个具体的时间，时间到后会被自动唤醒。</span><br><span class="line">     * 举个例子：t3唤醒你之后，你来到了小卖部窗口前。但是不巧的是又来了个人（t4）说让你等5分钟再买，去帮他拿一下快递。这时你还是线程t2，让你拿快递的人是线程t4。</span><br><span class="line">     * t4让t2等待了指定时间，t2先主动释放了锁。此时t2等待期间就属于TIMED_WATING状态。t2等待10分钟后，就自动唤醒，拥有了去争夺锁的资格。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 终止状态。此时线程已执行完毕。</span><br><span class="line">     * 举个例子：你已经买到了你想要的东西，整个线程结束。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="线程之间的转换"><a href="#线程之间的转换" class="headerlink" title="线程之间的转换"></a>线程之间的转换</h5><p><img src="https://img-blog.csdnimg.cn/2020031814324423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>BLOCKED与RUNNABLE状态的转换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadState &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        blockedTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void blockedTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread a &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;a&quot;);</span><br><span class="line">        Thread b &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        System.out.println(a.getName() + &quot;:&quot; + a.getState()); &#x2F;&#x2F; 输出？</span><br><span class="line">        System.out.println(b.getName() + &quot;:&quot; + b.getState()); &#x2F;&#x2F; 输出？</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void test() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:TIMED_WAITING</span><br><span class="line">b:BLOCKED</span><br></pre></td></tr></table></figure><ul><li>WAITING状态与RUNNABLE状态的转换</li></ul><p>使线程从RUNNABLE状态转为WAITING状态可以使用<code>Object.wait()</code>，<code>Thread.join()</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadState &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        blockedTest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void blockedTest() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Thread a &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;a&quot;);</span><br><span class="line">        Thread b &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                test();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;b&quot;);</span><br><span class="line"></span><br><span class="line">        a.start();</span><br><span class="line">        a.join();&#x2F;&#x2F; 这里调用join方法，join()方法不会释放锁，会一直等待当前线程执行完毕（转换为TERMINATED状态）。</span><br><span class="line">        b.start();</span><br><span class="line">        System.out.println(a.getName() + &quot;:&quot; + a.getState()); &#x2F;&#x2F; 输出？</span><br><span class="line">        System.out.println(b.getName() + &quot;:&quot; + b.getState()); &#x2F;&#x2F; 输出？</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized void test() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(2000L);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:TERMINATED</span><br><span class="line">b:TIMED_WAITING</span><br></pre></td></tr></table></figure><ul><li>TIMED_WAITING与RUNNABLE状态转换<br>TIMED_WAITING与WAITING状态类似，只是TIMED_WAITING状态等待的时间是指定的。<ul><li>Thread.sleep(long)：使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行，并不会释放锁。时间到后，线程会重新进入RUNNABLE状态。</li><li>Object.wait(long)：wait(long)方法使线程进入TIMED_WAITING状态。这里的wait(long)方法与无参方法wait()相同的地方是，都可以通过其他线程调用notify()或notifyAll()方法来唤醒。不同的地方是，有参方法wait(long)就算其他线程不来唤醒它，经过指定时间long之后它会自动唤醒，拥有去争夺锁的资格。</li><li>Thread.join(long)：join(long)使当前线程执行指定时间，并且使线程进入TIMED_WAITING状态。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized和锁</title>
      <link href="/2020/04/16/Synchronized%E5%92%8C%E9%94%81/"/>
      <url>/2020/04/16/Synchronized%E5%92%8C%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p><code>synchronized</code>这个关键字，它翻译成中文就是“同步”的意思。首先需要明确的一点是：Java多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁，也就是说我们常听到的类锁其实也是<strong>对象锁</strong>。</p><a id="more"></a><p>首先需要明确的一点是：Java多线程的锁都是基于对象的，Java中的每一个对象都可以作为一个锁，也就是说我们常听到的类锁其实也是<strong>对象锁</strong>。</p><p><code>synchronized</code>这个关键字，它翻译成中文就是“同步”的意思。</p><p>为避免竞争状态，应该防止多个线程同时进入程序的某一特定部分，程序中的这部分称为临界区。</p><p>通常使用<strong>synchronized</strong>关键字来给一段代码或一个方法上锁。</p><ul><li>关键字在实例方法上，锁为当前实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void instanceLock() &#123;</span><br><span class="line">    &#x2F;&#x2F; todo...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键字在静态方法上，锁为当前Class对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void classLock() &#123;</span><br><span class="line">    &#x2F;&#x2F; todo...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关键字在代码块上，锁为括号里面的对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void blockLock() &#123;</span><br><span class="line">    Object o &#x3D; new Object();</span><br><span class="line">    synchronized (o) &#123;</span><br><span class="line">        &#x2F;&#x2F; todo...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Java中的几种锁"><a href="#Java中的几种锁" class="headerlink" title="Java中的几种锁"></a>Java中的几种锁</h5><p>一个对象其实有四种锁状态，它们级别由低到高依次是：</p><ul><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ul><h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><ul><li>为什么要引入偏向锁？</li></ul><p>因为经过HotSpot的作者大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。</p><ul><li>偏向锁原理和升级过程</li></ul><p>当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</p><h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><ul><li>为什么要引入轻量级锁？</li></ul><p>轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。</p><ul><li>轻量级锁原理和升级过程</li></ul><p><strong>线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord）</strong>，然后使用<strong>CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；</strong></p><p>如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，<strong>线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。 自旋锁简单来说就是让线程2在循环中不断CAS</strong></p><p>但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，<strong>如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。</strong></p><p>几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻，锁降级发生在<code>Stop The World</code>期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级。如果想了解锁降级，请各位移步<a href="Java锁优化--JVM锁降级">这里</a>。</p><h5 id="synchronized实现的原理"><a href="#synchronized实现的原理" class="headerlink" title="synchronized实现的原理"></a>synchronized实现的原理</h5><p>这里借用方大大的文章，请移步<a href="https://www.infoq.cn/article/java-se-16-synchronized" target="_blank" rel="noopener">这里</a></p><h6 id="总结一下锁升级的过程"><a href="#总结一下锁升级的过程" class="headerlink" title="总结一下锁升级的过程"></a>总结一下锁升级的过程</h6><p><img src="https://img-blog.csdnimg.cn/20200319095959853.png" alt="在这里插入图片描述"></p><p>每一个线程在准备获取共享资源时： 第一步，检查MarkWord里面是不是放的自己的ThreadId ,如果是，表示当前线程是处于 “偏向锁” 。</p><p>第二步，如果MarkWord不是自己的ThreadId，锁升级，这时候，用CAS来执行切换，新的线程根据MarkWord里面现有的ThreadId，通知之前线程暂停，之前线程将Markword的内容置为空。</p><p>第三步，两个线程都把锁对象的HashCode复制到自己新建的用于存储锁的记录空间，接着开始通过CAS操作， 把锁对象的MarKword的内容修改为自己新建的记录空间的地址的方式竞争MarkWord。</p><p>第四步，第三步中成功执行CAS的获得资源，失败的则进入自旋 。</p><p>第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 。</p><p>第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p><h5 id="synchronized锁重入"><a href="#synchronized锁重入" class="headerlink" title="synchronized锁重入"></a>synchronized锁重入</h5><ul><li>关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁之后，再次请求此对象锁是可以可以再次得到这个对象的锁的。</li><li>“可重入锁”的概念是：自己可以获得自己内部锁。假设有线程t1获得了某个对象的锁，此时这个对象锁还没有被释放，想再次获得这个对象的锁的时候还是可以获得的，如果不可重入锁的话，就会造成死锁。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Callable、Future与FutureTask</title>
      <link href="/2020/04/16/Callable%E3%80%81Future%E4%B8%8EFutureTask/"/>
      <url>/2020/04/16/Callable%E3%80%81Future%E4%B8%8EFutureTask/</url>
      
        <content type="html"><![CDATA[<p>通常来说，我们使用<code>Runnable</code>和<code>Thread</code>来创建一个新的线程，但是它们是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p><a id="more"></a><p>通常来说，我们使用<code>Runnable</code>和<code>Thread</code>来创建一个新的线程，但是它们是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p><p>那么JDK提供了<code>Callable</code>接口与<code>Future</code>类为我们解决这个问题，这也是所谓的“异步”模型。</p><h5 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h5><p>可以看到<code>Callable</code>是一个函数式接口。同时<code>Callable</code>是有返回值的，并且支持泛型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那一般是怎么使用Callable的呢？Callable一般是配合线程池工具ExecutorService来使用的。这里举例介绍ExecutorService可以使用submit方法来让一个Callable接口执行。它会返回一个Future，我们后续的程序可以通过这个Future的get方法得到结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Callable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;call()方法&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(2);</span><br><span class="line">        Task task &#x3D; new Task();</span><br><span class="line">        Future&lt;String&gt; submit &#x3D; executorService.submit(task);</span><br><span class="line">        System.out.println(submit.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<code>call()方法</code></p><h5 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h5><p><code>Future</code>和<code>Callable</code>有着类似的地方，同样也是支持泛型和有返回结果。<br><code>Future</code>接口只有几个比较简单的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Attempts to cancel execution of this task.  This attempt will</span><br><span class="line">     * fail if the task has already completed, has already been cancelled,</span><br><span class="line">     * or could not be cancelled for some other reason. If successful,</span><br><span class="line">     * and this task has not started when &#123;@code cancel&#125; is called,</span><br><span class="line">     * this task should never run.  If the task has already started,</span><br><span class="line">     * then the &#123;@code mayInterruptIfRunning&#125; parameter determines</span><br><span class="line">     * whether the thread executing this task should be interrupted in</span><br><span class="line">     * an attempt to stop the task.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;After this method returns, subsequent calls to &#123;@link #isDone&#125; will</span><br><span class="line">     * always return &#123;@code true&#125;.  Subsequent calls to &#123;@link #isCancelled&#125;</span><br><span class="line">     * will always return &#123;@code true&#125; if this method returned &#123;@code true&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param mayInterruptIfRunning &#123;@code true&#125; if the thread executing this</span><br><span class="line">     * task should be interrupted; otherwise, in-progress tasks are allowed</span><br><span class="line">     * to complete</span><br><span class="line">     * @return &#123;@code false&#125; if the task could not be cancelled,</span><br><span class="line">     * typically because it has already completed normally;</span><br><span class="line">     * &#123;@code true&#125; otherwise</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns &#123;@code true&#125; if this task was cancelled before it completed</span><br><span class="line">     * normally.</span><br><span class="line">     *</span><br><span class="line">     * @return &#123;@code true&#125; if this task was cancelled before it completed</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean isCancelled();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns &#123;@code true&#125; if this task completed.</span><br><span class="line">     *</span><br><span class="line">     * Completion may be due to normal termination, an exception, or</span><br><span class="line">     * cancellation -- in all of these cases, this method will return</span><br><span class="line">     * &#123;@code true&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @return &#123;@code true&#125; if this task completed</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean isDone();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Waits if necessary for the computation to complete, and then</span><br><span class="line">     * retrieves its result.</span><br><span class="line">     *</span><br><span class="line">     * @return the computed result</span><br><span class="line">     * @throws CancellationException if the computation was cancelled</span><br><span class="line">     * @throws ExecutionException if the computation threw an</span><br><span class="line">     * exception</span><br><span class="line">     * @throws InterruptedException if the current thread was interrupted</span><br><span class="line">     * while waiting</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Waits if necessary for at most the given time for the computation</span><br><span class="line">     * to complete, and then retrieves its result, if available.</span><br><span class="line">     *</span><br><span class="line">     * @param timeout the maximum time to wait</span><br><span class="line">     * @param unit the time unit of the timeout argument</span><br><span class="line">     * @return the computed result</span><br><span class="line">     * @throws CancellationException if the computation was cancelled</span><br><span class="line">     * @throws ExecutionException if the computation threw an</span><br><span class="line">     * exception</span><br><span class="line">     * @throws InterruptedException if the current thread was interrupted</span><br><span class="line">     * while waiting</span><br><span class="line">     * @throws TimeoutException if the wait timed out</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>cancel()</code>注意是试图取消，并不一定能取消成功。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。boolean类型的返回值是“是否取消成功”的意思。参数paramBoolean表示是否采用中断的方式取消线程执行。</li></ul><h5 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h5><p><code>FutureTask</code>的几个状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * The run state of this task, initially NEW.  The run state</span><br><span class="line">    * transitions to a terminal state only in methods set,</span><br><span class="line">    * setException, and cancel.  During completion, state may take on</span><br><span class="line">    * transient values of COMPLETING (while outcome is being set) or</span><br><span class="line">    * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="line">    * cancel(true)). Transitions from these intermediate to final</span><br><span class="line">    * states use cheaper ordered&#x2F;lazy writes because values are unique</span><br><span class="line">    * and cannot be further modified.</span><br><span class="line">    *</span><br><span class="line">    * Possible state transitions:</span><br><span class="line">    * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">    * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">    * NEW -&gt; CANCELLED</span><br><span class="line">    * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line">    *&#x2F;</span><br><span class="line">private volatile int state;</span><br><span class="line">private static final int NEW          &#x3D; 0;</span><br><span class="line">private static final int COMPLETING   &#x3D; 1;</span><br><span class="line">private static final int NORMAL       &#x3D; 2;</span><br><span class="line">private static final int EXCEPTIONAL  &#x3D; 3;</span><br><span class="line">private static final int CANCELLED    &#x3D; 4;</span><br><span class="line">private static final int INTERRUPTING &#x3D; 5;</span><br><span class="line">private static final int INTERRUPTED  &#x3D; 6;</span><br></pre></td></tr></table></figure><ul><li>先看一下<code>FutureTask</code>类</li></ul><p>可以看到<code>FutureTask</code>是实现了<code>RunnableFuture</code>接口的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>再看一下<code>RunnableFuture</code>接口</li></ul><p>可以看到<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * A &#123;@link Future&#125; that is &#123;@link Runnable&#125;. Successful execution of</span><br><span class="line"> * the &#123;@code run&#125; method causes completion of the &#123;@code Future&#125;</span><br><span class="line"> * and allows access to its results.</span><br><span class="line"> * @see FutureTask</span><br><span class="line"> * @see Executor</span><br><span class="line"> * @since 1.6</span><br><span class="line"> * @author Doug Lea</span><br><span class="line"> * @param &lt;V&gt; The result type returned by this Future&#39;s &#123;@code get&#125; method</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>那FutureTask类有什么用？为什么要有一个FutureTask类？前面说到了Future只是一个接口，而它里面的cancel，get，isDone等方法要自己实现起来都是非常复杂的。所以JDK提供了一个FutureTask类来供我们使用。</p></li><li><p>修改一下上面的代码，改用<code>FutureTask</code></p></li></ul><p>使用上与第一个Demo有一点小的区别。首先，调用submit方法是没有返回值的。这里实际上是调用的submit(Runnable task)方法，而上面的Demo，调用的是submit(Callable<T> task)方法。</p><p>然后，这里是使用FutureTask直接取get取值，而上面的Demo是通过submit方法返回的Future去取值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Task implements Callable &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String call() throws Exception &#123;</span><br><span class="line">        return &quot;call()方法&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newFixedThreadPool(2);</span><br><span class="line">        FutureTask futureTask &#x3D; new FutureTask(new Task());</span><br><span class="line">        executorService.submit(futureTask);</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread类和Runnable接口</title>
      <link href="/2020/04/16/Thread%E7%B1%BB%E5%92%8CRunnable%E6%8E%A5%E5%8F%A3/"/>
      <url>/2020/04/16/Thread%E7%B1%BB%E5%92%8CRunnable%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>如果我们需要有一个“线程”类，JDK提供了<code>Thread</code>类和<code>Runnalble</code>接口来让我们实现自己的“线程”类。继承Thread类，并重写run方法（注意：Thread类实现了Runnable接口），实现Runnable接口的run方法。</p><a id="more"></a><p>如果我们需要有一个“线程”类，JDK提供了<code>Thread</code>类和<code>Runnalble</code>接口来让我们实现自己的“线程”类。</p><ul><li>继承Thread类，并重写run方法（注意：Thread类实现了Runnable接口）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>实现Runnable接口的run方法</li></ul><h5 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static class MyThread extends Thread &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;MyThread&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Thread t1 &#x3D; new MyThread();</span><br><span class="line">t1.start();</span><br><span class="line">System.out.println(t1.getName() + &quot;运行结束&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>start()</code>方法启动一个线程，注意不能多次调用<code>start()</code>方法，否则会抛出异常。</p><h5 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static class MyThread1 implements Runnable &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;MyThread1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new Thread(new MyThread1()).start();</span><br><span class="line">System.out.println(&quot;运行结束&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Thread类的几个常用方法"><a href="#Thread类的几个常用方法" class="headerlink" title="Thread类的几个常用方法"></a>Thread类的几个常用方法</h5><ul><li><code>currentThread()</code>：静态方法，返回对当前正在执行的线程对象的引用</li></ul><p>该方法可以可以返回代码段正在被哪个线程调用的信息。实例代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果会在控制台打印<code>main</code>，证明main方法正在被名字叫main的线程调用。<br>修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">public MyThread() &#123;</span><br><span class="line">System.out.println(&quot;构造方法打印：&quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;run方法打印：&quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Thread t1 &#x3D; new MyThread();</span><br><span class="line">t1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，证明构造函数是被main线程调用的，而<code>run()</code>方法是被名叫“Thread-0”调用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造方法打印：main</span><br><span class="line">run方法打印：Thread-0</span><br></pre></td></tr></table></figure><p>再次修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static class MyThread extends Thread &#123;</span><br><span class="line"></span><br><span class="line">public MyThread() &#123;</span><br><span class="line">System.out.println(&quot;构造方法打印：&quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;run方法打印：&quot; + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class MyThread1 implements Runnable &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;MyThread1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Thread t1 &#x3D; new MyThread();</span><br><span class="line">&#x2F;&#x2F; t1.start();</span><br><span class="line">t1.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，证明两个线程都是被main调用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">构造方法打印：main</span><br><span class="line">run方法打印：main</span><br></pre></td></tr></table></figure><ul><li><code>isAlive()</code>方法：是判断当前线程是不是出于活动状态</li><li><code>sleep()</code>方法：静态方法，使当前线程睡眠一段时间</li><li><code>start()</code>：开始执行线程的方法，java虚拟机会调用线程内的run()方法</li><li><code>yield()</code>：yield在英语里有放弃的意思，同样，这里的yield()指的是当前线程愿意让出对当前处理器的占用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static class MyThread extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        long beginTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5000000; i++) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            count &#x3D; count + (i + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;用时：&quot; + (endTime - beginTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Thread t1 &#x3D; new MyThread();</span><br><span class="line">    t1.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>Thread.yield();</code>这句代码被注释掉之后，输出结果为<code>用时：4</code>。 当<code>Thread.yield();</code>这句代码没有被注释掉之后，输出结果为<code>用时：1515</code>。所以证明<code>yield()</code>方法会放弃当前资源，将CPU让给其他资源做事情，所以导致速度变慢。</p><ul><li><code>Thread.stop()</code>：暴力停止线程， 不推荐这么做。</li><li><code>Thread.interrupt()</code>：推荐使用此方法。此方法是在当前线程中打印一个停止的标记，并不是真正的停止线程。<ul><li>this.interrupted()，测试当前线程是否已经中断，执行后具有将状态标志清除为false的功能</li><li>this.isInterrupted()，测试线程Thread对象是否已经是中断状态，但不会清除状态标志</li></ul></li></ul><h5 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h5><p>User Thread（用户线程）和Daemon Thread（守护线程）从本质上来说并没有什么区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p><h5 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h5><p>首先看下JDK对线程优先级的设置有哪些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">  * The minimum priority that a thread can have.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public final static int MIN_PRIORITY &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * The default priority that is assigned to a thread.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public final static int NORM_PRIORITY &#x3D; 5;</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * The maximum priority that a thread can have.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> public final static int MAX_PRIORITY &#x3D; 10;</span><br></pre></td></tr></table></figure><p>那么JDK是通过什么方法设置线程的优先级呢？答案是通过<code>setPriority(int newPriority)</code>这个方法设置优先级，参数<code>newPriority</code>越大，优先级越高。但是需要注意的是优先级虽然高，占得CPU资源较多，但是也不能保证优先级高的线程全部执行完，因为<code>优先级具有随机性</code>。</p><h5 id="Thread类与Runnable接口的比较"><a href="#Thread类与Runnable接口的比较" class="headerlink" title="Thread类与Runnable接口的比较"></a>Thread类与Runnable接口的比较</h5><p>实现一个自定义的线程类，可以有继承Thread类或者实现Runnable接口这两种方式，它们之间有什么优劣呢？</p><ul><li>由于Java“单继承，多实现”的特性，Runnable接口使用起来比Thread更灵活。</li><li>Runnable接口出现更符合面向对象，将线程单独进行对象的封装。</li><li>Runnable接口出现，降低了线程对象和线程任务的耦合性。</li><li>如果使用线程时不需要使用Thread类的诸多方法，显然使用Runnable接口更为轻量。</li></ul><p>所以，我们通常优先使用“实现Runnable接口”这种方式来自定义线程类。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul><li><a href="https://www.cnblogs.com/yanggb/p/11702843.html" target="_blank" rel="noopener">Java中的守护线程</a></li><li>《Java多线程编程核心技术》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程的基本概念</title>
      <link href="/2020/04/16/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/04/16/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h5 id="进程产生的背景"><a href="#进程产生的背景" class="headerlink" title="进程产生的背景"></a>进程产生的背景</h5><p>进程产生的背景：最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在思考或者输入时，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。</p><a id="more"></a><p>最初的计算机只能接受一些特定的指令，用户每输入一个指令，计算机就做出一个操作。当用户在思考或者输入时，计算机就在等待。这样效率非常低下，在很多时候，计算机都处在等待状态。</p><ul><li>批处理操作系统</li></ul><p>后来有了批处理操作体统,把一系列需要操作的指令写下来，形成一个清单，一次性交给计算机。用户将多个需要执行的程序写在磁带上，然后交由计算机去读取并逐个执行这些程序，并将输出结果写在另一个磁带上。</p><p>批处理操作系统在一定程度上提高了计算机的效率，但是由于批处理操作系统的指令运行方式仍然是串行的，内存中始终只有一个程序在运行，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于I/O操作、网络等原因阻塞，所以批处理操作效率也不高。</p><ul><li>进程的提出</li></ul><p>人们对于计算机的性能要求越来越高，现有的批处理操作系统并不能满足人们的需求，而批处理操作系统的瓶颈在于内存中只存在一个程序，那么内存中能不能存在多个程序呢？这是人们亟待解决的问题。</p><p>于是，科学家们提出了<strong>进程</strong>的概念。</p><p><strong>进程就是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰。同时进程保存着程序每一个时刻运行的状态</strong>。</p><p>此时，CPU采用时间片轮转的方式运行进程：CPU为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且CPU分配给另一个进程（这个过程叫做上下文切换）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。当进程暂停时，它会保存当前进程的状态（进程标识，进程使用的资源等），在下一次切换回来时根据之前保存的状态进行恢复，接着继续执行。</p><p>使用进程+CPU时间片轮转方式的操作系统，在宏观上看起来同一时间段执行多个任务，换句话说，<strong>进程让操作体统的并发成为了可能</strong>。虽然并发从宏观上看有多个任务在执行，但在事实上，对于单核CPU来说，任意具体时刻都只有一个任务在占用CPU资源。</p><p>虽然进程的出现，使得操作系统的性能大大提升，但是随着时间的推移，人们并不满足一个进程在一段时间只能做一件事情，如果一个进程有多个子任务时，只能逐个得执行这些子任务，很影响效率，此时<strong>线程</strong>出现了。</p><h5 id="线程的提出"><a href="#线程的提出" class="headerlink" title="线程的提出"></a>线程的提出</h5><p>那么能不能让这些子任务同时执行呢？<strong>于是科学家们又提出了线程的概念，让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。</strong></p><p>总之，进程和线程的提出极大的提高了操作提供的性能。<strong>进程让操作系统的并发性成为了可能，而线程让进程的内部并发成为了可能。</strong></p><p><strong>多进程的方式也可以实现并发，为什么我们要使用多线程？</strong></p><p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：<br>    - 进程间的通信比较复杂，而线程间的通信比较简单，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。<br>    - 进程是重量级的，而线程是轻量级的，故多线程方式的系统开销更小。</p><h5 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h5><p><strong>进程是一个独立的运行环境，而线程是在进程中执行的一个任务</strong>。他们两个本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）：</p><ul><li><p>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</p></li><li><p>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。</p></li><li><p>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。</p></li><li><p>另外一个重要区别是，进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位 。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java多线程进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，多线程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
