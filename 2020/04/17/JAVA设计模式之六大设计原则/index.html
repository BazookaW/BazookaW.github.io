<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    JAVA设计模式之六大设计原则 |
    
    Wry&#39;s blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-JAVA设计模式之六大设计原则" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      JAVA设计模式之六大设计原则
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2020/04/17/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" class="article-date">
  <time datetime="2020-04-17T02:44:05.000Z" itemprop="datePublished">2020-04-17</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        

                                            

                                                
                                                                    <p>在程序设计中，我们通常要遵循以下六大原则：单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和开闭原则。</p>
<a id="more"></a>

<p>在程序设计中，我们通常要遵循以下六大原则：</p>
<p><img src="https://img-blog.csdn.net/20181016095505330?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdjaGVuZ21pbmcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><ul>
<li>官方定义：<ul>
<li>就一个类(接口、结构体、方法等等)而言，有且仅有一个引起它变化的原因。</li>
</ul>
</li>
<li>个人理解：<ul>
<li>通俗的来讲做一件事就是专注做一件事，不可以三心二意。任务对象只是专注于一项职责，不去承担太多的责任。当任务对象的职责发生变化时，不会对其他的对象产生影响。</li>
</ul>
</li>
<li>遵循单一职责原的优点：<ul>
<li>可以大大降低耦合度。</li>
<li>降低类的复杂度。</li>
<li>提高类的可读性。</li>
<li>降低因变更而引起的风险。</li>
<li>提高类的复用性和可维护性。</li>
</ul>
</li>
<li>单一职责应用：<ul>
<li>背景：有一个类A，他需要负责T1和T2。但是当职责T1因为需求而改变类A的时候，就会对职责T2造成影响，导致T2不能正常工作。</li>
<li>解决办法：针对职责T1创建类A，针对职责T2创建类B。这样就可以达到当修改类A时不会对职责T2造成影响，当修改类B时不会对职责T1造成影响。</li>
</ul>
</li>
</ul>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><ul>
<li>官方定义：<ul>
<li>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</li>
</ul>
</li>
<li>个人理解：<ul>
<li>继承必须确保父类所拥有的性质在子类中仍然成立。</li>
<li>或者说子类可以扩展父类的功能，但不能改变父类原有的功能。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>子类的方法实现父类的抽象方法时，方法的返回值要比父类的返回值更加严谨。</li>
</ul>
</li>
<li>继承是面向对象的三大特性之一，在程序设计方面带来了很大的便利性，但是同时也存在一些不好的地方：<code>增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</code></li>
<li>经典案例之正方形不是长方形：<ul>
<li>在大众的认知范围内长方形的长和宽是不相等的，正方形的长和宽是相等的，正方形属于特殊的长方形。</li>
<li>先定义一个长方形类</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">	private int width;</span><br><span class="line">	private int height;</span><br><span class="line"></span><br><span class="line">	public int getWidth() &#123;</span><br><span class="line">		return width;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setWidth(int width) &#123;</span><br><span class="line">		this.width &#x3D; width;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getHeight() &#123;</span><br><span class="line">		return height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setHeight(int height) &#123;</span><br><span class="line">		this.height &#x3D; height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Rectangle(int width, int height) &#123;</span><br><span class="line">		this.width &#x3D; width;</span><br><span class="line">		this.height &#x3D; height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int area() &#123;</span><br><span class="line">		return width * height;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>再定义一个正方形类，继承自长方形类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Square extends Rectangle &#123;</span><br><span class="line"></span><br><span class="line">	private int width;</span><br><span class="line"></span><br><span class="line">	public int getWidth() &#123;</span><br><span class="line">		return width;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setWidth(int width) &#123;</span><br><span class="line">		this.width &#x3D; width;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Square(int width, int height) &#123;</span><br><span class="line">		super(width, height);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * 重写 area()</span><br><span class="line">	 * </span><br><span class="line">	 * @see design.Rectangle#area()</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public int area() &#123;</span><br><span class="line">		return width * width;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Rectangle rectangle &#x3D; new Rectangle(10, 20);</span><br><span class="line">		System.out.println(&quot;面积：&quot; + rectangle.area());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 输出结果为面积：200</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Tester &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Square rectangle &#x3D; new Square(10, 20);</span><br><span class="line">		System.out.println(&quot;面积：&quot; + rectangle.area());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; 输出结果为面积：0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分析：为什么当<code>Rectangle</code>替换为<code>Square</code>之后，面积的结果出错了呢？因为在<code>Square</code>类里重写了<code>area()</code>方法，很明显违背了里氏替换原则，改变了父类的原有功能，所以导致输出结果不对。</li>
</ul>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒置原则就是面向对象设计的主要手段。</p>
<ul>
<li>官方定义：<ul>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</li>
</ul>
</li>
<li>个人理解：<ul>
<li>依赖倒置原则的核心思想就是让我们<code>面向接口编程</code>。</li>
<li>抽象是面向对象的三大特性之一，相对于细节的多变性，抽象的东西要稳定的多。在Java中抽象指的就是接口和抽象类，接口和抽象类只是定义好规范和规则，而不去关注任何实现，具体的实现都交给实现类去关注。</li>
</ul>
</li>
<li>应用场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了（copy自网上）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Book&#123;</span><br><span class="line">	public String getContent()&#123;</span><br><span class="line">		return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Mother&#123;</span><br><span class="line">	public void narrate(Book book)&#123;</span><br><span class="line">		System.out.println(&quot;妈妈开始讲故事&quot;);</span><br><span class="line">		System.out.println(book.getContent());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Mother mother &#x3D; new Mother();</span><br><span class="line">		mother.narrate(new Book());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">妈妈开始讲故事</span><br><span class="line">很久很久以前有一个阿拉伯的故事……</span><br></pre></td></tr></table></figure>

<p>但是现在问题来了，当我修改了Book类，由原先的读书变成读报纸，这个时候Mother类就不会了，那么这个问题怎么解决呢？</p>
<p>两种方法解决：    </p>
<pre><code>①第一种：直接去修改Mother类，将Book类直接替换成Newspaper类。这样是可以解决一时的问题，但是将来我不仅仅是读书，而且还要读邮件等等呢，Mother和Book之间的耦合性太高了，所以不是一个好的办法。
②第二种：我们引入一个抽象的接口IReader。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface IReader&#123;</span><br><span class="line">	public String getContent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Newspaper implements IReader &#123;</span><br><span class="line">	public String getContent()&#123;</span><br><span class="line">		return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Book implements IReader&#123;</span><br><span class="line">	public String getContent()&#123;</span><br><span class="line">		return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Mother&#123;</span><br><span class="line">	public void narrate(IReader reader)&#123;</span><br><span class="line">		System.out.println(&quot;妈妈开始讲故事&quot;);</span><br><span class="line">		System.out.println(reader.getContent());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Mother mother &#x3D; new Mother();</span><br><span class="line">		mother.narrate(new Book());</span><br><span class="line">		mother.narrate(new Newspaper());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">妈妈开始讲故事</span><br><span class="line">很久很久以前有一个阿拉伯的故事……</span><br><span class="line">妈妈开始讲故事</span><br><span class="line">林书豪17+9助尼克斯击败老鹰……</span><br></pre></td></tr></table></figure>
<p>这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。</p>
<ul>
<li>最佳实践<ul>
<li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。</li>
<li>变量的显示类型尽量是接口或者是抽象类。</li>
<li>任何类都不应该从具体类派生。</li>
<li>尽量不要覆写基类的方法。</li>
<li>结合里氏替换原则使用。</li>
</ul>
</li>
</ul>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><ul>
<li>官方定义：<ul>
<li>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</li>
</ul>
</li>
<li>个人理解：<ul>
<li>单从字面上理解：使用多个隔离的接口，而不是使用单一的接口。</li>
<li>接口隔离原则的本意是降低类之间的耦合性。在大型的软件设计中，为了方便维护和扩展，降低类之间的依赖和耦合是很必要的。</li>
<li>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。</li>
</ul>
</li>
<li>举一反三<ul>
<li>一开始我自己觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。</li>
<li>其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。</li>
<li>其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</li>
</ul>
</li>
<li>最佳实践：<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
</li>
</ul>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><ul>
<li>官方定义：<ul>
<li>一个对象应该对其他对象保持最少的了解。</li>
</ul>
</li>
<li>个人理解：<ul>
<li>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</li>
<li>也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。</li>
<li>当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，就是说可扩展性很好。</li>
</ul>
</li>
<li>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;总公司员工</span><br><span class="line">class Employee&#123;</span><br><span class="line">	private String id;</span><br><span class="line">	public void setId(String id)&#123;</span><br><span class="line">		this.id &#x3D; id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getId()&#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;分公司员工</span><br><span class="line">class SubEmployee&#123;</span><br><span class="line">	private String id;</span><br><span class="line">	public void setId(String id)&#123;</span><br><span class="line">		this.id &#x3D; id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getId()&#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class SubCompanyManager&#123;</span><br><span class="line">	public List&lt;SubEmployee&gt; getAllEmployee()&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list &#x3D; new ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">		for(int i&#x3D;0; i&lt;100; i++)&#123;</span><br><span class="line">			SubEmployee emp &#x3D; new SubEmployee();</span><br><span class="line">			&#x2F;&#x2F;为分公司人员按顺序分配一个ID</span><br><span class="line">			emp.setId(&quot;分公司&quot;+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class CompanyManager&#123;</span><br><span class="line"> </span><br><span class="line">	public List&lt;Employee&gt; getAllEmployee()&#123;</span><br><span class="line">		List&lt;Employee&gt; list &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">		for(int i&#x3D;0; i&lt;30; i++)&#123;</span><br><span class="line">			Employee emp &#x3D; new Employee();</span><br><span class="line">			&#x2F;&#x2F;为总公司人员按顺序分配一个ID</span><br><span class="line">			emp.setId(&quot;总公司&quot;+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printAllEmployee(SubCompanyManager sub)&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list1 &#x3D; sub.getAllEmployee();</span><br><span class="line">		for(SubEmployee e:list1)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		List&lt;Employee&gt; list2 &#x3D; this.getAllEmployee();</span><br><span class="line">		for(Employee e:list2)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		CompanyManager e &#x3D; new CompanyManager();</span><br><span class="line">		e.printAllEmployee(new SubCompanyManager());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class SubCompanyManager&#123;</span><br><span class="line">	public List&lt;SubEmployee&gt; getAllEmployee()&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list &#x3D; new ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">		for(int i&#x3D;0; i&lt;100; i++)&#123;</span><br><span class="line">			SubEmployee emp &#x3D; new SubEmployee();</span><br><span class="line">			&#x2F;&#x2F;为分公司人员按顺序分配一个ID</span><br><span class="line">			emp.setId(&quot;分公司&quot;+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">	public void printEmployee()&#123;</span><br><span class="line">		List&lt;SubEmployee&gt; list &#x3D; this.getAllEmployee();</span><br><span class="line">		for(SubEmployee e:list)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class CompanyManager&#123;</span><br><span class="line">	public List&lt;Employee&gt; getAllEmployee()&#123;</span><br><span class="line">		List&lt;Employee&gt; list &#x3D; new ArrayList&lt;Employee&gt;();</span><br><span class="line">		for(int i&#x3D;0; i&lt;30; i++)&#123;</span><br><span class="line">			Employee emp &#x3D; new Employee();</span><br><span class="line">			&#x2F;&#x2F;为总公司人员按顺序分配一个ID</span><br><span class="line">			emp.setId(&quot;总公司&quot;+i);</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void printAllEmployee(SubCompanyManager sub)&#123;</span><br><span class="line">		sub.printEmployee();</span><br><span class="line">		List&lt;Employee&gt; list2 &#x3D; this.getAllEmployee();</span><br><span class="line">		for(Employee e:list2)&#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><ul>
<li>官方定义：<ul>
<li>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</li>
</ul>
</li>
<li>个人理解：<ul>
<li>如果修改或者添加一个功能，应该是通过扩展原来的代码，而不是通过修改原来的代码。 </li>
</ul>
</li>
<li>应用场景：略。</li>
</ul>
<p>总的来说，程序设计尽量的贴近软件编程的总的原则：高内聚，低耦合。</p>
<p>参考资料：<a href="https://blog.csdn.net/column/details/pattern.html" target="_blank" rel="noopener">https://blog.csdn.net/column/details/pattern.html</a></p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://wry1610.com/2020/04/17/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" data-id="ck9m8ngyh000ss8hpgz3jfqzs" class="article-share-link">
                                            分享
                                        </a>
                                        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%EF%BC%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">软件工程，设计模式</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2020/04/17/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-Template-Method-Pattern/" class="article-nav-link">
        <strong class="article-nav-caption">前一篇</strong>
        <div class="article-nav-title">
          
            模板方法模式(Template Method Pattern)
          
        </div>
      </a>
    
    
      <a href="/2020/04/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-Singleton-Pattern/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">单例模式(Singleton Pattern)</div>
      </a>
    
  </nav>


            

                
                    
                        
  <div class="gitalk" id="gitalk-container"></div>
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

  
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

  
<script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>

  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'dc4bc5e8db8ad0c02feb',
      clientSecret: 'e34658b398507219c612f0217783e96033c4cd4b',
      repo: 'BazookaW.github.io',
      owner: 'BazookaW',
      admin: ['BazookaW'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

                            

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 Wry&#39;s blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean" target="_blank" rel="noopener">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/favicon.ico" alt="Wry&#39;s blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">首页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/category">分类</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>

<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>




  
<script src="/js/tocbot.min.js"></script>

  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>



<script src="/js/ocean.js"></script>


</body>
</html>